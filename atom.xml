<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xusheng.online/"/>
  <updated>2020-09-13T12:40:43.724Z</updated>
  <id>https://blog.xusheng.online/</id>
  
  <author>
    <name>Hsum</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jetpack App Startup</title>
    <link href="https://blog.xusheng.online/2020/07/19/Jetpack-App-Startup/"/>
    <id>https://blog.xusheng.online/2020/07/19/Jetpack-App-Startup/</id>
    <published>2020-07-19T11:34:05.000Z</published>
    <updated>2020-09-13T12:40:43.724Z</updated>
    
    <content type="html"><![CDATA[<p>App Startup 是Jetpack套件新增的功能。它为应用程序提供类一种更加高效的方式来初始化组件的方式。</p><p>下面我们就来了解一下App Startup的使用方法和原理。</p><h3 id="1-开始使用"><a href="#1-开始使用" class="headerlink" title="1. 开始使用"></a>1. 开始使用</h3><p><strong>导入依赖</strong></p><p>为了使用App Startup，我们需要将它的依赖添加到<code>build.gradle</code>中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.startup:startup-runtime:1.0.0-alpha03&quot;</span></span><br></pre></td></tr></table></figure><p><strong>初始化组件</strong></p><p>初始化组件时需要我们自定义实现<code>Initializer</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化组件A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAAInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Int</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;AAAInitializer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;create: &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> listOf(BBBInitializer::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化组件B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBBInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Int</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BBBInitializer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;create: &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> listOf(CCCInitializer::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化组件C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCCInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Int</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CCCInitializer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;create: &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义时<code>Initializer</code>，必须实现2种方法：</p><ul><li><p><code>create(context)</code>：提供<code>ApplicationContext</code>并初始化组件。</p></li><li><p><code>dependencies()</code>：返回在初始化当前依赖项之前需要初始化的依赖项列表。</p><p>设置<code>Initializer</code>在应用启动时运行的顺序。如果<code>AAAInitializer</code>依赖<code>BBBInitializer</code>，并且<code>BBBInitializer</code>依赖<code>CCCInitializer</code>，那么<code>CCCInitializer</code>首先运行，其次是<code>BBBInitializer</code>，最后是<code>AAAInitializer</code>。</p></li></ul><p><strong>注册Initializer</strong></p><p>对于要在应用程序启动时自动初始化的组件，需要在AndroidManifest文件中的<code>&lt;meta-data&gt;</code>条目中对其<code>Initializer</code>进行声明。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.github.demo.AAAInitializer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.github.demo.BBBInitializer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.github.demo.CCCInitializer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App Startup能够通过读取AndroidManifest文件中<code>InitializationProvider</code>条目下的<code>&lt;meta-data&gt;</code>条目来自动检测组件，以在应用程序加载后进行初始化。</p><blockquote><p>在注册时只要声明最高级的<code>Initializer</code>就可以。</p></blockquote><p>应用程序运行后的输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;CCCInitializer: create: </span><br><span class="line">D&#x2F;BBBInitializer: create: </span><br><span class="line">D&#x2F;AAAInitializer: create: </span><br></pre></td></tr></table></figure><p><strong>延迟初始化</strong></p><p>当我们应用的组件不需要在启动时进行初始化，我们可以将<code>&lt;meta-data&gt;</code>指定的<code>Initializer</code>移除。还可以使用<code>tools:node=&quot;remove&quot;</code>来确保合并工具在合并Manifest文件时从其它Manifest文件中删除。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span><br><span class="line">    android:authorities=<span class="string">&quot;<span class="subst">$&#123;applicationId&#125;</span>.androidx-startup&quot;</span></span><br><span class="line">    android:exported=<span class="string">&quot;false&quot;</span></span><br><span class="line">    tools:node=<span class="string">&quot;merge&quot;</span>&gt;</span><br><span class="line">    &lt;meta-<span class="keyword">data</span></span><br><span class="line">        android:name=<span class="string">&quot;com.github.demo.DDDInitializer&quot;</span></span><br><span class="line">        tools:node=<span class="string">&quot;remove&quot;</span> /&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure><p>当我们需要手动初始化时可以这样调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppInitializer.getInstance(applicationContext).initializeComponent(DDDInitializer::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p><strong>InitializationProvider</strong></p><p>在查看<code>InitializationProvider</code>之前，我们先自定义一个ContentProvider，来看看它是怎么启动的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> :<span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachBaseContext</span><span class="params">(base: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base)</span><br><span class="line">        Log.d(<span class="string">&quot;AppStartup&quot;</span>, <span class="string">&quot;Application attachBaseContext: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Log.d(<span class="string">&quot;AppStartup&quot;</span>, <span class="string">&quot;Application onCreate:&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomProvider</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;AppStartup&quot;</span>, <span class="string">&quot;Provider onCreate: &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动应用之后日志输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;AppStartup: Application attachBaseContext: </span><br><span class="line">D&#x2F;AppStartup: Provider onCreate: </span><br><span class="line">D&#x2F;AppStartup: Application onCreate:</span><br></pre></td></tr></table></figure><p>可以发现<code>ContentProvider#onCreate()</code>在<code>Application#onCreate()</code>之前运行。这是因为这个样，很多的第三方库已经不需要我们去手动调用初始化了，比如<a href="http://blog.xusheng.online/2020/04/18/LeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#2-1-LeakCanary%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90">Leakcanary</a>等。</p><p><code>InitializationProvider</code>就是是App Startup的初始化的入口，我们看看它是如何调用<code>Initializer</code>来初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用AppInitializer来发现和初始化Initializer</span></span><br><span class="line">            AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(<span class="string">&quot;Context cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里只是调用了<code>AppInitializer</code>中<code>discoverAndInitialize</code>的方法，然后就直接返回了。</p><p>那我们跟着进入<code>discoverAndInitialize()</code>：</p><p><strong>AppInitializer</strong></p><p><strong><em>discoverAndInitialize()</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Set&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; mDiscovered; <span class="comment">// 用来保存已经发现的Initializer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discoverAndInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">           ComponentName provider = <span class="keyword">new</span> ComponentName(mContext.getPackageName(),</span><br><span class="line">                   InitializationProvider.class.getName());</span><br><span class="line">           <span class="comment">// 获取InitializationProvider的信息</span></span><br><span class="line">           ProviderInfo providerInfo = mContext.getPackageManager()</span><br><span class="line">                   .getProviderInfo(provider, GET_META_DATA);</span><br><span class="line">           <span class="comment">// 获取InitializationProvider的&lt;meta-data&gt;节点</span></span><br><span class="line">           <span class="comment">// 它将我们传入的android:name作为key，android:value作为value</span></span><br><span class="line">           Bundle metadata = providerInfo.metaData;</span><br><span class="line">           <span class="comment">// 这个字符串就是“androidx_startup”</span></span><br><span class="line">           String startup = mContext.getString(R.string.androidx_startup);</span><br><span class="line">           <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123; <span class="comment">// 如果Provider中有&lt;meta-data&gt;节点</span></span><br><span class="line">               Set&lt;Class&lt;?&gt;&gt; initializing = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">               Set&lt;String&gt; keys = metadata.keySet(); <span class="comment">// 遍历key</span></span><br><span class="line">               <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                   String value = metadata.getString(key, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">if</span> (startup.equals(value)) &#123; <span class="comment">// 判断value</span></span><br><span class="line">                       Class&lt;?&gt; clazz = Class.forName(key); <span class="comment">// 获取类对象</span></span><br><span class="line">                       <span class="keyword">if</span> (Initializer.class.isAssignableFrom(clazz)) &#123; </span><br><span class="line">                           <span class="comment">//判断Initializer是不是clazz的父类</span></span><br><span class="line">                           Class&lt;? extends Initializer&lt;?&gt;&gt; component =</span><br><span class="line">                                   (Class&lt;? extends Initializer&lt;?&gt;&gt;) clazz;</span><br><span class="line">                           mDiscovered.add(component); <span class="comment">// 添加到mDiscovered中</span></span><br><span class="line">                           <span class="keyword">if</span> (StartupLogger.DEBUG) &#123;</span><br><span class="line">                               StartupLogger.i(String.format(<span class="string">&quot;Discovered %s&quot;</span>, key));</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 去初始化</span></span><br><span class="line">                           doInitialize(component, initializing);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>discoverAndInitialize</code>被调用的时候，它先获取<code>InitializationProvider</code>的metaData，然后将中的<code>Initializer</code>存入到已经<code>mDiscovered</code>中，最有调用<code>doInitialize()</code>去执行<code>Initializer</code>的相关操作。</p><p><strong><em>doInitialize()</em></strong></p><p>这里我们就可以看到<code>Initializer</code>的相关方法被执行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; mInitialized; <span class="comment">// 用来保存已经初始化的组件</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">doInitialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="meta">@NonNull</span> Class&lt;? extends Initializer&lt;?&gt;&gt; component,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="meta">@NonNull</span> Set&lt;Class&lt;?&gt;&gt; initializing)</span> </span>&#123;</span><br><span class="line">              ...</span><br><span class="line">               Object result;</span><br><span class="line">               <span class="comment">// 如果该组件已经初始化，直接从mInitialized获取</span></span><br><span class="line">               <span class="keyword">if</span> (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">                   initializing.add(component);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// 通过反射创建Initializer对象</span></span><br><span class="line">                       Object instance = component.getDeclaredConstructor().newInstance();</span><br><span class="line">                       Initializer&lt;?&gt; initializer = (Initializer&lt;?&gt;) instance;</span><br><span class="line">                       List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies =</span><br><span class="line">                               initializer.dependencies(); <span class="comment">// 调用dependencies()获取依赖</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 如果当前Initializer依赖其它的Initializer</span></span><br><span class="line">                       <span class="comment">// 那么先去进行其它Initializer初始化</span></span><br><span class="line">                       <span class="comment">// 这就是为什么在manifest中只要注册优先级最高的Initializer的原因</span></span><br><span class="line">                       <span class="keyword">if</span> (!dependencies.isEmpty()) &#123;</span><br><span class="line">                           <span class="keyword">for</span> (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                                   <span class="comment">// 递归实现依赖的Initializer</span></span><br><span class="line">                                   doInitialize(clazz, initializing);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// 调用create()方法初始化我们的组件</span></span><br><span class="line">                       result = initializer.create(mContext);</span><br><span class="line">                       </span><br><span class="line">                       initializing.remove(component);</span><br><span class="line">                       mInitialized.put(component, result);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(throwable);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   result = mInitialized.get(component);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> (T) result;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以明显的看到<code>Initializer</code>对象是通过反射来创建的。当<code>Initializer</code>对象创建好之后就调用<code>dependencies()</code>来看看它依赖哪些组件，如果有依赖那就创建它依赖的<code>Initializer</code>，如果没有那就执行<code>initializer.create()</code>来初始化我们的组件。</p><p>这里是App Start的完整流程了。</p><p>如果当我们手动调用<code>Initializer</code>进行初始化的时候，它也会去执行<code>doInitialize</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">initializeComponent</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;? extends Initializer&lt;T&gt;&gt; component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doInitialize(component, <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;App Startup 是Jetpack套件新增的功能。它为应用程序提供类一种更加高效的方式来初始化组件的方式。&lt;/p&gt;
&lt;p&gt;下面我们就来了解一下App Startup的使用方法和原理。&lt;/p&gt;
&lt;h3 id=&quot;1-开始使用&quot;&gt;&lt;a href=&quot;#1-开始使用&quot; clas
      
    
    </summary>
    
    
    
      <category term="Startup" scheme="https://blog.xusheng.online/tags/Startup/"/>
    
  </entry>
  
  <entry>
    <title>kotlin-函数字面值</title>
    <link href="https://blog.xusheng.online/2020/07/07/kotlin-%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E5%80%BC/"/>
    <id>https://blog.xusheng.online/2020/07/07/kotlin-%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E5%80%BC/</id>
    <published>2020-07-06T16:58:28.000Z</published>
    <updated>2020-09-14T07:29:31.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p><code>androidx.core:core-ktx:1.1.0</code>这个包大大提高了我们开发的效率，比如之前使用<code>SharedPreferences</code>的时候需要这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> editor = sharedPreferences.edit()</span><br><span class="line">      editor.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">      editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">      editor.putString(<span class="string">&quot;avatar&quot;</span>, <span class="string">&quot;http://xxxx&quot;</span>)</span><br><span class="line">      editor.apply()</span><br></pre></td></tr></table></figure><p>而且一旦忘记使用<code>apply()</code>或者<code>commit()</code>，那就白提交了。ktx这个包出现后，我们的代码就变成这样了:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sharedPreferences.edit &#123;</span><br><span class="line">    putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    putInt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    putString(<span class="string">&quot;avatar&quot;</span>, <span class="string">&quot;http://xxxx&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比上面的是不是简单了很多？</p><p>虽然知道了用法，但是我们也要看看它是怎么实现的，打开它的源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">&quot;ApplySharedPref&quot;</span>)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">edit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    commit: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    action: <span class="type">SharedPreferences</span>.<span class="type">Editor</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> editor = edit()</span><br><span class="line">    action(editor)</span><br><span class="line">    <span class="keyword">if</span> (commit) &#123;</span><br><span class="line">        editor.commit()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editor.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也很简单，但是<code>action: SharedPreferences.Editor.() -&gt; Unit</code>是什么东西？我们之前传递函数时不都是这样写<code>func: () -&gt; Unit</code>这样的吗？</p><h3 id="2-函数字面值"><a href="#2-函数字面值" class="headerlink" title="2. 函数字面值"></a>2. 函数字面值</h3><p>参考: <a href="https://stackoverflow.com/questions/48244734/what-does-classname-mean-in-kotlin">What does .() mean in Kotlin?</a> 和 <a href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver">Function literals with receiver</a>。</p><p><strong>什么叫函数字面值</strong></p><blockquote><p>Function types with receiver, such as <code>A.(B) -&gt; C</code>, can be instantiated with a special form of function literals – function literals with receiver.</p><p>带有接收者的函数类型，例如 <code>A.(B) -&gt; C</code>，可以用特殊形式的函数字面值实例化—— 带有接收者的函数字面值。</p><p>As said above, Kotlin provides the ability to call an instance of a function type with receiver providing the <em>receiver object</em>.</p><p>如上所述，Kotlin 提供了调用带有接收者（提供<em>接收者对象</em>）的函数类型实例的能力。</p></blockquote><p><code>函数字面值</code>，有的也叫<code>函数字面量</code>(function literal，可以参考<a href="https://www.cnblogs.com/moonandstar08/p/5240296.html">Scala函数字面量</a>)。</p><p><code>函数字面值（量）</code>就是一段函数文本，可以当作参数传递。函数字面值在默认情况下没有名称，但是可以通过将它们绑定到一个变量来给它一个名字。</p><p>在 Kotlin 中，<code>let</code>、<code>run</code>，<code>apply</code>等都是一种 函数字面值。</p><p><strong><code>A.(B) -&gt; C</code>与<code>(A) -&gt; B</code>的区别</strong></p><blockquote><p>Inside the body of the function literal, the receiver object passed to a call becomes an <em>implicit</em> <em>this</em>, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a <code>this</code> expression.</p><p>在这样的函数字面值内部，传给调用的接收者对象成为<em>隐式</em>的<em>this</em>，以便访问接收者对象的成员而无需任何额外的限定符，亦可使用 <code>this</code> 表达式 访问接收者对象。</p></blockquote><p>对比ktx中的方法，如果我们没有使用函数字面值，而是使用<code>(A) -&gt; B</code>这中函数类型的话可以写成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">&quot;ApplySharedPref&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">edit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    commit: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    action: (<span class="type">SharedPreferences</span>.<span class="type">Editor</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> editor = edit()</span><br><span class="line">    action(editor)</span><br><span class="line">    <span class="keyword">if</span> (commit) &#123;</span><br><span class="line">        editor.commit()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editor.apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看怎么调用它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sharedPreferences.edit &#123;</span><br><span class="line">    it.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    it.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    it.putString(<span class="string">&quot;avatar&quot;</span>, <span class="string">&quot;http://xxxx&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的this调用的就不是<code>SharedPreferences.Editor</code>了，这时候就需要使用默认的<code>it</code>来访问<code>SharedPreferences.Editor</code>里面的方法了。这种场景下使用相比ktx里的实现显得有些丑陋了。</p><p>总结一下<code>A.(B) -&gt; C</code>与<code>(A) -&gt; B</code>的区别就是：**<code>A.(B) -&gt; C</code>里的this代表的是自身实例，<code>(A) -&gt; B</code>里的this代表的是外部类的实例**。</p><h3 id="3-函数字面值的使用"><a href="#3-函数字面值的使用" class="headerlink" title="3. 函数字面值的使用"></a>3. 函数字面值的使用</h3><p><strong>TextWatcher</strong></p><p>如果我们想要监听<code>TextView</code>内容的变化一般都会这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">textView.addTextChangedListener(<span class="keyword">object</span> : TextWatcher &#123;</span><br><span class="line">           <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>看看如何使用函数字面值改造它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> TextView.<span class="title">textWatcher</span><span class="params">(<span class="keyword">init</span>: <span class="type">TextWatcherAdapter</span>.() -&gt; <span class="type">Unit</span>)</span></span> =</span><br><span class="line">    addTextChangedListener(TextWatcherAdapter().apply(<span class="keyword">init</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextWatcherAdapter</span> : <span class="type">TextWatcher &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _beforeChanged: ((CharSequence?, <span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _onChanged: ((CharSequence?, <span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _afterChanged: ((Editable?) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        _beforeChanged?.invoke(s, start, count, after)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        _onChanged?.invoke(s, start, before, count)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(s: <span class="type">Editable</span>?)</span></span> &#123;</span><br><span class="line">        _afterChanged?.invoke(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">beforeChanged</span><span class="params">(listener: (<span class="type">CharSequence</span>?, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _beforeChanged = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(listener: (<span class="type">CharSequence</span>?, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _onChanged = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">afterChanged</span><span class="params">(listener: (<span class="type">Editable</span>?) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        _afterChanged = listener</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看怎么使用，然后在解释上面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">textView.textWatcher &#123;</span><br><span class="line">    afterChanged &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 假如我们只需要监视它修改后的改动，直接在方法体里调用<code>afterChanged</code>就行了。如果有需要，还可以继续在<code>textWatcher</code>方法体里使用<code>beforeChanged</code>和<code>onChanged</code>。</p><p>现在就来解释一下上面的那个方法：</p><ol><li><p><code>TextWatcherAdapter</code>是继承自<code>TextWatcher</code>，所以<code>addTextChangedListener(watcher)</code>并没有什么不同。</p></li><li><p><code>TextWatcherAdapter().apply(init)</code>方法返回的就是<code>TextWatcherAdapter</code>本身，因为我们要使用<code>TextWatcherAdapter</code>里面的方法所以使用了函数字面值。开始的时候说了<code>apply</code>是一种函数字面值，现在我们看一下<code>apply()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用管<code>contract</code>是什么，我们现在可以知道<code>apply</code>的作用是：<strong>以“ this”值作为接收者调用指定的函数<code>block</code>并返回“ this”值</strong>。而<code>TextWatcherAdapter().apply(init)</code>等价于:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextWatcherAdapter().apply&#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们熟悉的<code>apply</code>写法了。</p></li><li><p>为什么要定义<code>_onChanged</code>等变量然后添加<code>onChanged()</code>这些方法呢？</p><p>因为在<code>textView.textWatcher&#123;&#125;</code>方法体里面使用<code>afterTextChanged</code>的话，我们只是调用它的方法。而我们需要的是监听它的回调，所以当<code>onTextChanged()</code>被调用的时候我们需要回调到<code>textChanged</code>中才能去响应监听。</p></li></ol><p>接下来再来看看我是怎样改进其它的模块。</p><p><strong>RuntimePermission</strong></p><p>我们项目中用到的动态权限申请框架是<a href="https://github.com/florent37/RuntimePermission">florent37/RuntimePermission</a>。它原始的用法也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> permission = RuntimePermission(<span class="keyword">this</span>)</span><br><span class="line">permission.request(Manifest.permission.CAMERA).ask()</span><br><span class="line">permission.onAccepted &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">permission.onDenied &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实它也有kotlin版的，方法比这个更简单。</p></blockquote><p>我们先来改造它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> FragmentActivity.<span class="title">askPermissions</span><span class="params">(<span class="keyword">vararg</span> permission: <span class="type">String</span>, func: <span class="type">RuntimePermissionHelper</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimePermissionHelper(<span class="keyword">this</span>).apply(func).ask(permission.toList())</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuntimePermissionHelper</span></span>(activity: FragmentActivity) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runtimePermission = RuntimePermission(activity)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onAccepted</span><span class="params">(func: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">        runtimePermission.onAccepted &#123;</span><br><span class="line">            func?.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onDenied</span><span class="params">(func: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">        runtimePermission.onDenied &#123;</span><br><span class="line">            func?.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onForeverDenied</span><span class="params">(func: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">        runtimePermission.onForeverDenied &#123;</span><br><span class="line">            func?.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(func: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">        runtimePermission.onResponse &#123;</span><br><span class="line">            func?.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ask</span><span class="params">(permissions: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        runtimePermission.request(permissions).ask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在Activity中这样使用它:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">askPermissions(Manifest.permission.CAMERA) &#123;</span><br><span class="line">    onAccepted &#123; </span><br><span class="line">        <span class="comment">// do accepted</span></span><br><span class="line">    &#125;</span><br><span class="line">    onDenied &#123; </span><br><span class="line">        <span class="comment">// do denied</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，<code>函数字面值</code>基本已经被我们了解了。使用好<code>函数字面值</code>不仅能是代码函数减少，更能加强代码的可读性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h3&gt;&lt;p&gt;&lt;code&gt;androidx.core:core-ktx:1.1.0&lt;/code&gt;这个包大大提高了我们开发的效率，比如之
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://blog.xusheng.online/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://blog.xusheng.online/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin Coroutines</title>
    <link href="https://blog.xusheng.online/2020/06/26/kotlin%E5%8D%8F%E7%A8%8B/"/>
    <id>https://blog.xusheng.online/2020/06/26/kotlin%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-26T06:42:36.000Z</published>
    <updated>2020-09-13T15:45:03.024Z</updated>
    
    <content type="html"><![CDATA[<p>Coroutines一般我们都会成协程，单看这个翻译我们很难去理解它的意思。Coroutines其实是由两个单词组合而成的，分别是cooperation和routine。cooperation是指合作，routine指的是例行程序、常规作业，所以我们可以把它翻译为合作的例行程序。</p><p>routine在这里指的是程序中的方法，所以说这种将方法协同其它方法来共同作业的方式就叫做Coroutines。</p><p>Coroutines允许方法暂停执行(suspend)后再恢复执行(resume)，而被暂停的方法状态运行被保留，恢复后再以暂停前的状态继续执行。</p><h3 id="1-开始使用"><a href="#1-开始使用" class="headerlink" title="1. 开始使用"></a>1. 开始使用</h3><p>kotlin coroutines不包含在stdlib包中，需要我们单独引入：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7&#x27;</span></span><br></pre></td></tr></table></figure><p>我们先从一个简单的例子开始，使用界面来展示一个获取验证码倒计时。</p><p>先来看看没有使用Coroutines之前我们的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> countDown = <span class="keyword">object</span> :AsyncTask&lt;<span class="built_in">Void</span>, <span class="built_in">Int</span>, <span class="built_in">Void</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> params: <span class="type">Void</span>?)</span></span>: <span class="built_in">Void</span>? &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">60</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">            publishProgress(i)</span><br><span class="line">            Thread.sleep(<span class="number">1_000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressUpdate</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onProgressUpdate(*values)</span><br><span class="line">        textView.text = <span class="string">&quot;<span class="subst">$&#123;values.elementAtOrNull(<span class="number">0</span>)&#125;</span>秒&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">countDown.execute()</span><br></pre></td></tr></table></figure><p>再来对比一下使用Coroutines：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">60</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">        textView.text = <span class="string">&quot;<span class="subst">$&#123;i&#125;</span>秒&quot;</span></span><br><span class="line">        delay(<span class="number">1_000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是相比使用<code>AsyncTask</code>简单的多(另外，Android中有专门的<code>CountDownTimer</code>来实现计时器)，下面我们来看看它们的具体含义。</p><h3 id="2-Scope"><a href="#2-Scope" class="headerlink" title="2. Scope"></a>2. Scope</h3><p>Scope指的是Coroutines的作用范围。</p><p><code>GlobalScope</code>继承自<code>CoroutineScope</code>，它的作用范围伴随着整个应用程序的生命周期。：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们在实际开发的时候不会经常去使用GlobalScope，而是按照Activity或者Fragment的生命周期来使用自定义的CoroutineScope，当生命周期完成的时候取消GlobalScope里的运行方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> countDownJob: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        countDownJob = launch &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">60</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">                textView.text = <span class="string">&quot;<span class="subst">$&#123;i&#125;</span>秒&quot;</span></span><br><span class="line">                delay(<span class="number">1_000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        countDownJob?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来介绍一下<code>Job</code>和<code>CoroutineContext</code>。</p><h3 id="3-Job"><a href="#3-Job" class="headerlink" title="3. Job"></a>3. Job</h3><p>Job从字面意思来看，就是指工作。</p><p>从Scope的角度来说，Scope可以管理它作用域下面所有的方法，当Scope取消的时候就会取消掉Scope中所有在执行的方法。假如我们现在有一个上传和一个下载的方法同时在Scope中运行，当我们要取消下载的时候就不能使用<code>Scope.cancel()</code>，而是轮到Job出场了。</p><p>我们可以看到，Scope使用<code>launch</code>扩展方法的时候返回的就是一个Job。所以Job就是单个Coroutines的生命周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                                     wait children</span><br><span class="line">+-----+ start  +--------+ complete   +-------------+  finish  +-----------+</span><br><span class="line">| New | -----&gt; | Active | ---------&gt; | Completing  | -------&gt; | Completed |</span><br><span class="line">+-----+        +--------+            +-------------+          +-----------+</span><br><span class="line">                 |  cancel &#x2F; fail       |</span><br><span class="line">                 |     +----------------+</span><br><span class="line">                 |     |</span><br><span class="line">                 V     V</span><br><span class="line">             +------------+                           finish  +-----------+</span><br><span class="line">             | Cancelling | --------------------------------&gt; | Cancelled |</span><br><span class="line">             +------------+                                   +-----------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>来自<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Job.kt">Job类的注解</a></p></blockquote><h3 id="4-CoroutineContext"><a href="#4-CoroutineContext" class="headerlink" title="4. CoroutineContext"></a>4. CoroutineContext</h3><p><code>CoroutineContext</code>指的就是Coroutines的上下文。</p><p>协程中的代码是在CoroutineContext中执行的，CoroutineContext为我们提供了异步运行/执行代码所需的执行环境。</p><p><code>CoroutineContext</code>是各种不同元素的集合，其中主元素是协程中的 <em>Job</em>。对于Scope 、CoroutineContext 、Job 三者间的关系，简单的来说就是：<strong>Scope 包含了CoroutinContext，而CoroutineContext 里Element就是Job</strong>。</p><p>想要对CoroutineContext有更多了解，可以参考<a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055">Coroutine Context and Scope</a>。</p><h3 id="5-Dispatcher"><a href="#5-Dispatcher" class="headerlink" title="5. Dispatcher"></a>5. Dispatcher</h3><p>Dispatcher就是Coroutines中的调度器。它其实就是Kotlin为我们封装好的<code>CoroutineContext</code>。</p><p>在Kotlinx coroutine中有四种Dispatcher分别是：</p><ul><li><strong>Dispatchers.Main</strong>：就是主线程的包装，在Android 需要操作到UI 线程 通常会用它</li><li><strong>Dispatchers.Default</strong>：默认的Dispatcher，将协程执行限制在共享的后台线程池中</li><li><strong>Dispatchers.IO</strong>：基于Default 去加强的Dispatchers。它跟Default 最本质的区别在于，它开的线程数量会比较多，以Default 来说是N ( JVM 给的数量，个平台机子会不同)，而IO 则会给上64 个，如果JVM 给更多，那就更多那样。</li><li><strong>Dispatchers.Unconfined</strong>：不局限于任何特定线程的Dispatcher，通常他会跑在执行该Coroutines 的线程 上，但是在suspend后被回复可能会跑到另一个线程 上。</li></ul><p>像是MainScope 的CoroutineContext 是supervisorJob() + Dispatcher.Main，所以MainScop 实质上是提供一个主线程 为context 的Scope。</p><p>在Android 上Dispatcher.Main 会将launch 的程序跑在UI 线程上，那Dispatcher.IO 则会将launch 的程序跑在worker 线程上，通常会用来跑耗时作业，其实就是用比较简易的方式决定Coroutines 执行的CoroutineContext。</p><h3 id="6-Suspend"><a href="#6-Suspend" class="headerlink" title="6. Suspend"></a>6. Suspend</h3><p>这时候轮到Coroutines中最重要的suspend了，先来看一段代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span> = withContext (Dispatchers.IO) &#123; </span><br><span class="line">  <span class="comment">// fetch user from network</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>withContext(Dispathcers.IO) </code>的意思就是要让这东西跑在Worker 线程上。</p><p>另外可以看到，这个方法 前面加了一个<code>suspend</code> ，表示执行到这个function 时是可以被suspend (暂停)的。</p><p>在Coroutines的代码块中，线程的代码在到达 <code>suspend</code> 函数的时候被掐断，接下来协程会从这个 <code>suspend</code> 函数开始继续往下执行，不过是在<code>withContext</code>指定的线程。在 <code>suspend</code> 函数执行完成之后，会根据传入的Dispatcher将线程切回到原来的线程。</p><p> <code>suspend</code>关键字 起到的并不是切换线程的作用，而是用于IDE的提示。所以fun 前面注记的suspend 必须要在coroutineScope 的launch 、runBlocking 内或者是其他的suspend method 才能够被使用。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>这篇主要是记录Kotlin Coroutines的相关介绍。如需深入了解可以查看<a href="https://developer.android.com/kotlin/coroutines">Android 上的 Kotlin 协程</a>和<a href="https://kotlinlang.org/docs/reference/coroutines-overview.html#coroutines-for-asynchronous-programming-and-more">Coroutines for asynchronous programming and more</a>等官方文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Coroutines一般我们都会成协程，单看这个翻译我们很难去理解它的意思。Coroutines其实是由两个单词组合而成的，分别是cooperation和routine。cooperation是指合作，routine指的是例行程序、常规作业，所以我们可以把它翻译为合作的例行
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://blog.xusheng.online/categories/Kotlin/"/>
    
    
      <category term="Coroutines" scheme="https://blog.xusheng.online/tags/Coroutines/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin委托属性(Delegate)</title>
    <link href="https://blog.xusheng.online/2020/05/26/Kotlin%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7-Delegate/"/>
    <id>https://blog.xusheng.online/2020/05/26/Kotlin%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7-Delegate/</id>
    <published>2020-05-26T14:51:28.000Z</published>
    <updated>2020-09-13T12:40:43.727Z</updated>
    
    <content type="html"><![CDATA[<p>使用<strong>Kotlin</strong>某些功能我们很容易编写简洁易读的代码。由于有了数据类(<em>data class</em>)，扩展函数(<em>extensions</em>)和委托属性(<em>delegate</em>)等，与Java类相比，Kotlin类通常更小而且更易阅读。</p><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h3><p>委托只是一个提供属性值并处理其更改的类。这使我们可以将getter-setter逻辑从属性本身移动或委托到单独的类，从而使我们可以重用此逻辑。</p><p>假如我们想要一个始终为大写字符串的属性<code>param</code>，我们可以在它的属性设置器里进行下面的操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperCaseDemo</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> param:String = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">set</span>(value) &#123;</span><br><span class="line">      field = value.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对上面的语法感到困惑，请参考kotlin文档中的<a href="https://www.kotlincn.net/docs/reference/properties.html">属性与字段</a>。</p><p>假如我们要在其它的类中重用此功能该怎么办？这时候就轮到<strong>Delegate</strong>上场了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperCaseDelegate</span> : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any?, String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> upperCaseValue = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> upperCaseValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        upperCaseValue = value.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Delegate</strong>只是具有两个方法的类：用于获取和设置属性的值。为了提供更多信息，它通过<code>KProperty</code>类的实例提供了它正在使用的属性，并通过提供了具有该属性的对象<code>thisRef</code>。下面我们将使用修改<code>UpperCaseDemo</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperCaseDemo</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> param:String <span class="keyword">by</span> UpperCaseDelegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这等效于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperCaseDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> delegate = UpperCaseDelegate()</span><br><span class="line">    <span class="keyword">var</span> param: String</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::param)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            delegate.setValue(<span class="keyword">this</span>, <span class="keyword">this</span>::param, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>::param</code>是一个运算符，它返回该属性的KProperty类的实例。</p><p><strong>Delegate</strong>尽管非常的简单，但是它可能对我们开发人员有很大的帮助。因此，我们来编写一些帮助我们开发的一些Android实例。</p><h3 id="2-使用delegate简化操作"><a href="#2-使用delegate简化操作" class="headerlink" title="2. 使用delegate简化操作"></a>2. 使用delegate简化操作</h3><p>我们经常会将一些参数传递给Fragment，通常类似这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegateFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        arguments?.let &#123; args -&gt;</span><br><span class="line">            name = args.getString(ARGS_NAME)</span><br><span class="line">            age = args.getInt(ARGS_AGE)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARGS_NAME = <span class="string">&quot;name&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARGS_AGE = <span class="string">&quot;age&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>)</span></span>: DelegateFragment =</span><br><span class="line">            DelegateFragment().apply &#123;</span><br><span class="line">                arguments = Bundle().apply &#123;</span><br><span class="line">                    putString(ARGS_NAME, name)</span><br><span class="line">                    putInt(ARGS_AGE, age)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要为每个属性编写相同的代码，如果有很多的属性可能会显得非常的混乱。我们下一步将使用属性委托来美化代码。</p><p>Fragment的参数存储在一个<code>Bundle</code>对象中，该对象具有用于放置不同类型的值。我们做一个扩展函数，尝试将任意类型的值放入Bundle中，如果不支持该类型则抛出异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> Bundle.<span class="title">put</span><span class="params">(key: <span class="type">String</span>, value: <span class="type">T</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (value) &#123;</span><br><span class="line">        <span class="literal">null</span> -&gt; putString(key, <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Boolean</span> -&gt; putBoolean(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Byte</span> -&gt; putByte(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Char</span> -&gt; putChar(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; putDouble(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Float</span> -&gt; putFloat(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; putInt(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; putLong(key, value)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Short</span> -&gt; putShort(key, value)</span><br><span class="line">        <span class="keyword">is</span> Bundle -&gt; putBundle(key, value)</span><br><span class="line">        <span class="keyword">is</span> CharSequence -&gt; putCharSequence(key, value)</span><br><span class="line">        <span class="keyword">is</span> Parcelable -&gt; putParcelable(key, value)</span><br><span class="line">        <span class="keyword">is</span> BooleanArray -&gt; putBooleanArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> ByteArray -&gt; putByteArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> CharArray -&gt; putCharArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> DoubleArray -&gt; putDoubleArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> FloatArray -&gt; putFloatArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> IntArray -&gt; putIntArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> LongArray -&gt; putLongArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> ShortArray -&gt; putShortArray(key, value)</span><br><span class="line">        <span class="keyword">is</span> Array&lt;*&gt; -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> componentType = value::<span class="keyword">class</span>.java.componentType!!</span><br><span class="line">            <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span> <span class="comment">// Checked by reflection.</span></span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                Parcelable::<span class="keyword">class</span>.java.isAssignableFrom(componentType) -&gt; &#123;</span><br><span class="line">                    putParcelableArray(key, value <span class="keyword">as</span> Array&lt;Parcelable&gt;)</span><br><span class="line">                &#125;</span><br><span class="line">                String::<span class="keyword">class</span>.java.isAssignableFrom(componentType) -&gt; &#123;</span><br><span class="line">                    putStringArray(key, value <span class="keyword">as</span> Array&lt;String&gt;)</span><br><span class="line">                &#125;</span><br><span class="line">                CharSequence::<span class="keyword">class</span>.java.isAssignableFrom(componentType) -&gt; &#123;</span><br><span class="line">                    putCharSequenceArray(key, value <span class="keyword">as</span> Array&lt;CharSequence&gt;)</span><br><span class="line">                &#125;</span><br><span class="line">                Serializable::<span class="keyword">class</span>.java.isAssignableFrom(componentType) -&gt; &#123;</span><br><span class="line">                    putSerializable(key, value)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> valueType = componentType.canonicalName</span><br><span class="line">                    <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;Illegal value array type <span class="variable">$valueType</span> for key \&quot;<span class="variable">$key</span>\&quot;&quot;</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> Serializable -&gt; putSerializable(key, value)</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">18</span> &amp;&amp; value <span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">                putBinder(key, value)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span> &amp;&amp; value <span class="keyword">is</span> Size) &#123;</span><br><span class="line">                putSize(key, value)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span> &amp;&amp; value <span class="keyword">is</span> SizeF) &#123;</span><br><span class="line">                putSizeF(key, value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> valueType = value.javaClass.canonicalName</span><br><span class="line">                <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Illegal value type <span class="variable">$valueType</span> for key \&quot;<span class="variable">$key</span>\&quot;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建Delegate：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentArgumentDelegate</span>&lt;<span class="type">T : Any</span>&gt; :<span class="type"></span></span></span><br><span class="line">    ReadWriteProperty&lt;Fragment, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        thisRef: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        property: <span class="type">KProperty</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">val</span> key = property.name</span><br><span class="line">        <span class="keyword">return</span> thisRef.arguments</span><br><span class="line">            ?.<span class="keyword">get</span>(key) <span class="keyword">as</span>? T</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Property <span class="subst">$&#123;property.name&#125;</span> could not be read&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        thisRef: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> args = thisRef.arguments</span><br><span class="line">            ?: Bundle().also(thisRef::setArguments)</span><br><span class="line">        <span class="keyword">val</span> key = property.name</span><br><span class="line">        args.put(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当属性允许为空时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentArgumentNullableDelegate</span>&lt;<span class="type">T : Any</span>&gt; :<span class="type"></span></span></span><br><span class="line">    ReadWriteProperty&lt;Fragment, T?&gt; &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        thisRef: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        property: <span class="type">KProperty</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">val</span> key = property.name</span><br><span class="line">        <span class="keyword">return</span> thisRef.arguments?.<span class="keyword">get</span>(key) <span class="keyword">as</span>? T</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        thisRef: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> args = thisRef.arguments</span><br><span class="line">            ?: Bundle().also(thisRef::setArguments)</span><br><span class="line">        <span class="keyword">val</span> key = property.name</span><br><span class="line">        value?.let &#123; args.put(key, it) &#125; ?: args.remove(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delegate从Fragment的Arguments中读取属性，当属性的值发生改变时，Delegate将检索Fragment Argument，然后使用<code>Bundle.put</code>扩展函数将新值写入Arguments。</p><p><code>ReadWriteProperty</code>是一个接受两个类型参数的接口。我们将第一个设置为<code>Fragment</code>，使该Delegate仅可用于Fragment内的属性。这使我们可以使用Fragment实例<code>thisRef</code>并管理其参数。<code>ReadWriteProperty</code>的第二个类型参数确定属性可以具有哪种类型的值。</p><p>接下来，我们创建一些扩展函数方便使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">argument</span><span class="params">()</span></span>: ReadWriteProperty&lt;Fragment, T&gt; =</span><br><span class="line">    FragmentArgumentDelegate()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">argumentNullable</span><span class="params">()</span></span>: ReadWriteProperty&lt;Fragment, T?&gt; =</span><br><span class="line">    FragmentArgumentNullableDelegate()</span><br></pre></td></tr></table></figure><p>最终我们就可以这样使用Delegate来传递args：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegateFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: String <span class="keyword">by</span> argument()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>? <span class="keyword">by</span> argumentNullable()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>)</span></span>: DelegateFragment =</span><br><span class="line">            DelegateFragment().apply &#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name</span><br><span class="line">                <span class="keyword">this</span>.age = age</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>this.name = name</code>并不是直接对对象赋值。可以查看编译后的字节码发现是通过<code>delegate.setvalue()</code>来管理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> DelegateFragment <span class="title">newInstance</span><span class="params">(<span class="meta">@NotNull</span> String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">      DelegateFragment var3 = <span class="keyword">new</span> DelegateFragment();</span><br><span class="line">      <span class="keyword">boolean</span> var4 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> var5 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> var7 = <span class="keyword">false</span>;</span><br><span class="line">      var3.setName(name);</span><br><span class="line">      var3.setAge(age);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (String)<span class="keyword">this</span>.name$delegate.getValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name$delegate.setValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">0</span>], var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.age$delegate.getValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.age$delegate.setValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">1</span>], var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h3><p><strong>Delegate</strong>的功能完全不止上面的实例，有到许多其他方法在应用程序中使用它们。例如自定义View、<code>SharedPreferences</code>等等。这里的目的是为了演示什么是强大的属性委托，以及可以实现什么。如果想要更进一步的了解，可以查阅文档<a href="https://kotlinlang.org/docs/reference/delegated-properties.html">Delegated Properties</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;strong&gt;Kotlin&lt;/strong&gt;某些功能我们很容易编写简洁易读的代码。由于有了数据类(&lt;em&gt;data class&lt;/em&gt;)，扩展函数(&lt;em&gt;extensions&lt;/em&gt;)和委托属性(&lt;em&gt;delegate&lt;/em&gt;)等，与Java类相比，Kotl
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://blog.xusheng.online/categories/Kotlin/"/>
    
    
      <category term="Delegate" scheme="https://blog.xusheng.online/tags/Delegate/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary源码解析</title>
    <link href="https://blog.xusheng.online/2020/04/18/LeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.xusheng.online/2020/04/18/LeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-04-18T10:06:33.000Z</published>
    <updated>2020-09-13T12:40:43.728Z</updated>
    
    <content type="html"><![CDATA[<p>LeakCanary是适用于Android的内存泄漏检测库。</p><p>本文基于<a href="https://github.com/square/leakcanary/tree/v2.2">LeakCanary</a>最新2.2版本进行分析。</p><h3 id="1-开始使用"><a href="#1-开始使用" class="headerlink" title="1. 开始使用"></a>1. 开始使用</h3><p>要使用LeakCanary，只需要将<code>leakcanary-android</code>添加到项目的build.gradle中，无需在项目中修改代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  &#x2F;&#x2F; debugImplementation because LeakCanary should only run in debug builds.</span><br><span class="line">  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><h4 id="2-1-LeakCanary初始化分析"><a href="#2-1-LeakCanary初始化分析" class="headerlink" title="2.1 LeakCanary初始化分析"></a>2.1 LeakCanary初始化分析</h4><blockquote><p>LeakCanary为什么不需要修改项目中的代码就可以使用呢，它在何时进行初始化操作？</p></blockquote><p><strong>LeakCanary</strong>巧妙的利用了ContentProvider来进行初始化操作，ContentProvider的<code>onCreate()</code>方法会在Application的<code>onCreate()</code>方法之前被系统回调。所以只需要在AndroidManifest.xml中配置一下这个ContentProvider，然后在<code>onCreate()</code>方法中进行初始化即可。</p><p><strong>AndroidManifest.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;leakcanary.internal.AppWatcherInstaller$MainProcess&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>AppWatcherInstaller.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWatcherInstaller</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    InternalAppWatcher.install(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该ContentProvider除了在onCreate方法中进行了初始化处理，其他方法都是空实现。在onCreate方法中调用了<code>InternalAppWatcher.install(Application)</code>方法完成了LeakCanary的初始化操作。</p><p><strong>InternalAppWatcher.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalAppWatcher &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟5秒抛出任务</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor = Executor &#123;</span><br><span class="line">    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">      clock = clock,</span><br><span class="line">      checkRetainedExecutor = checkRetainedExecutor,</span><br><span class="line">      isEnabled = &#123; AppWatcher.config.enabled &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    checkMainThread()</span><br><span class="line">    <span class="comment">// 如果已经初始化了，则不需要再次install</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>::application.isInitialized) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    InternalAppWatcher.application = application</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class="line">    <span class="comment">// 安装ActivityDestroyWatcher、FragmentDestroyWatcher</span></span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    <span class="comment">// 回调InternalLeakCanary</span></span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这个install方法中，干了两件事:</p><ol><li>Activity、Fragment销毁的观察者的安装。</li><li>回调<code>InternalLeakCanary.invoke()</code>。</li></ol><p>下面我们逐步分析这两件事情的具体内容。</p><h4 id="2-2-Activity、Fragment观察"><a href="#2-2-Activity、Fragment观察" class="headerlink" title="2.2 Activity、Fragment观察"></a>2.2 Activity、Fragment观察</h4><p><strong>ActivityDestroyWatcher.kt</strong></p><p>进入到<code>ActivityDestroyWatcher#install</code>方法中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">  <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (configProvider().watchActivities) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    objectWatcher: <span class="type">ObjectWatcher</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    configProvider: () -&gt; <span class="type">Config</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> activityDestroyWatcher =</span><br><span class="line">      ActivityDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">    application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑很简单，就是对于每个Activity，在其<code>onDestroy</code>方法调用之后，调用<code>objectWatcher.watch</code>观察这个Activity。</p><p>然后我们看看Fragment的观察逻辑。</p><p><strong>FragmentDestroyWatcher.kt</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  objectWatcher: <span class="type">ObjectWatcher</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  configProvider: () -&gt; <span class="type">AppWatcher</span>.<span class="type">Config</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里等同于val fragmentDestroyWatchers = mutableListOf&lt;Function1&lt;Activity, Unit&gt;&gt;()</span></span><br><span class="line">  <span class="keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">    <span class="comment">// 添加android.app.Fragment的观察者</span></span><br><span class="line">    fragmentDestroyWatchers.add(</span><br><span class="line">        AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取androidx.fragment.app.Fragment的观察者AndroidXFragmentDestroyWatcher</span></span><br><span class="line">  <span class="comment">// 如果存在则添加</span></span><br><span class="line">  getWatcherIfAvailable(</span><br><span class="line">      ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">      objectWatcher,</span><br><span class="line">      configProvider</span><br><span class="line">  )?.let &#123;</span><br><span class="line">    fragmentDestroyWatchers.add(it)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取android.support.v4.app.Fragment的观察者AndroidSupportFragmentDestroyWatcher</span></span><br><span class="line">  <span class="comment">// 如果存在则添加</span></span><br><span class="line">  getWatcherIfAvailable(</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">      objectWatcher,</span><br><span class="line">      configProvider</span><br><span class="line">  )?.let &#123;</span><br><span class="line">    fragmentDestroyWatchers.add(it)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fragmentDestroyWatchers.size == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册生命周期监听</span></span><br><span class="line">  application.registerActivityLifecycleCallbacks(<span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      activity: <span class="type">Activity</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      <span class="comment">// 在Activity创建时对所有Fragment进行观察</span></span><br><span class="line">      <span class="keyword">for</span> (watcher <span class="keyword">in</span> fragmentDestroyWatchers) &#123;</span><br><span class="line">        watcher(activity)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FragmentDestroyWatcher</code>会根据不同的Fragment来创建<code>*FragmentDestroyWatcher</code>。这里的<code>*FragmentDestroyWatcher</code>是实现<code>Function&lt;Activity,Unit&gt;</code>接口。在Activity调用<code>onCreate</code>之后，使用<code>*FragmentDestroyWatcher.invoke()</code>来处理对Fragment的监听。</p><p><code>AndroidOFragmentDestroyWatcher</code>、<code>AndroidXFragmentDestroyWatcher</code>和<code>AndroidSupportFragmentDestroyWatcher</code>的源码都非常类似，只是针对的Fragment不同而调用的API不同而已。但是<code>AndroidXFragmentDestroyWatcher</code>多了对ViewModel的监听，下面就以它为例看看具体是如何实现的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidXFragmentDestroyWatcher</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config</span><br><span class="line">) : (Activity) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentLifecycleCallbacks = <span class="keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      fragment: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      <span class="comment">// 在fragment创建的时候安装ViewModelClearedWatcher</span></span><br><span class="line">      ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> view = fragment.view</span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span> &amp;&amp; configProvider().watchFragmentViews) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            view, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">            <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">      <span class="comment">// 在销毁后观察fragment</span></span><br><span class="line">      <span class="keyword">if</span> (configProvider().watchFragments) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            fragment, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">val</span> supportFragmentManager = activity.supportFragmentManager</span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">      <span class="comment">// 安装ViewModelClearedWatcher</span></span><br><span class="line">      ViewModelClearedWatcher.install(activity, objectWatcher, configProvider)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是向Activity的FragmentManager注册<code>FragmentLifecycleCallbacks</code>，这样在Fragment调用<code>onDestroyView</code>和<code>onDestory</code>之后就能观察Fragment的View或者Fragment本身了。</p><p><code>ViewModelClearedWatcher</code>则是通过获取<code>ViewModelStore.mMap</code>，然后在执行生命周期<code>onCleared</code>遍历mMap的value进行观察。ViewModel的分析使用可以查看<a href="http://blog.xusheng.online/2020/08/09/Jetpack%E4%B9%8BViewModel/">Jetpack之ViewModel</a>，这里就不继续贴里面的代码了。</p><h4 id="2-3-InternalLeakCanary"><a href="#2-3-InternalLeakCanary" class="headerlink" title="2.3 InternalLeakCanary"></a>2.3 InternalLeakCanary</h4><p>在Activity和Fragment的观察者之后，还调用了<code>onAppWatcherInstalled(application)</code>，这个方法做了什么工作呢？</p><p><code>onAppWatcherInstalled</code>的定义为<code>private val onAppWatcherInstalled: (Application) -&gt; Unit</code>, 然后在<code>init</code>中通过反射将<code>InternalLeakCanary</code>复制给<code>onAppWatcherInstalled</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> onAppWatcherInstalled: (Application) -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> internalLeakCanary = <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> leakCanaryListener = Class.forName(<span class="string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)</span><br><span class="line">    leakCanaryListener.getDeclaredField(<span class="string">&quot;INSTANCE&quot;</span>)</span><br><span class="line">        .<span class="keyword">get</span>(<span class="literal">null</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">    NoLeakCanary</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@kotlin</span>.Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span><br><span class="line">  onAppWatcherInstalled = internalLeakCanary <span class="keyword">as</span> (Application) -&gt; <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onAppWatcherInstalled(application)</code>相当于调用了<code>InternalLeakCanary#invoke()</code>。所以接着查看<code>InternalLeakCanary#invoke()</code>即可，该方法也是完成了一些初始化操作，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.application = application</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内存泄漏时回调该类的方法</span></span><br><span class="line">  AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用默认的GcTrigger</span></span><br><span class="line">  <span class="keyword">val</span> gcTrigger = GcTrigger.Default</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> configProvider = &#123; LeakCanary.config &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用HandlerThread + Handler 来处理后台任务</span></span><br><span class="line">  <span class="keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)</span><br><span class="line">  handlerThread.start()</span><br><span class="line">  <span class="keyword">val</span> backgroundHandler = Handler(handlerThread.looper)</span><br><span class="line"></span><br><span class="line">  heapDumpTrigger = HeapDumpTrigger(</span><br><span class="line">      application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,</span><br><span class="line">      configProvider</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 检测App是否可见</span></span><br><span class="line">  application.registerVisibilityListener &#123; applicationVisible -&gt;</span><br><span class="line">    <span class="keyword">this</span>.applicationVisible = applicationVisible</span><br><span class="line">    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为resumedActivity赋值</span></span><br><span class="line">  registerResumedActivityListener(application)</span><br><span class="line">  <span class="comment">// 动态添加Shortcut</span></span><br><span class="line">  addDynamicShortcut(application)</span><br><span class="line"></span><br><span class="line">  disableDumpHeapInTests()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>AppWatcher.objectWatcher</code>其实就是<code>InternalAppWatcher.objectWatcher</code>, 这里添加了一个<code>OnObjectRetainedListener</code>监听器。</p><p><code>heapDumper</code>的作用是通过<code>Debug.dumpHprofData(heapDumpFile.absolutePath)</code>将堆转储到文件中。</p><p><code>gcTrigger</code>是通过调用<code>Runtime.getRuntime().gc()</code>来出发gc操作。</p><p><code>HeapDumpTrigger</code> 是用来管理<code>Heap Dump</code>的。当<code>objectWatcher</code>的监听器触发之后，就会调用<code>heapDumpTrigger.onObjectRetained()</code>。</p><h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>先不去管<code>ObjectWatcher.OnObjectRetainedListener</code>是怎么触发的，也不去关心<code>HeapDumpTrigger.onObjectRetained</code>进行了何种操作，我们先把初始化相关的流程捋清楚在去查看它们的以下原理。</p><p>LeakCanary通过ContentProvider<code>AppWatcherInstaller</code>在创建的时候执行<code>InternalAppWatcher.install()</code>操作。<code>InternalAppWatcher</code>定义了<code>ObjectWatcher</code>对象，在<code>InternalAppWatcher.install()</code>中分别将<code>objectWatcher</code>传递给Activity<code>ActivityDestroyWatcher</code>和<code>FragmentDestroyWatcher</code>用来观察Activity和Fragment的销毁，然后回调用<code>InternalLeakCanary.invoke</code>完成操作。<code>InternalLeakCanary.invoke</code>则是为objectWatcher添加对象保留监听器，并在监听器触发的时候调用<code>HeapDumpTrigger.onObjectRetained</code>。</p><p>这样LeakCanary就初始化安装完毕了，下面我们看看<code>ObjectWatcher</code>是如何观察Activity和Fragment，并触发<code>HeapDumpTrigger</code>方法的，以及<code>HeapDumpTrigger</code>被触发后进行哪些操作。</p><h3 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h3><h4 id="3-1-ObjectWatcher"><a href="#3-1-ObjectWatcher" class="headerlink" title="3.1 ObjectWatcher"></a>3.1 ObjectWatcher</h4><p>现在我们来看看<code>ObjectWatcher.watch(Any)</code>方法，Activity、Fragment都是由该方法进行观察的，所以最后还是统一回到了这里。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(watchedObject: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">  watch(watchedObject, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将ReferenceQueue中出现的弱引用移除</span></span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">      .toString()</span><br><span class="line">  <span class="comment">// 观测时间</span></span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="comment">// 创建一个自定义弱引用KeyedWeakReference</span></span><br><span class="line">  <span class="comment">// 调用了基类的WeakReference&lt;Any&gt;(referent, referenceQueue)构造器</span></span><br><span class="line">  <span class="comment">// KeyedWeakReference在被回收前后出现在ReferenceQueue中</span></span><br><span class="line">  <span class="keyword">val</span> reference =</span><br><span class="line">    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">        (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">        (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">        <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将KeyedWeakReference保存到map中</span></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主线程5秒后会执行</span></span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑是：</p><ol><li><p>将要观测的对象使用WeakReference保存起来，并在构造时传入一个ReferenceQueue。在垃圾回收器扫描它所管辖的内存区域过程中，一旦gc发现对象是可被被回收(弱可达)，就会把它放到ReferenceQueue中。</p></li><li><p>5秒钟之后再检查一下是否出现在了引用队列中，若出现了，则没有泄露。（为什么默认的是5秒呢？）</p></li></ol><p>下面我们进一步查看<code>removeWeaklyReachableObjects()</code>与<code>moveToRetained(key)</code>：</p><p><strong>removeWeaklyReachableObjects()</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>removeWeaklyReachableObjects()</code> 方法的作用就是将可被回收(弱可达)的对象从<code>watchedObjects</code>中移除。</p><p><strong>moveToRetained(key)</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>同样的，先执行一次<code>removeWeaklyReachableObjects()</code>， 那么剩下的对象就可以被认为有可能产生内存泄漏。这时候记录下内存泄漏的时间，然后回调所有监听器执行<code>onObjectRetained()</code>。</p><h4 id="3-2-HeapDumpTrigger"><a href="#3-2-HeapDumpTrigger" class="headerlink" title="3.2 HeapDumpTrigger"></a>3.2 HeapDumpTrigger</h4><p>上面我们看到ObjectWatcher中的<code>onObjectRetained</code>会执行<code>HeapDumpTrigger.onObjectRetained()</code>，那么我们就进入到这个方法中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scheduleRetainedObjectCheck(</span><br><span class="line">      reason = <span class="string">&quot;found new object retained&quot;</span>,</span><br><span class="line">      rescheduling = <span class="literal">false</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  reason: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  rescheduling: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">  <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 同一时间只能出现一次任务</span></span><br><span class="line">    <span class="keyword">val</span> scheduledIn = checkCurrentlyScheduledAt - SystemClock.uptimeMillis()</span><br><span class="line">    SharkLog.d &#123; <span class="string">&quot;Ignoring request to check for retained objects (<span class="variable">$reason</span>), already scheduled in <span class="subst">$&#123;scheduledIn&#125;</span>ms&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> verb = <span class="keyword">if</span> (rescheduling) <span class="string">&quot;Rescheduling&quot;</span> <span class="keyword">else</span> <span class="string">&quot;Scheduling&quot;</span></span><br><span class="line">    <span class="keyword">val</span> delay = <span class="keyword">if</span> (delayMillis &gt; <span class="number">0</span>) <span class="string">&quot; in <span class="subst">$&#123;delayMillis&#125;</span>ms&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    SharkLog.d &#123; <span class="string">&quot;<span class="variable">$verb</span> check for retained objects<span class="subst">$&#123;delay&#125;</span> because <span class="variable">$reason</span>&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis</span><br><span class="line">  <span class="comment">// 使用backgroundHandler去检查被保留的对象(objectWatcher.watchedObjects)</span></span><br><span class="line">  backgroundHandler.postDelayed(&#123;</span><br><span class="line">    checkScheduledAt = <span class="number">0</span></span><br><span class="line">    checkRetainedObjects(reason)</span><br><span class="line">  &#125;, delayMillis)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">(reason: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> config = configProvider()</span><br><span class="line">  <span class="comment">// A tick will be rescheduled when this is turned back on.</span></span><br><span class="line">  <span class="keyword">if</span> (!config.dumpHeap) &#123;</span><br><span class="line">    SharkLog.d &#123; <span class="string">&quot;Ignoring check for retained objects scheduled because <span class="variable">$reason</span>: LeakCanary.Config.dumpHeap is false&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// objectWatcher.watchedObjects中剩余的引用个数，</span></span><br><span class="line">  <span class="comment">// 得到个数之前仍然会执行removeWeaklyReachableObjects()</span></span><br><span class="line">  <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 手动调用System.gc()</span></span><br><span class="line">    gcTrigger.runGc()</span><br><span class="line">    <span class="comment">// 重新获取个数</span></span><br><span class="line">    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测当前保留对象数量</span></span><br><span class="line">  <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!config.dumpHeapWhenDebugging &amp;&amp; DebuggerControl.isDebuggerAttached) &#123;</span><br><span class="line">    <span class="comment">// 默认Debug的时候不执行，并安排在20秒后</span></span><br><span class="line">    onRetainInstanceListener.onEvent(DebuggerIsAttached)</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">        objectCount = retainedReferenceCount,</span><br><span class="line">        contentText = application.getString(</span><br><span class="line">            R.string.leak_canary_notification_retained_debugger_attached</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    scheduleRetainedObjectCheck(</span><br><span class="line">        reason = <span class="string">&quot;debugger is attached&quot;</span>,</span><br><span class="line">        rescheduling = <span class="literal">true</span>,</span><br><span class="line">        delayMillis = WAIT_FOR_DEBUG_MILLIS</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">  <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">    <span class="comment">// 60秒只会执行一次，并重新安排时间</span></span><br><span class="line">    onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">        objectCount = retainedReferenceCount,</span><br><span class="line">        contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">    )</span><br><span class="line">    scheduleRetainedObjectCheck(</span><br><span class="line">        reason = <span class="string">&quot;previous heap dump was <span class="subst">$&#123;elapsedSinceLastDumpMillis&#125;</span>ms ago (&lt; <span class="subst">$&#123;WAIT_BETWEEN_HEAP_DUMPS_MILLIS&#125;</span>ms)&quot;</span>,</span><br><span class="line">        rescheduling = <span class="literal">true</span>,</span><br><span class="line">        delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SharkLog.d &#123; <span class="string">&quot;Check for retained objects found <span class="variable">$retainedReferenceCount</span> objects, dumping the heap&quot;</span> &#125;</span><br><span class="line">  dismissRetainedCountNotification()</span><br><span class="line">  dumpHeap(retainedReferenceCount, retry = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedCount</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  retainedKeysCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  retainedVisibleThreshold: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount</span><br><span class="line">  lastDisplayedRetainedObjectCount = retainedKeysCount</span><br><span class="line">  <span class="keyword">if</span> (retainedKeysCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有被保留的对象，说明没有泄漏</span></span><br><span class="line">    SharkLog.d &#123; <span class="string">&quot;Check for retained object found no objects remaining&quot;</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> (countChanged) &#123;</span><br><span class="line">      onRetainInstanceListener.onEvent(NoMoreObjects)</span><br><span class="line">      showNoMoreRetainedObjectNotification()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (retainedKeysCount &lt; retainedVisibleThreshold) &#123;</span><br><span class="line">    <span class="comment">// 被保留的对象小于5个</span></span><br><span class="line">    <span class="keyword">if</span> (applicationVisible || applicationInvisibleLessThanWatchPeriod) &#123;</span><br><span class="line">      <span class="comment">// 当前应用可见，或者不可见时间间隔少于 5s，重新安排到 2s 后</span></span><br><span class="line">      <span class="keyword">if</span> (countChanged) &#123;</span><br><span class="line">        onRetainInstanceListener.onEvent(BelowThreshold(retainedKeysCount))</span><br><span class="line">      &#125;</span><br><span class="line">      showRetainedCountNotification(</span><br><span class="line">          objectCount = retainedKeysCount,</span><br><span class="line">          contentText = application.getString(</span><br><span class="line">              R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">      scheduleRetainedObjectCheck(</span><br><span class="line">          reason = <span class="string">&quot;found only <span class="variable">$retainedKeysCount</span> retained objects (&lt; <span class="variable">$retainedVisibleThreshold</span> while app visible)&quot;</span>,</span><br><span class="line">          rescheduling = <span class="literal">true</span>,</span><br><span class="line">          delayMillis = WAIT_FOR_OBJECT_THRESHOLD_MILLIS</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进入<code>onObjectRetained()</code>，该方法会调用<code>scheduleRetainedObjectCheck()</code>。此方法也就是在后台线程中执行<code>checkRetainedObjects()</code>来检查泄漏的对象： </p><ol><li><p>首先获取保留对象的个数，如果大于0，则GC一次之后再次获取 。</p></li><li><p>如果gc后的保留数为0直接返回。如果保留对象小于5个并且应用可见，或者不可见时间间隔少于 5s，重新安排<code>scheduleRetainedObjectCheck()</code>到 2s 后。否则进行下一步操作。</p></li><li><p>如果config里面配置的“调试时不允许dump heap”为false（默认值）且正在调试，则20s之后再试 </p></li><li><p>判断<code>lastHeapDumpUptimeMillis</code>和当前时间间隔，如果小于60秒则重新安排<code>scheduleRetainedObjectCheck()</code>。</p></li><li><p>执行<code>dumpHeap()</code>。</p></li></ol><p><strong>dumpHeap</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  retainedReferenceCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  retry: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  saveResourceIdNamesToMemory()</span><br><span class="line">  <span class="keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">  KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis</span><br><span class="line">  <span class="comment">// 获取hprof文件</span></span><br><span class="line">  <span class="keyword">val</span> heapDumpFile = heapDumper.dumpHeap()</span><br><span class="line">  <span class="keyword">if</span> (heapDumpFile == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (retry) &#123;</span><br><span class="line">      SharkLog.d &#123; <span class="string">&quot;Failed to dump heap, will retry in <span class="variable">$WAIT_AFTER_DUMP_FAILED_MILLIS</span> ms&quot;</span> &#125;</span><br><span class="line">      <span class="comment">// 如果文件为空并且重试时重新安排任务</span></span><br><span class="line">      scheduleRetainedObjectCheck(</span><br><span class="line">          reason = <span class="string">&quot;failed to dump heap&quot;</span>,</span><br><span class="line">          rescheduling = <span class="literal">true</span>,</span><br><span class="line">          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SharkLog.d &#123; <span class="string">&quot;Failed to dump heap, will not automatically retry&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">        objectCount = retainedReferenceCount,</span><br><span class="line">        contentText = application.getString(</span><br><span class="line">            R.string.leak_canary_notification_retained_dump_failed</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  lastDisplayedRetainedObjectCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 设置HeapDump时间</span></span><br><span class="line">  lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">  <span class="comment">//这些对象我们已经 dump 出来分析了，所以没必要保留它们了</span></span><br><span class="line">  objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">  <span class="comment">// 使用HeapAnalyzerService分析hprof文件</span></span><br><span class="line">  HeapAnalyzerService.runAnalysis(application, heapDumpFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 HeapDumper.dumpHeap() 获取 hprof 文件，接着调用<code>ObjectWatcher.clearObjectsWatchedBefore() </code> 清理被观察的<code>watchedObjects</code>，最后调用 <code>HeapAnalyzerService.runAnalysis()</code> 进行分析。HeapAnalyzerService启动了一个前台进程然后使用<code>HeapAnalyzer</code>对文件进行分析，这里就不继续跟进了。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li>LeakCanary通过注册ContentProvider来实现初始化。</li><li>注册Activity、Fragment的生命周期监听，当对象销毁时触发<code>ObjectWatcher.watch()</code>。</li><li><code>ObjectWatcher.watch()</code>将对象包装成KeyedReference，并关联到ReferenceQueue。</li><li>延迟5秒根据ReferenceQueue来清除<code>watchedObjects</code>中弱可达的值。</li><li>如果<code>watchedObjects</code>中包含对象的引用，那么通知监听器。</li><li>监听器触发<code>HeapDumpTrigger.onObjectRetained()</code>。</li><li>onObjectRetained安排后台检查对象并手动调用<code>System.gc()</code>来查看对象保留。</li><li>进行<code>dumpHeap()</code> 生成hprof文件，并启动<code>HeapAnalyzerService</code>来分析hprof文件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LeakCanary是适用于Android的内存泄漏检测库。&lt;/p&gt;
&lt;p&gt;本文基于&lt;a href=&quot;https://github.com/square/leakcanary/tree/v2.2&quot;&gt;LeakCanary&lt;/a&gt;最新2.2版本进行分析。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="LeakCanary" scheme="https://blog.xusheng.online/tags/LeakCanary/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之ViewModel</title>
    <link href="https://blog.xusheng.online/2019/11/29/Jetpack%E4%B9%8BViewModel/"/>
    <id>https://blog.xusheng.online/2019/11/29/Jetpack%E4%B9%8BViewModel/</id>
    <published>2019-11-29T05:30:50.000Z</published>
    <updated>2020-09-13T12:40:43.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jetpack之ViewModel解析"><a href="#Jetpack之ViewModel解析" class="headerlink" title="Jetpack之ViewModel解析"></a>Jetpack之ViewModel解析</h2><p><code>ViewModel</code>类旨在以注重生命周期的方式存储和管理界面相关的数据。<code>ViewModel</code>类让数据可在发生屏幕旋转等配置更改后继续留存。</p><p>官网介绍：<a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel指南</a></p><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h3><h4 id="1-1-创建自定义ViewModel"><a href="#1-1-创建自定义ViewModel" class="headerlink" title="1.1 创建自定义ViewModel"></a>1.1 创建自定义ViewModel</h4><p>创建自定义ViewModel有两种方式，最大的区别是ViewMode中不能引用Activity、Fragment的实例。主要原因是：为了防止内存泄漏。如果在某种场景下需要用到上下文Context，在继承ViewMode的时候，可以选择继承AndroidViewModel。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _userName = MutableLiveData&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> userName: LiveData&lt;String&gt; <span class="keyword">get</span>() = _userName</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUserName</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _userName.value = text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-在Activity中使用"><a href="#1-2-在Activity中使用" class="headerlink" title="1.2 在Activity中使用"></a>1.2 在Activity中使用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> viewModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MainViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    viewModel.userName.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">        nameTv.text = it</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    changeNameBtn.setOnClickListener &#123;</span><br><span class="line">        viewModel.setUserName(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ViewModelProvider</code>获取到<code>MainViewModel</code>的实例，然后在Activity中观察<code>MainViewModel</code>中的数据变化和调用其方法。</p><h4 id="1-3-ViewModel的生命周期"><a href="#1-3-ViewModel的生命周期" class="headerlink" title="1.3 ViewModel的生命周期"></a>1.3 ViewModel的生命周期</h4><p>ViewMode在Activity被finish后才会销毁，否则在Activity的生命周期范围内会一直保存在内存中，或者当依附的Fragment detached后进行销毁。 使用官网的一张图来标注Activity的生命周期与ViewMode的生命周期关联，如下图所示：</p><img src="/2019/11/29/Jetpack%E4%B9%8BViewModel/viewmodel-lifecycle.png" class="" title="viewmodel-lifecycle"><h3 id="2-ViewModel原理"><a href="#2-ViewModel原理" class="headerlink" title="2. ViewModel原理"></a>2. ViewModel原理</h3><h4 id="2-1-Activity重建时对象的保存"><a href="#2-1-Activity重建时对象的保存" class="headerlink" title="2.1 Activity重建时对象的保存"></a>2.1 Activity重建时对象的保存</h4><p>在分析<code>ViewModel</code>的源码之前，我们先来看一下Activity是如何保存对象的。</p><p>在Activity中除了使用<code>onSaveInstanceState()</code>来保存数据和<code>onRestoreInstanceState()</code>恢复数据之外，还有另外的接口回调：<code>onRetainNonConfigurationInstance()</code>和<code>getLastNonConfigurationInstance()</code>。当修改Activity的代码如下时，运行的结果和之前完全一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">Activity</span></span>(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> viewModel: MainViewModel? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        getViewModel().userName.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            nameTv.text = it</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        changeNameBtn.setOnClickListener &#123;</span><br><span class="line">            getViewModel().setUserName(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            recreate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getViewModel</span><span class="params">()</span></span>: MainViewModel &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewModel == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> lastStore = lastNonConfigurationInstance <span class="keyword">as</span>? MainViewModel</span><br><span class="line">            <span class="keyword">if</span> (lastStore == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastStore = MainViewModel()</span><br><span class="line">            &#125;</span><br><span class="line">            viewModel = lastStore</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> viewModel!!</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRetainNonConfigurationInstance</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> viewModel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-创建ViewModelProvider"><a href="#2-2-创建ViewModelProvider" class="headerlink" title="2.2 创建ViewModelProvider"></a>2.2 创建ViewModelProvider</h4><p>在Activity中，我们会调用以下方法来获取到ViewModel实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MainViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><p>在<code>ViewModelProvider</code>中有三个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner, <span class="meta">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(owner.getViewModelStore(), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> </span>&#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity的代码中并没有传入<code>ViewModelStoreOwner</code>和<code>ViewModelProvider.Factory</code>对象，说明<code>AppCompatActivity</code>或者其父类中实现了<code>ViewModelStoreOwner</code>接口，找到<code>ComponentActivity</code>发现其不仅实现了<code>ViewModelStoreOwner</code>，还实现了<code>ViewModelProvider.Factory</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">HasDefaultViewModelProviderFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnBackPressedDispatcherOwner</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            NonConfigurationInstances nc =</span><br><span class="line">                    (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">                mViewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewModelProvider.<span class="function">Factory <span class="title">getDefaultViewModelProviderFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDefaultFactory = <span class="keyword">new</span> SavedStateViewModelFactory(</span><br><span class="line">                    getApplication(),</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    getIntent() != <span class="keyword">null</span> ? getIntent().getExtras() : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">    &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">onRetainNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">        ViewModelStore viewModelStore = mViewModelStore;</span><br><span class="line">        <span class="keyword">if</span> (viewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">            <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">            NonConfigurationInstances nc =</span><br><span class="line">                      (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                viewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewModelStore == <span class="keyword">null</span> &amp;&amp; custom == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NonConfigurationInstances nci = <span class="keyword">new</span> NonConfigurationInstances();</span><br><span class="line">        nci.custom = custom;</span><br><span class="line">        nci.viewModelStore = viewModelStore;</span><br><span class="line">        <span class="keyword">return</span> nci;</span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ComponentActivity</code>实现<code>getViewModelStore()</code>的时候先尝试从<code>getLastNonConfigurationInstance()</code>获取使用<code>onRetainNonConfigurationInstance()</code>保存的对象，如果没有才会创建。<code>getDefaultViewModelProviderFactory</code>则是直接返回了<code>SavedStateViewModelFactory</code>对象。</p><h4 id="2-3-ViewModelStore"><a href="#2-3-ViewModelStore" class="headerlink" title="2.3 ViewModelStore"></a>2.3 ViewModelStore</h4><p><code>ViewModelStore</code>类的方法非常简单，它使用了<code>HashMap</code>来缓存了ViewModel。并提供<code>clear()</code>来清理ViewModel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  清除内部存储并通知ViewModels不再使</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-ViewModelProvider-Factory"><a href="#2-4-ViewModelProvider-Factory" class="headerlink" title="2.4 ViewModelProvider.Factory"></a>2.4 ViewModelProvider.Factory</h4><p><code>ViewModelProvider.Factory</code>是一个接口，作用是将传入的<code>Class</code>对象生成具体的ViewModel实例。通过<code>ComponentActivity</code>中默认的实现可以看到<code>SavedStateViewModelFactory</code>通过反射来创建ViewModel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedStateViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">KeyedFactory</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line">        SavedStateHandleController controller = SavedStateHandleController.create(</span><br><span class="line">                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T viewmodel;</span><br><span class="line">            <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">            &#125;</span><br><span class="line">            viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">            <span class="keyword">return</span> viewmodel;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-获取ViewModel"><a href="#2-5-获取ViewModel" class="headerlink" title="2.5 获取ViewModel"></a>2.5 获取ViewModel</h4><p>在<code>ViewModelProvider</code>创建完成之后，调用<code>get()</code>就能获取到ViewModel。这里先尝试从<code>ViewModelStore</code>中或取ViewModel，如果不存在则使用<code>ViewModelProvider.Factory</code>创建，并将创建的实例存入到<code>ViewModelStore</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = (mFactory).create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>当我们在Activity中去实例化<code>ViewModelProvider</code>时，所依赖的activity在其内部会调用<code>getViewModelStore</code>方法去获取一个<code>ViewModelStore</code>对象。如果没有从ViewModelStore中获取到ViewModel对象则创建一个，并保存起来，然后调用<code>ViewModelProvider.get</code>方法将我们的<code>viewmodel</code>实例通过<code>ViewModelStore</code>进行保存管理，当我们的activity的状态发生改变，如旋转屏幕，此时系统会调用<code>onRetainNonConfigurationInstance</code>方法，在这个方法内会将我们的<code>ViewModelStore</code>进行保存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Jetpack之ViewModel解析&quot;&gt;&lt;a href=&quot;#Jetpack之ViewModel解析&quot; class=&quot;headerlink&quot; title=&quot;Jetpack之ViewModel解析&quot;&gt;&lt;/a&gt;Jetpack之ViewModel解析&lt;/h2&gt;&lt;p&gt;&lt;c
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="https://blog.xusheng.online/categories/Jetpack/"/>
    
    
      <category term="ViewModel" scheme="https://blog.xusheng.online/tags/ViewModel/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之LiveData</title>
    <link href="https://blog.xusheng.online/2019/11/02/Jetpack%E4%B9%8BLiveData/"/>
    <id>https://blog.xusheng.online/2019/11/02/Jetpack%E4%B9%8BLiveData/</id>
    <published>2019-11-02T08:11:07.000Z</published>
    <updated>2020-09-13T12:40:43.726Z</updated>
    
    <content type="html"><![CDATA[<p><code>LiveData</code> 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p><p>本文用到的源代码基于<code>androidx.lifecycle:lifecycle-livedata:2.2.0</code>。</p><p>官网介绍：<a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData指南</a></p><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h3><h4 id="1-1-在ViewModel定义LiveData"><a href="#1-1-在ViewModel定义LiveData" class="headerlink" title="1.1 在ViewModel定义LiveData"></a>1.1 在ViewModel定义LiveData</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _liveData: MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">val</span> liveData <span class="keyword">get</span>() = _liveData</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateValue</span><span class="params">(value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _liveData.setValue(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 LiveData 是一个 抽象类，我们不能直接创建它的实例。官方两个它的子类<code>MutableLiveData</code>和<code>MediatorLiveData</code>，它们分别有这不同的使用场景：</p><ul><li><p>MutableLiveData：将<code>postValue(value)</code>和<code>setValue()</code>方法公开，允许外部访问</p></li><li><p>MediatorLiveData：允许合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 <code>MediatorLiveData</code> 对象的观察者。</p></li></ul><p>当我们要更新LiveData中的数据时，通过调用<code>updateValue(value)</code>即可。</p><h4 id="1-2-观察LiveData数据的变化"><a href="#1-2-观察LiveData数据的变化" class="headerlink" title="1.2 观察LiveData数据的变化"></a>1.2 观察LiveData数据的变化</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(saveInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    viewModel.liveData.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCreate: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><h4 id="2-1-Observer"><a href="#2-1-Observer" class="headerlink" title="2.1 Observer"></a>2.1 Observer</h4><p>为LiveData添加观察者的方式特别简单，调用其<code>observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)</code>方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// 用来存放Observer和Observer的包装对象ObserverWrapper</span></span><br><span class="line">    <span class="keyword">private</span> SafeIterableMap&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt; mObservers =</span><br><span class="line">            <span class="keyword">new</span> SafeIterableMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">&quot;observe&quot;</span>); <span class="comment">// 判断observe是不是在主线程执行</span></span><br><span class="line">        <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// 如果当前Lifecycle处于DESTROYED状态，直接返回</span></span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 将owner, observer包装成LifecycleBoundObserver对象</span></span><br><span class="line">        LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">          <span class="comment">// 保存LifecycleBoundObserver到mObservers中，如果存在则返回已存在的值</span></span><br><span class="line">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">          <span class="comment">// 防止重复添加</span></span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                    + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 为Lifecycle添加LifecycleBoundObserver</span></span><br><span class="line">        owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义观察者的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)</code>中接收两个参数，LifecycleOwer和Observer的实现。我们提供的观察者observer在被包装成<code>LifecycleBoundObserver</code>之后，既被添加到了LiveData的观察者集合中，又被添加到了了Lifecycle的观察者集合中。</p><p>LiveData本身定义的观察者<code>Observer</code>是很简单的，只有一个<code>onChanged</code>方法，在LiveData数据发生变化时被调用。为了让LiveData与生命周期关联，才有了 <code>LifecycleBoundObserver</code>。</p><blockquote><p>Livecycle相关的解析可以查看<a href="http://blog.xusheng.online/2020/08/09/Jetpack%E4%B9%8BLiveData/">Jetpack之LiveData</a>。</p></blockquote><p><code>LifecycleBoundObserver</code>继承自<code>ObserverWrapper</code>，我们先看看<code>ObserverWrapper</code>中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">      <span class="comment">// LiveData原始的观察者，也就是我们传入的</span></span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; mObserver;</span><br><span class="line">      <span class="comment">// 是否处于活动状态</span></span><br><span class="line">    <span class="keyword">boolean</span> mActive;</span><br><span class="line">      <span class="comment">// 版本号，默认为START_VERSION</span></span><br><span class="line">    <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">    ObserverWrapper(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        mObserver = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 如果活动状态没有发生改变则返回</span></span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">              <span class="comment">// LiveData中的方法，空实现</span></span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">              <span class="comment">// LiveData中的方法，空实现</span></span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">              <span class="comment">// LiveData中的方法</span></span><br><span class="line">            <span class="comment">// ObserverWrapper处于活动状态时会分发值</span></span><br><span class="line">            dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObserverWrapper的主要职责是处理活动状态的变化。这里的<code>mActive</code>值的是被包装者<code>mObserver</code>是否处于活动状态，处于活动状态的观察者可以接收LiveData数据的变化，否则则不能。</p><p>Livedata本身也是有活动状态的，LiveData的活动状态取决于它本身的观察者中是否至少有一个处于“Active”状态。当LiveData从非活动状态变为活动状态时<code>onActive()</code>会被调用，从活动状态变为非活动状态时<code>onInactive()</code>会被调用。</p><p>再来看看对ObserverWrapper进一步的包装<code>LifecycleBoundObserver</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;  <span class="comment">// Lifecycle持有者</span></span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Lifecycle至少是STARTED时才允许活动</span></span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 当Lifecycle处于DESTROYED时，从LiveData中移除观察者</span></span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 当生命周期改变时就调用ObserverWrapper的activeStateChanged</span></span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 从Lifecycle观察者中移除</span></span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LifecycleBoundObserver实现了GenericLifecycleObserver接口，这就可以做到：</p><ol><li><p>当生命周期变化时改变是否处于活动状态</p></li><li><p>当生命周期处于<code>DESTROYED</code>时，从LiveDatah和Lifecycle中移除观察者。</p></li></ol><p><strong>总结一下LiveData添加观察者的流程和内容：</strong></p><ol><li><p>接收一个LifecycleOwer和用户传入的Observer</p></li><li><p>将LifecycleOwer和Observer包装成LifecycleBoundObserver，并将包装后的对象添加到LiveData和Lifecycle的观察者中</p></li><li><p>在生命周期改变时设置LifecycleBoundObserver的活动状态</p></li><li><p>在生命周期为<code>DESTROYED</code>时，从LiveDatah和Lifecycle中移除观察者</p></li></ol><blockquote><p>此外LiveData还可以通过<code>observeForever(@NonNull Observer&lt;? super T&gt; observer)</code>来添加观察者。其实就是没有绑定生命周期的观察者，也可以手动移除。</p></blockquote><h4 id="2-2-setValue"><a href="#2-2-setValue" class="headerlink" title="2.2 setValue"></a>2.2 setValue</h4><p>LiveData需要在两种情况下分发数据：</p><ol><li><p>LiveData本身的数据发生改变时</p></li><li><p>LiveData中的某个观察者因为生命周期的变化处于活动时</p></li></ol><p>改变LiveData的数据需要使用其<code>setValue(T value)</code>或者<code>postValue(T value)</code>方法。这取决于是否在主线程传入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据锁，postValue时使用</span></span><br><span class="line">    <span class="keyword">final</span> Object mDataLock = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="comment">// LiveData的初始版本</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_VERSION = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 初始情况下LiveData</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object NOT_SET = <span class="keyword">new</span> Object();</span><br><span class="line">      <span class="comment">// LiveData的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object mData = NOT_SET;</span><br><span class="line">      <span class="comment">// 通过postValue设置数据</span></span><br><span class="line">    <span class="keyword">volatile</span> Object mPendingData = NOT_SET;</span><br><span class="line">      <span class="comment">// 用于和ObserverWrapper中的version进行比较，防止重复通知</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mVersion = START_VERSION;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            setValue((T) newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> postTask;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            postTask = mPendingData == NOT_SET;</span><br><span class="line">            mPendingData = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 切换到主线程调用setValue</span></span><br><span class="line">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">          <span class="comment">// mVersion递增</span></span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">          <span class="comment">// 分发mData数据变化</span></span><br><span class="line">        dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 如果当前线程不在主线程就会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertMainThread</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ArchTaskExecutor.getInstance().isMainThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot invoke &quot;</span> + methodName + <span class="string">&quot; on a background&quot;</span></span><br><span class="line">                    + <span class="string">&quot; thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出<code>postValue()</code>最终还是调用的<code>setValue()</code>。<code>setValue()</code>也很简单，增加版本号、设置数据、然后调用<code>dispatchingValue()</code>分发数据。</p><p>我们继续跟进``dispatchingValue()`：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDispatchingValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDispatchInvalidated;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">              <span class="comment">// 只分发处于活动状态的ObserverWrapper</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 如果ObserverWrapper应该为不活动时，将ObserverWrapper不活动</span></span><br><span class="line">          <span class="comment">// 例如LifecycleBoundObserver收到ON_STOP事件处于CREATED状态时就不会分发数据</span></span><br><span class="line">          <span class="comment">// 这里再一次进行了判断</span></span><br><span class="line">        <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 如果数据已经是最新的了就不需要分发</span></span><br><span class="line">        <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 重新设置ObserverWrapper的版本号</span></span><br><span class="line">        observer.mLastVersion = mVersion;</span><br><span class="line">          <span class="comment">// 回调我们传入的Observer方法</span></span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// mDispatchingValue和mDispatchInvalidated防止在数据分发的时候</span></span><br><span class="line">          <span class="comment">// LiveData的数据再次发生改变</span></span><br><span class="line">        <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 如果传入的ObserverWrapper不为空，只需要对传入的ObserverWrapper分发数据</span></span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 对所有的ObserverWrapper进行分发数据</span></span><br><span class="line">                <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出，当LiveData的数据发生变化时，对所有观察者考虑是否通知数据的变化；某个观察者的变为活动时，只对这个观察者只对该观察者本身考虑是否通知数据的变化。</p><p>在通知观察者的时候同样会和ObserverWrapper的版本号进行比对，避免重复通知。</p><h4 id="2-3-MediatorLiveData"><a href="#2-3-MediatorLiveData" class="headerlink" title="2.3 MediatorLiveData"></a>2.3 MediatorLiveData</h4><p>MediatorLiveData也是LiveData的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorLiveData</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MutableLiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SafeIterableMap&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; mSources = <span class="keyword">new</span> SafeIterableMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">addSource</span><span class="params">(<span class="meta">@NonNull</span> LiveData&lt;S&gt; source, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> S&gt; onChanged)</span> </span>&#123;</span><br><span class="line">        Source&lt;S&gt; e = <span class="keyword">new</span> Source&lt;&gt;(source, onChanged);</span><br><span class="line">        Source&lt;?&gt; existing = mSources.putIfAbsent(source, e);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; existing.mObserver != onChanged) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;This source was already added with the different observer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 如果有观察者</span></span><br><span class="line">        <span class="keyword">if</span> (hasActiveObservers()) &#123;</span><br><span class="line">              <span class="comment">// e.mLiveData.observeForever</span></span><br><span class="line">            e.plug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">removeSource</span><span class="params">(<span class="meta">@NonNull</span> LiveData&lt;S&gt; toRemote)</span> </span>&#123;</span><br><span class="line">        Source&lt;?&gt; source = mSources.remove(toRemote);</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 其实调用的就是source.mLiveData.removeObserver()</span></span><br><span class="line">            source.unplug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 如果MediatorLiveData处于活动状态时</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123;</span><br><span class="line">            source.getValue().plug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 如果MediatorLiveData处于非活动状态时</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123;</span><br><span class="line">            source.getValue().unplug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LiveData&lt;V&gt; mLiveData;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> V&gt; mObserver;</span><br><span class="line">        <span class="keyword">int</span> mVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">        Source(LiveData&lt;V&gt; liveData, <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> V&gt; observer) &#123;</span><br><span class="line">            mLiveData = liveData;</span><br><span class="line">            mObserver = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">plug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 为mLiveData添加观察者</span></span><br><span class="line">            mLiveData.observeForever(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unplug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 移除mLiveData的观察者</span></span><br><span class="line">            mLiveData.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mVersion != mLiveData.getVersion()) &#123;</span><br><span class="line">                mVersion = mLiveData.getVersion();</span><br><span class="line">                mObserver.onChanged(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MediatorLiveData可以添加其它LiveData的监听，当其它LiveData的观察者被回调时就会作用的MediatorLiveData上。</p><p>这里结合的<code>Transformations</code>能更好的使用MediatorLiveData，具体查看<a href="https://developer.android.com/reference/androidx/lifecycle/Transformations">Transformations</a>。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ol><li>我们的观察者经过包装后，被添加进LiveData的观察者集合，也被添加到了我们提供的Lifecycle的观察者集合中（假如不是通过调用<code>observeForever</code>）</li><li>无论是LiveData本身的数据发生变化，还是观察者变为“活动”状态时，我们的观察者都会被通知。</li><li>当我们的观察者处于“活动”状态并且没有被通知过的时候（version低于LiveData的version），Observer的onChanged方法才会被调用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;LiveData&lt;/code&gt; 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="https://blog.xusheng.online/categories/Jetpack/"/>
    
    
      <category term="LiveData" scheme="https://blog.xusheng.online/tags/LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之Lifecycle</title>
    <link href="https://blog.xusheng.online/2019/09/17/Jetpack%E4%B9%8BLifecycle/"/>
    <id>https://blog.xusheng.online/2019/09/17/Jetpack%E4%B9%8BLifecycle/</id>
    <published>2019-09-17T04:57:00.000Z</published>
    <updated>2020-09-13T12:40:43.725Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle是一个可以用来响应其他组件（如Activity、Fragment）生命周期变化的类。</p><p>本文源代码基于:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> lifecycle_version = <span class="string">&quot;2.1.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common:$lifecycle_version&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot;</span></span><br></pre></td></tr></table></figure><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h3><h4 id="1-1-创建LifecycleObserver"><a href="#1-1-创建LifecycleObserver" class="headerlink" title="1.1 创建LifecycleObserver"></a>1.1 创建LifecycleObserver</h4><p>通过实现<code>LifecycleObserver</code>接口，然后就能根据注解响应到生命周期事件：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>(), LifecycleObserver &#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-创建LifecycleOwner"><a href="#1-2-创建LifecycleOwner" class="headerlink" title="1.2 创建LifecycleOwner"></a>1.2 创建LifecycleOwner</h4><p>实现<code>LifecycleOwner</code>接口，然后通过<code>LifecycleRegistry</code>处理生命周期事件：</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">Activity</span></span>(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-3-为生命周期添加观察者"><a href="#1-3-为生命周期添加观察者" class="headerlink" title="1.3 为生命周期添加观察者"></a>1.3 为生命周期添加观察者</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> viewModel = MainViewModel()</span><br><span class="line">    lifecycle.addObserver(viewModel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动Activity后就会看到如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;MyViewModel: onCreate: </span><br></pre></td></tr></table></figure><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p><code>lifecycleRegistry</code>是<code>Lifecycle</code>的实现类。Lifecycle响应生命周期的原理很简单，就是在Activity或者Fragment的生命周期中发送事件，然后添加一个观察者去响应这些事件。</p><blockquote><p>在实际使用中我们并不需要去处理生命周期事件的发送，因为Support Library 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 <code>LifecycleOwner</code>接口。</p></blockquote><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h3><p>在分析源码之前我们先介绍一下Lifecycle中关键的几个类：</p><ul><li><code>Lifecycle</code>：用于存储组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</li><li><code>Lifecycle.Event</code>：生命周期事件，这些事件映射到 Activity 和 Fragment 中的回调方法。</li><li><code>Lifecycle.State</code>：生命周期状态。</li><li><code>LifecycleOwner</code>：接口，表示类具有<code>Lifecycle</code>。</li><li><code>LifecycleObserve</code>：接口，表示类可以通过<code>OnLifecycleEvent</code>注释响应生命周期。</li><li><code>LifecycleRegistry</code>：<code>Lifecycle</code>的实现类。</li></ul><h4 id="2-1-事件和状态"><a href="#2-1-事件和状态" class="headerlink" title="2.1 事件和状态"></a>2.1 事件和状态</h4><p><code>Livecycle</code>使用两种主要枚举跟踪其关联组件的生命周期状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Event &#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们对应的关系如下图所示:</p><img src="/2019/09/17/Jetpack%E4%B9%8BLifecycle/lifecycle-states.svg" class="" title="lifecycle-states"><h4 id="2-2-Lifecycle生命周期事件的分发"><a href="#2-2-Lifecycle生命周期事件的分发" class="headerlink" title="2.2 Lifecycle生命周期事件的分发"></a>2.2 Lifecycle生命周期事件的分发</h4><p>上面说到在正式开发中一般不需要我们去分发Lifecycle的生命周期事件，这些事件都由sdk处理好了。进入<code>ComponentActivity</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">core</span>.<span class="title">app</span>.<span class="title">ComponentActivity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ViewModelStoreOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SavedStateRegistryOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnBackPressedDispatcherOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">       ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它同样实现了<code>LifecycleOwner</code>接口，但是不同的是多了一个<code>ReportFragment</code>。那我们就看看<code>ReportFragment</code>是用来干什么的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">&quot;androidx.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReportFragment.injectIfNeededIn(activity)</code>向Activity中添加一个无界面的<code>Fragment</code>，然后在<code>Fragment</code>的生命周期回调中分发事件。</p><p><code>Fragment</code>中也会有类似的操作。</p><h4 id="2-3-添加生命周期观察者"><a href="#2-3-添加生命周期观察者" class="headerlink" title="2.3 添加生命周期观察者"></a>2.3 添加生命周期观察者</h4><p><code>LifecycleRegistry</code>通过调用<code>addObserver(observer)</code>来添加一个观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">      <span class="comment">// 创建一个ObserverWithState对象用来接收事件</span></span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">      <span class="comment">// 将statefulObserver添加到mObserverMap</span></span><br><span class="line">      <span class="comment">// 如果ObserverMap中已经存在则返回已存在的值，防止重复添加</span></span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 是否正在添加LifecycleObserver或者正在同步生命周期事件</span></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">      <span class="comment">// 根据mParentState计算当前状态</span></span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">      <span class="comment">// 如果statefulObserver的状态在targetState之前</span></span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">          <span class="comment">// 回调事件</span></span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 如果不是添加LifecycleObserver且不在回调周期事件，那么同步所有Observer</span></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单：</p><ol><li>首先创建一个<code>ObserverWithState</code>对象(<code>ObserverWithState</code>具体在后面会说到)</li><li>判断当前正在添加LifecycleObserver或者正在回调生命周期事件，如果是直接使用<code>ObserverWithState</code>回调事件，否则同步回调事件。</li></ol><h4 id="2-4-生命周期事件的回调"><a href="#2-4-生命周期事件的回调" class="headerlink" title="2.4 生命周期事件的回调"></a>2.4 生命周期事件的回调</h4><p><code>LifecycleRegistry</code>有三种方法去发送生命周期事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markState</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">    setCurrentState(state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">    moveToState(state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>getStateAfter(event)</code>的方法的作用是获取事件之后的状态，对比之前的时序图还是很好理解。</p><p>这三个方法最终都会调用到<code>moveToState()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态和设置的状态相同</span></span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">      <span class="comment">// 如果正在同步状态或者正在添加LifecycleObserver</span></span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 有新的事件产生</span></span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 同步状态</span></span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先判断当前的状态和要同步的状态是否一样，如果相同就不做处理。然后判断当前是不是正在同步或者正在添加LifecycleObserver(添加LifecycleObserver的时候也会执行<code>sync()</code>)，如果满足上述条件之一则表明有新的事件产生。</p><p>最后调用<code>sync()</code>同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class="line">                + <span class="string">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="comment">// 比较当前状态和mObserverMap中最早添加的LifecycleObserver中的状态</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 向后同步</span></span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// mObserverMap中最新添加的LifecycleObserver中的状态</span></span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); </span><br><span class="line">        <span class="comment">// 如果有最新添加的并且当前状态在最新添加的LifecycleObserver中的状态之前</span></span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 向前同步</span></span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap</code>类似于<code>LinkedHashMap</code>，它支持迭代期间进行修改。<code>sync</code>会根据当前状态和mObserverMap中的eldest和newest的状态做对比 ，判断当前状态是向前还是向后。<code>forwardPass()</code>和<code>backwardPass()</code>的代码大同小异，这里以<code>forwardPass()</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">            mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">          <span class="comment">// observer中保存的状态在当前状态之前</span></span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">              <span class="comment">// 像mParentStates添加state</span></span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">              <span class="comment">// 回调事件</span></span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">              <span class="comment">// 从mParentStates删除最后一个值</span></span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代<code>mObserverMap</code>，然后进行事件回调。<code>mParentStates</code>主要在添加<code>LifecycleObserver</code>中用到，<code>upEvent(observer.mState)</code>会得到当前状态的向前的事件。<code>ObserverWithState</code>从名称就可以看出，它内部包含了一个<code>State</code>和<code>LifecycleEventObserver</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">          <span class="comment">// 获取到对应的LifecycleEventObserver实现类</span></span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = getStateAfter(event);</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lifecycling.lifecycleEventObserver(observer)</code>根据<code>LifecycleObserver</code>来创建<code>LifecycleEventObserver</code>的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LifecycleEventObserver <span class="title">lifecycleEventObserver</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 是不是LifecycleEventObserver的实现类</span></span><br><span class="line">    <span class="keyword">boolean</span> isLifecycleEventObserver = object <span class="keyword">instanceof</span> LifecycleEventObserver;</span><br><span class="line">      <span class="comment">// 是不是FullLifecycleObserver的实现类</span></span><br><span class="line">    <span class="keyword">boolean</span> isFullLifecycleObserver = object <span class="keyword">instanceof</span> FullLifecycleObserver;</span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FullLifecycleObserverAdapter((FullLifecycleObserver) object,</span><br><span class="line">                (LifecycleEventObserver) object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FullLifecycleObserverAdapter((FullLifecycleObserver) object, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LifecycleEventObserver) object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; klass = object.getClass();</span><br><span class="line">      <span class="comment">// 获取观察者构造函数类型</span></span><br><span class="line">    <span class="keyword">int</span> type = getObserverConstructorType(klass);</span><br><span class="line">    <span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">          <span class="comment">// 通过引入kapt &quot;android.arch.lifecycle:compiler:2.1.0&quot;生成的实现</span></span><br><span class="line">        List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors =</span><br><span class="line">                sClassToAdapters.get(klass);</span><br><span class="line">        <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            GeneratedAdapter generatedAdapter = createGeneratedAdapter(</span><br><span class="line">                    constructors.get(<span class="number">0</span>), object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        GeneratedAdapter[] adapters = <span class="keyword">new</span> GeneratedAdapter[constructors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">            adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveGenericLifecycleObserver(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们这里的产生的实现就是<code>ReflectiveGenericLifecycleObserver</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectiveGenericLifecycleObserver</code>在<code>onStateChanged()</code>会调用CallbackInfo的invokeCallbacks方法。在讲这个方法前，需要先了解CallbackInfo是怎么创建的，是由createInfo方法创建的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CallbackInfo <span class="title">createInfo</span><span class="params">(Class klass, <span class="meta">@Nullable</span> Method[] declaredMethods)</span> </span>&#123;</span><br><span class="line">       Class superclass = klass.getSuperclass();</span><br><span class="line">       Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      ...</span><br><span class="line">       Method[] methods = declaredMethods != <span class="keyword">null</span> ? declaredMethods : getDeclaredMethods(klass);</span><br><span class="line">       <span class="keyword">boolean</span> hasLifecycleMethods = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">              <span class="comment">// 遍历各个方法，获取方法上的名为OnLifecycleEvent的注解，这个注解正是实现LifecycleObserver接口时用到的</span></span><br><span class="line">           OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class);</span><br><span class="line">           <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           hasLifecycleMethods = <span class="keyword">true</span>;</span><br><span class="line">           Class&lt;?&gt;[] params = method.getParameterTypes();</span><br><span class="line">           <span class="keyword">int</span> callType = CALL_TYPE_NO_ARG;</span><br><span class="line">           <span class="keyword">if</span> (params.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               callType = CALL_TYPE_PROVIDER;</span><br><span class="line">               <span class="keyword">if</span> (!params[<span class="number">0</span>].isAssignableFrom(LifecycleOwner.class)) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           <span class="string">&quot;invalid parameter type. Must be one and instanceof LifecycleOwner&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">              <span class="comment">// 获取该注解的值，也就是在@OnLifecycleEvent中定义的事件</span></span><br><span class="line">           Lifecycle.Event event = annotation.value();</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">// 新建了一个MethodReference，其内部包括了使用了该注解的方法</span></span><br><span class="line">           MethodReference methodReference = <span class="keyword">new</span> MethodReference(callType, method);</span><br><span class="line">           verifyAndPutHandler(handlerToEvent, methodReference, event, klass);</span><br><span class="line">       &#125;</span><br><span class="line">       CallbackInfo info = <span class="keyword">new</span> CallbackInfo(handlerToEvent);</span><br><span class="line">       mCallbackMap.put(klass, info);</span><br><span class="line">       mHasLifecycleMethods.put(klass, hasLifecycleMethods);</span><br><span class="line">       <span class="keyword">return</span> info;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实就是回调<code>ViewModel</code>中注解的方法。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p><code>Lifecycle</code>的流程如下：</p><ol><li><code>Activity</code>或<code>Fragment</code>中实现<code>LifecycleOwner</code>接口。</li><li>为<code>Lifecycle</code>添加生命周期观察者<code>LifecycleObserver</code>。</li><li>通过<code>LifecycleRegistry</code>在<code>Activity</code>或<code>Fragment</code>的生命周期方法中发送事件。</li><li><code>LifecycleRegistry</code>根据不同的实现的<code>LifecycleEventObserver</code>来回调<code>onStateChanged(LifecycleOwner owner, Event event)</code>。</li><li><code>LifecycleObserver</code>观察到生命周期事件。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle是一个可以用来响应其他组件（如Activity、Fragment）生命周期变化的类。&lt;/p&gt;
&lt;p&gt;本文源代码基于:&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="https://blog.xusheng.online/categories/Jetpack/"/>
    
    
      <category term="Lifecycle" scheme="https://blog.xusheng.online/tags/Lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码解析</title>
    <link href="https://blog.xusheng.online/2019/08/15/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.xusheng.online/2019/08/15/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2019-08-15T00:48:17.000Z</published>
    <updated>2020-09-13T12:40:43.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-开始使用"><a href="#1-开始使用" class="headerlink" title="1. 开始使用"></a>1. 开始使用</h3><p>在<code>build.gradle</code>中添加依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> okhttpVersion = <span class="string">&quot;4.2.2&quot;</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.okhttp3:okhttp:$okhttpVersion&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>OkHttp 4.0后就使用了Kotlin来重写</p></blockquote><p>创建<code>OkHttpClient</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttpClient = OkHttpClient.Builder()</span><br><span class="line">            .build()</span><br></pre></td></tr></table></figure><p>发送请求并响应返回结果:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">        .build()</span><br><span class="line"><span class="keyword">val</span> call = okHttpClient.newCall(request)</span><br><span class="line"><span class="keyword">val</span> response = call.execute()</span><br></pre></td></tr></table></figure><p>下面我们以这个例子为切入点，开始分析OkHttp的内部实现。</p><h3 id="2-OkHttpClient的创建"><a href="#2-OkHttpClient的创建" class="headerlink" title="2.  OkHttpClient的创建"></a>2.  OkHttpClient的创建</h3><p>OkHttpClient的创建方式有两种：通过<code>OkHttpClient.Builder</code>创建和直接使用构造方创建，：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (builder.sslSocketFactoryOrNull != <span class="literal">null</span> || connectionSpecs.none &#123; it.isTls &#125;) &#123;</span><br><span class="line">      <span class="keyword">this</span>.sslSocketFactoryOrNull = builder.sslSocketFactoryOrNull</span><br><span class="line">      <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner</span><br><span class="line">      <span class="keyword">this</span>.x509TrustManager = builder.x509TrustManagerOrNull</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.x509TrustManager = Platform.<span class="keyword">get</span>().platformTrustManager()</span><br><span class="line">      Platform.<span class="keyword">get</span>().configureTrustManager(x509TrustManager)</span><br><span class="line">      <span class="keyword">this</span>.sslSocketFactoryOrNull = newSslSocketFactory(x509TrustManager!!)</span><br><span class="line">      <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.<span class="keyword">get</span>(x509TrustManager!!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sslSocketFactoryOrNull != <span class="literal">null</span>) &#123;</span><br><span class="line">      Platform.<span class="keyword">get</span>().configureSslSocketFactory(sslSocketFactoryOrNull)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.certificatePinner = builder.certificatePinner</span><br><span class="line">        .withCertificateChainCleaner(certificateChainCleaner)</span><br><span class="line"></span><br><span class="line">    check(<span class="literal">null</span> !<span class="keyword">in</span> (interceptors <span class="keyword">as</span> List&lt;Interceptor?&gt;)) &#123;</span><br><span class="line">      <span class="string">&quot;Null interceptor: <span class="variable">$interceptors</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(<span class="literal">null</span> !<span class="keyword">in</span> (networkInterceptors <span class="keyword">as</span> List&lt;Interceptor?&gt;)) &#123;</span><br><span class="line">      <span class="string">&quot;Null network interceptor: <span class="variable">$networkInterceptors</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: OkHttpClient = OkHttpClient(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>init</code>里面为一些属性赋值，但是对比一下之前版本的构造方法，发现少了很多的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = builder.dispatcher;</span><br><span class="line">  <span class="keyword">this</span>.proxy = builder.proxy;</span><br><span class="line">  <span class="keyword">this</span>.protocols = builder.protocols;</span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);</span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);</span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = builder.proxySelector;</span><br><span class="line">  <span class="keyword">this</span>.cookieJar = builder.cookieJar;</span><br><span class="line">  <span class="keyword">this</span>.cache = builder.cache;</span><br><span class="line">  <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">      certificateChainCleaner);</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = builder.connectionPool;</span><br><span class="line">  <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = builder.connectTimeout;</span><br><span class="line">  <span class="keyword">this</span>.readTimeout = builder.readTimeout;</span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = builder.writeTimeout;</span><br><span class="line">  <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为kotlin的成员变量可以通过构造方法中的参数来赋值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;dispatcher&quot;</span>) <span class="keyword">val</span> dispatcher: Dispatcher = builder.dispatcher</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;connectionPool&quot;</span>) <span class="keyword">val</span> connectionPool: ConnectionPool = builder.connectionPool</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">    builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">    builder.networkInterceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;eventListenerFactory&quot;</span>) <span class="keyword">val</span> eventListenerFactory: EventListener.Factory =</span><br><span class="line">    builder.eventListenerFactory</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;retryOnConnectionFailure&quot;</span>) <span class="keyword">val</span> retryOnConnectionFailure: <span class="built_in">Boolean</span> =</span><br><span class="line">    builder.retryOnConnectionFailure</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里每个字段的意思先不去详细了解，我们的目的是为了了解它内部的实现机制。</p><h3 id="3-Request、Call"><a href="#3-Request、Call" class="headerlink" title="3. Request、Call"></a>3. Request、Call</h3><p>接下来我们看看如何去创建一个请求。</p><h4 id="3-1-Request"><a href="#3-1-Request" class="headerlink" title="3.1 Request"></a>3.1 Request</h4><p><code>Request</code>中的代码很简单，也是通过构造方法或者<code>Request.Builder</code>来创建：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;url&quot;</span>) <span class="keyword">val</span> url: HttpUrl, <span class="comment">// 请求Url</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;method&quot;</span>) <span class="keyword">val</span> method: String, <span class="comment">// 请求方法 GET、POST</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;headers&quot;</span>) <span class="keyword">val</span> headers: Headers, <span class="comment">// 请求头</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;body&quot;</span>) <span class="keyword">val</span> body: RequestBody?, <span class="comment">// 请求体</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">val</span> tags: Map&lt;Class&lt;*&gt;, Any&gt; <span class="comment">// 请求tag</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: Request &#123;</span><br><span class="line">      <span class="keyword">return</span> Request(</span><br><span class="line">          checkNotNull(url) &#123; <span class="string">&quot;url == null&quot;</span> &#125;,</span><br><span class="line">          method,</span><br><span class="line">          headers.build(),</span><br><span class="line">          body,</span><br><span class="line">          tags.toImmutableMap()</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Call"><a href="#3-2-Call" class="headerlink" title="3.2 Call"></a>3.2 Call</h3><p>我们回到<code>okHttpClient.newCall(request)</code>这一行代码。这里<code>OkHttpClient</code>通过我们的请求信息来创建了一个<code>Call</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">  <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>RealCall</code>是Call的实现类，我们先来看看Call的接口方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Call</span> : <span class="type">Cloneable &#123;</span></span></span><br><span class="line">  <span class="comment">// 原始请求信息</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span>: Request</span><br><span class="line">  <span class="comment">// 通过执行请求</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response</span><br><span class="line">  <span class="comment">// 异步执行请求</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span></span><br><span class="line">  <span class="comment">// 尽可能的取消请求，已完成的请求无法被取消</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">  <span class="comment">// 调用execute或者enqueue都返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isExecuted</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">  <span class="comment">// 是否被取消</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isCanceled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">  <span class="comment">// 超时</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span>: Timeout</span><br><span class="line">  <span class="comment">// 创建一个与当前Call相同的Call，即使当前Call已经被execute或者enqueue</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clone</span><span class="params">()</span></span>: Call</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>RealCall</code>，看看它的<code>newRealCall()</code>以及构造方法等：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> transmitter: Transmitter</span><br><span class="line">  <span class="keyword">var</span> executed: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: RealCall &#123;</span><br><span class="line">      <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">      <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">        transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Transmitter</code>是OkHttp的应用层和网络层之间的桥梁。</p><h3 id="3-3-Transmitter"><a href="#3-3-Transmitter" class="headerlink" title="3.3 Transmitter"></a>3.3 Transmitter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectionPool: RealConnectionPool = client.connectionPool.delegate</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> eventListener: EventListener = client.eventListenerFactory.create(call)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> timeout = <span class="keyword">object</span> : AsyncTimeout() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timedOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">      cancel()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.apply &#123;</span><br><span class="line">    timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建 Transmitter 对象传入了OkHttpClient对象和RealCall对象，并设置了相关指标的监听器和 ConnectionPool。</p><p>具体的方法在后续执行的时候我们再深入了解。</p><h3 id="4-RealCall-execute"><a href="#4-RealCall-execute" class="headerlink" title="4. RealCall.execute()"></a>4. RealCall.execute()</h3><p>接下来我们重点看看OkHttp是如何放送请求的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    executed = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter()</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>RealCall.execute()</code>执行时，立马将<code>executed</code>设置为true，如果多次调用就会报错。</p><p>接下来轮到我们看看<code>transmitter.timeoutEnter()</code>和<code>transmitter.callStart()</code>两个方法理的内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> eventListener: EventListener = client.eventListenerFactory.create(call)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> timeout = <span class="keyword">object</span> : AsyncTimeout() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timedOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">      cancel()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.apply &#123;</span><br><span class="line">    timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">timeoutEnter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeout.enter()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">callStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.callStackTrace = Platform.<span class="keyword">get</span>().getStackTraceForCloseable(<span class="string">&quot;response.body().close()&quot;</span>)</span><br><span class="line">    eventListener.callStart(call)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EventListener</code>用于Call事件的监听器，里面的接口对应了Call的每个事件。在 这里默认的是EventListener.NONE空实现，当我们要监听Call事件的时候我们可以看看<a href="https://github.com/square/okhttp/blob/master/okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/LoggingEventListener.kt">LoggingEventListener</a>。</p><p><code>AsyncTimeout</code>用于监听Call是否超时，它是一个链表。当<code>timeout.enter()</code>执行的时候<code>AsyncTimeout</code>便从<code>Watchdog</code>线程来对比OkHttpClient中设置的时间，如果超时就会调用<code>timedOut()</code>。大致如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTimeout</span> : <span class="type">Timeout</span></span>() &#123;*/</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> next: AsyncTimeout? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> timeoutAt = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    scheduleTimeout(<span class="keyword">this</span>, timeoutNanos, hasDeadline)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: AsyncTimeout? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleTimeout</span><span class="params">(node: <span class="type">AsyncTimeout</span>, timeoutNanos: <span class="type">Long</span>, hasDeadline: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">      synchronized(AsyncTimeout::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">        <span class="comment">// Start the watchdog thread and create the head node when the first timeout is scheduled.</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">          head = AsyncTimeout()</span><br><span class="line">          <span class="comment">// 启动watch dog</span></span><br><span class="line">          Watchdog().start()</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Watchdog 线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Watchdog</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>() : Thread(<span class="string">&quot;Okio Watchdog&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">      isDaemon = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> timedOut: AsyncTimeout? = <span class="literal">null</span></span><br><span class="line">          synchronized(AsyncTimeout::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">            timedOut = awaitTimeout()</span><br><span class="line">            <span class="keyword">if</span> (timedOut === head) &#123;</span><br><span class="line">              head = <span class="literal">null</span></span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 超时了</span></span><br><span class="line">          timedOut?.timedOut()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ignored: InterruptedException) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们回到<code>RealCall</code>，继续看看<code>client.dispatcher.executed(this)</code>的调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 同步运行的Call数组队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 将Call插入到队列末尾</span></span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就调用<code>getResponseWithInterceptorChain()</code>去返回结果了，最后调用<code>client.dispatcher.finished(this)</code>从<code>Dispatchs.runningSyncCalls</code>中移除当前的Call。</p><p><strong>小结一下</strong></p><p>OkHttp发送请求的流程为：</p><ol><li>创建Request请求信息</li><li>OkHttpClient执行<code>newCall()</code>的时候使用Request对象来创建RealCall</li><li>RealCall执行同步请求<code>execute()</code>并返回Response：<ol><li>使用transmitter来记录超时信息</li><li>使用transmitter发送Call开始事件</li><li>将当前Call添加到Dispatcher中当前运行的Call队列(<code>runningAsyncCalls</code>)末尾</li><li>调用<code>getResponseWithInterceptorChain()</code>获取结果并返回(当然其方法内部也会调用Transmitter的相关方法)</li><li>从Dispatchers中的运行Call队列移除当前Call。</li></ol></li></ol><h3 id="5-getResponseWithInterceptorChain"><a href="#5-getResponseWithInterceptorChain" class="headerlink" title="5. getResponseWithInterceptorChain()"></a>5. getResponseWithInterceptorChain()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  interceptors += client.interceptors <span class="comment">// 用户传入的拦截器</span></span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client) </span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)  </span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    <span class="comment">// 如果不是WebSocket链接</span></span><br><span class="line">    <span class="comment">// 将添加用户传入的网络拦截器</span></span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">      client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">      <span class="comment">// 关闭Response.body.source</span></span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 释放链接</span></span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将用户传入的一些拦截器和OkHttp自带的拦截器加入到<code>interceptors</code>列表中，然后创建一个拦截器链<code>RealInterceptorChain</code>，并调用其<code>proceed()</code>开始处理网络请求。</p><p>下面来看看<code>RealInterceptorChain</code>是如何处理网络请求的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> transmitter: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> readTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> writeTimeout: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> calls: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    calls++</span><br><span class="line">    ...</span><br><span class="line">       <span class="comment">// 在index为n的时候创建一个index为n+1的拦截器链</span></span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    check(exchange == <span class="literal">null</span> || index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑相当于：</p><ol><li><p>在<code>getResponseWithInterceptorChain()</code>创建了一个<code>index</code>为0的<code>RealInterceptorChain</code>，接着就调用了其<code>proceed()</code></p></li><li><p>在<code>RealInterceptorChain.proceed()</code>中，当index为n的时候创建一个index为n+1的拦截器链</p></li><li><p>执行<code>interceptor.intercept(next)</code>的时候会调用<code>chain.proceed()</code>，相当于回到了<code>RealInterceptorChain.proceed()</code>调用。(<code>CallServerInterceptor</code>是最后添加的，而且里面并没有执行<code>chain.proceed()</code>，它是直接与服务器建立连接。)</p><p>可以看到我们自定义token拦截器的时候也会执行<code>chain.proceed()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestInterceptor</span> : <span class="type">Interceptor &#123;</span></span></span><br><span class="line">    <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> r = chain.request().newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            r.addHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer <span class="variable">$token</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(r.build())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>下图为OkHttp工作的大致流程，来自<a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html">拆轮子系列：拆 OkHttp</a>：</p><img src="/2019/08/15/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/okhttp_full_process.png" class="" title="okhttp_full_process"><p>接下来我们看看这些拦截器的一些实现</p><h3 id="6-RetryAndFollowUpInterceptor"><a href="#6-RetryAndFollowUpInterceptor" class="headerlink" title="6. RetryAndFollowUpInterceptor"></a>6. RetryAndFollowUpInterceptor</h3><p>重试、重定向拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">var</span> request = chain.request()</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      transmitter.prepareToConnect(request)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行正常请求</span></span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="literal">null</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, transmitter, <span class="literal">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">val</span> requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// The network call threw an exception. Release any resources.</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用priorResponse新建Response并将Body设为空</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = response.exchange</span><br><span class="line">      <span class="keyword">val</span> route = exchange?.connection()?.route()</span><br><span class="line">      <span class="comment">// 重试</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, route)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange?.detachWithViolence()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重试次数</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      <span class="comment">// 将重试Response添加priorResponse</span></span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先正常进行请求，如果请求成功则在<code>finally</code>中释放资源，然后返回Response。如果遇到不可修复的异常则抛出异常并跳出循环，否则使用<code>followUpRequest()</code>进行重试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-开始使用&quot;&gt;&lt;a href=&quot;#1-开始使用&quot; class=&quot;headerlink&quot; title=&quot;1. 开始使用&quot;&gt;&lt;/a&gt;1. 开始使用&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;build.gradle&lt;/code&gt;中添加依赖：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="OkHttp" scheme="https://blog.xusheng.online/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>通过Git自动更新Android编译版本号</title>
    <link href="https://blog.xusheng.online/2019/07/04/%E9%80%9A%E8%BF%87Git%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Android%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>https://blog.xusheng.online/2019/07/04/%E9%80%9A%E8%BF%87Git%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Android%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E5%8F%B7/</id>
    <published>2019-07-04T09:21:02.000Z</published>
    <updated>2020-09-13T12:40:43.736Z</updated>
    
    <content type="html"><![CDATA[<p>我们公司的Android打包是通过使用Jenkins，然后Jenkins将打包好的App发布到下载服务器供测试同学进行测试。虽然Jenkins上可以通过使用脚本来指定对应的版本号和版本名称，但是这种方式并不优雅。</p><p>本文试图提供一种更优雅的方式来管理应用版本的方法。</p><h3 id="1-Android应用版本"><a href="#1-Android应用版本" class="headerlink" title="1.  Android应用版本"></a>1.  Android应用版本</h3><p>我们都知道Android应用的版本是通过指定AndroidManifest.xml文件属性来完成的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.zzt8888.construction.assistant&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">&quot;1.0.0&quot;</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>versionCode</code>：版本号，用作内部版本号。此数字仅用于确定某个版本是否比另一个版本更新：数字越大，则版本越新。</li><li><code>versionName</code>：一个字符串，用作向用户显示的版本号。</li></ul><p>要为应用定义版本信息，需要在 Gradle 构建文件中为版本设置设定相应的值。这些值随后会在构建流程中合并到应用的AndroidManifest.xml中。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.app&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">        targetSdkVersion <span class="number">29</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-VersionName"><a href="#2-VersionName" class="headerlink" title="2. VersionName"></a>2. VersionName</h3><p>通常在我们发布应用的时候都会打一个tag，这个tag也就是应用的版本名。</p><p>git通过<code>git describe --tags</code>可以获取到最新的tag信息，类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_2.3-35-g123123</span><br></pre></td></tr></table></figure><p>其中<code>v_2.3</code>是tag的名字，<code>35</code>是tag后提交的次数，<code>123123</code>是最新提交的id。</p><p>在<code>build.gradle</code>中使用<code>git describe --tags</code>来自动更新版本名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> def _versionName() &#123;</span><br><span class="line">    def cmd &#x3D; &#39;git describe --tags&#39;</span><br><span class="line">    def version &#x3D; cmd.execute().text.trim()</span><br><span class="line">    def pattern &#x3D; &quot;-(\\d+)-g&quot;</span><br><span class="line">    def matcher &#x3D; version &#x3D;~ pattern</span><br><span class="line">    if (matcher) &#123;</span><br><span class="line">        version &#x3D; version.substring(0, matcher.start()) + &quot;-&quot; + matcher[0][1]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        version &#x3D; version + &quot;-0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-VersionCode"><a href="#3-VersionCode" class="headerlink" title="3. VersionCode"></a>3. VersionCode</h3><p>一般来说，我们的往 Git 库中提交的 Commit 的数量应该是逐渐增加的。这样我们就可以使用git的Commit次数作为VersionCode。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> _versionCode() &#123;</span><br><span class="line">    <span class="keyword">def</span> cmd = <span class="string">&#x27;git rev-list HEAD --first-parent --count&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.execute().text.trim().toInteger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们Jenkins上是每编译一次，版本号就加一。个人很不合理的，如果是相同的代码，发布出去版本号应该保持一致，而不在于你编译多少次。</p><p>另外，VersionCode是一个32位的int类型，最大值是2147483647，使用commit次数并不会导致过大。</p><h4 id="4-优化build-gradle"><a href="#4-优化build-gradle" class="headerlink" title="4. 优化build.gradle"></a>4. 优化build.gradle</h4><p>尽可能减少 gradle 脚本的运算，提高编译速度，我们可以把这样的自动版本的计算放到 release 编译中去。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> _versionCode() &#123;</span><br><span class="line">    <span class="keyword">def</span> cmd = <span class="string">&#x27;git rev-list HEAD --first-parent --count&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> cmd.execute().text.trim().toInteger()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> _versionName() &#123;</span><br><span class="line">    <span class="keyword">def</span> cmd = <span class="string">&#x27;git describe --tags&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> version = cmd.execute().text.trim()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> pattern = <span class="string">&quot;-(\\d+)-g&quot;</span></span><br><span class="line">    <span class="keyword">def</span> matcher = version =~ pattern</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matcher) &#123;</span><br><span class="line">        version = version.substring(<span class="number">0</span>, matcher.start()) + <span class="string">&quot;-&quot;</span> + matcher[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        version = version + <span class="string">&quot;-0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.test&quot;</span></span><br><span class="line">        versionCode <span class="number">999999</span></span><br><span class="line">        versionName <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        <span class="comment">// 只在release的时候才使用自动版本号</span></span><br><span class="line">        <span class="keyword">if</span> (variant.buildType.name == <span class="string">&quot;release&quot;</span>) &#123;</span><br><span class="line">            variant.outputs.all &#123; output -&gt;</span><br><span class="line">                <span class="keyword">def</span> date = <span class="keyword">new</span> Date().format(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>, TimeZone.getTimeZone(<span class="string">&quot;GMT+08&quot;</span>))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (variant.buildType.name == <span class="string">&#x27;release&#x27;</span>) &#123;</span><br><span class="line">                    output.versionCodeOverride = _versionCode()</span><br><span class="line">                    output.versionNameOverride = _versionName()</span><br><span class="line">                    <span class="comment">// 输出文件名</span></span><br><span class="line">                    outputFileName = <span class="string">&quot;xiaozhu_release_$&#123;date&#125;_$&#123;_versionName()&#125;_$&#123;_versionCode()&#125;.apk&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们公司的Android打包是通过使用Jenkins，然后Jenkins将打包好的App发布到下载服务器供测试同学进行测试。虽然Jenkins上可以通过使用脚本来指定对应的版本号和版本名称，但是这种方式并不优雅。&lt;/p&gt;
&lt;p&gt;本文试图提供一种更优雅的方式来管理应用版本的方
      
    
    </summary>
    
    
      <category term="日常记录" scheme="https://blog.xusheng.online/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="https://blog.xusheng.online/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2源码解析-线程切换</title>
    <link href="https://blog.xusheng.online/2019/05/20/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <id>https://blog.xusheng.online/2019/05/20/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</id>
    <published>2019-05-20T09:32:10.000Z</published>
    <updated>2020-09-13T12:40:43.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">thread(name = <span class="string">&quot;subscribe thread&quot;</span>, start = <span class="literal">true</span>) &#123;</span><br><span class="line">    Observable.create&lt;String&gt; &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;create: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        it.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        it.onComplete()</span><br><span class="line">    &#125;</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">object</span> : Observer&lt;String&gt; &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span></span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onComplete: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>)</span></span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onSubscribe: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(t: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onNext: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onError: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;MainActivity: onSubscribe: subscribe thread</span><br><span class="line">D&#x2F;MainActivity: create: RxCachedThreadScheduler-1</span><br><span class="line">D&#x2F;MainActivity: onNext: main</span><br><span class="line">D&#x2F;MainActivity: onComplete: main</span><br></pre></td></tr></table></figure><p>根据运行结果我们可以发现：</p><ol><li><code>onSubscribe()</code>发生在调用线程</li><li><code>subscribeOn()</code>决定了上游数据产生的线程</li><li><code>observeOn()</code>决定了下游数据订阅时的线程</li></ol><h3 id="2-obServeOn"><a href="#2-obServeOn" class="headerlink" title="2. obServeOn()"></a>2. obServeOn()</h3><p><code>observeOn()</code>用来指定观察者回调的线程，我们进入到这个方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">  &#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> observeOn(scheduler, delayError, bufferSize());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">      ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">      ObjectHelper.verifyPositive(bufferSize, <span class="string">&quot;bufferSize&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法执行后会返回一个<code>ObservableObserveOn</code>对象，进入到<code>ObservableObserveOn</code>的<code>subscribeActual()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 如果传入的是Schedulers.trampoline(), 不做线程切换</span></span><br><span class="line">          <span class="comment">// 我们传入的是AndroidSchedulers.mainThread()</span></span><br><span class="line">     <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">         source.subscribe(observer);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 通过传入的scheduler来创建一个Worker</span></span><br><span class="line">         Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">         <span class="comment">// 直接调用了上游ObservableSource的订阅方法</span></span><br><span class="line">         <span class="comment">// 因此observeOn不会影响到上游ObservableSource运行环境</span></span><br><span class="line">         source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为我们传入的是<code>AndroidSchedulers.mainThread()</code>，所以在这里<code>scheduler.createWorker()</code>创建的是一个<code>HandlerWorker(handler, async)</code>。这里先不去细说，先来看看Worker到底是干什么的。</p><p>进入到<code>ObserveOnObserver</code>中，来看看它的<code>onSubscribe()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SimpleQueue&lt;T&gt; queue;</span><br><span class="line">    Disposable upstream;</span><br><span class="line">    ...</span><br><span class="line">    ObserveOnObserver(Observer&lt;? <span class="keyword">super</span> T&gt; actual, Scheduler.Worker worker, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>.downstream = actual;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.upstream, d)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.upstream = d;</span><br><span class="line">            <span class="keyword">if</span> (d <span class="keyword">instanceof</span> QueueDisposable) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 创建一个单生产者单消费者的队列</span></span><br><span class="line">            queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line"><span class="comment">// 直接调用上游Observer的onSubscribe方法</span></span><br><span class="line">            downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在ObserveOnObserver的<code>onSubscribe</code>中直接调用了上游ObservableSource的<code>onSubscribe()</code>，这说明了<code>observeOn()</code>不会影响上游线程执行环境，也不会影响下游Observer的<code>onSubscribe()</code>回调的线程。</p><p>在看看ObserveOnObserver的<code>onNext()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在onCompete和onError中done被设置为了true</span></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是非异步操作, 将数据添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        queue.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ObserveOnObserver类间接继承了AtomicInteger</span></span><br><span class="line">    <span class="comment">// getAndIncrement()只有在第一次执行的时候才返回0，后面执行会自增</span></span><br><span class="line">    <span class="comment">// 所以worker.schedule(this)只会执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Worker.schedule(Runnable run)</code>方法直接调用了重载方法<code>schedule(Runnable run, long delay, TimeUnit unit)</code>，后面的两个参数为<code>0L, TimeUnit.NANOSECONDS</code>，这就意味着立刻马上执行<code>run()</code>。</p><p><strong>RxAndroid</strong></p><p>由于上面的<code>worker</code>是通过<code>AndroidSchedulers.mainThread()</code>创建的，所以这里就要看看RxAndroid这个库的代码了。RxANdroid总共就4个文件，其中两个文件比较重要：<code>HandlerScheduler</code>以及封装了该类的<code>AndroidSchedulers</code>。<br><code>AndroidSchedulers</code>提供了两个公有静态方法来切换线程：</p><ul><li><code>mainThread()</code>指定主线程</li><li><code>from(Looper looper)</code>指定别的线程</li></ul><p>这两者都是通过创建<code>HandlerScheduler</code>时指定<code>Handle</code>的<code>Looper</code>来实现的，<code>AndroidSchedulers</code>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public final class AndroidSchedulers &#123;</span><br><span class="line"></span><br><span class="line">    private static final class MainHolder &#123;</span><br><span class="line">        static final Scheduler DEFAULT</span><br><span class="line">            &#x3D; new HandlerScheduler(new Handler(Looper.getMainLooper()), false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final Scheduler MAIN_THREAD &#x3D; RxAndroidPlugins.initMainThreadScheduler(</span><br><span class="line">            new Callable&lt;Scheduler&gt;() &#123;</span><br><span class="line">                @Override public Scheduler call() throws Exception &#123;</span><br><span class="line">                    return MainHolder.DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    public static Scheduler mainThread() &#123;</span><br><span class="line">        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Scheduler from(Looper looper) &#123;</span><br><span class="line">        return from(looper, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    @SuppressLint(&quot;NewApi&quot;) &#x2F;&#x2F; Checking for an @hide API.</span><br><span class="line">    public static Scheduler from(Looper looper, boolean async) &#123;</span><br><span class="line">        if (looper &#x3D;&#x3D; null) throw new NullPointerException(&quot;looper &#x3D;&#x3D; null&quot;);</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; 16) &#123;</span><br><span class="line">            async &#x3D; false;</span><br><span class="line">        &#125; else if (async &amp;&amp; Build.VERSION.SDK_INT &lt; 22) &#123;</span><br><span class="line">            &#x2F;&#x2F; Confirm that the method is available on this API level despite being @hide.</span><br><span class="line">            Message message &#x3D; Message.obtain();</span><br><span class="line">            try &#123;</span><br><span class="line">                message.setAsynchronous(true);</span><br><span class="line">            &#125; catch (NoSuchMethodError e) &#123;</span><br><span class="line">                async &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            message.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        return new HandlerScheduler(new Handler(looper), async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AndroidSchedulers() &#123;</span><br><span class="line">        throw new AssertionError(&quot;No instances.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再说说另外一个关键文件<code>HandlerScheduler</code>，该类的作用就是将<code>Runnable</code>使用指定的<code>Handler</code>来执行。</p><p>该类的两个公共方法：<code>scheduleDirect()</code>方法直接执行<code>Runnable</code>；或者通过<code>createWorker()</code>创建一个<code>HandlerWorker</code>对象，稍后通过该对象的<code>schedule</code>方法执行<code>Runnable</code>。该文件比较简单，不做过多描述。</p><p>回到<code>ObserveOnObserver.schedule()</code>中，这里调用了<code>worker.schedule(this)</code>。说明已经通过<code>HandlerScheduler</code>回到了主线程。</p><p>ObserveOnObserver实现了Runnable接口，接着就看看它的<code>run()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断点查看的时候这里为false</span></span><br><span class="line">    <span class="comment">// 暂时不清楚这是来干嘛的😊</span></span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">        drainFused();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        drainNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来进入<code>drainNormal()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// queue在onSubscribe中创建，然后在onNext中添加了值</span></span><br><span class="line">         <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">         <span class="comment">// 下游的Observer</span></span><br><span class="line">         <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = downstream;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                 <span class="keyword">boolean</span> d = done;</span><br><span class="line">                 T v;</span><br><span class="line">        <span class="comment">// 从queue中取值</span></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     v = q.poll();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                     Exceptions.throwIfFatal(ex);</span><br><span class="line">                     disposed = <span class="keyword">true</span>;</span><br><span class="line">                     upstream.dispose();</span><br><span class="line">                     q.clear();</span><br><span class="line">                     a.onError(ex);</span><br><span class="line">                     worker.dispose();</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">        <span class="comment">// 将取到的值发射给下游Observer</span></span><br><span class="line">                 a.onNext(v);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             missed = addAndGet(-missed);</span><br><span class="line">             <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>所以这里的流程大致如下：</p><ol><li><code>ObservableObserveOn</code>将<code>Observer</code>包装成<code>ObserveOnObserver</code>，并调用了上游ObservableSource的<code>source.subscribe()</code>。(<code>observeOn</code>不会影响到上游ObservableSource运行环境）</li><li><code>ObserveOnObserver</code>在<code>onSubscribe()</code>被调用的时候创建了一个<code>SpscLinkedArrayQueue&lt;T&gt;(bufferSize)</code>队列并调用上游Observer的<code>onSubscribe()</code>方法(不会影响下游Observer的<code>onSubscribe()</code>回调的线程)。</li><li><code>ObserveOnObserver</code>将<code>onNext()</code>中接收到的值存入到队列中并开始切换线程。</li><li><code>ObserveOnObserver</code>在线程的<code>run()</code>中取出队列中的值，然后调用下游的<code>onNext()</code>、<code>onError()</code>。</li></ol><p>至此，<code>observeOn()</code>工作原理已经解释完毕。我们已经知道了<code>observeOn()</code>是如何决定了下游订阅发生的线程的：将Runnable抛给指定的线程池来执行，Runnable里面会调用下游observer的<code>onNext</code>方法。</p><h3 id="3-subscribeOn"><a href="#3-subscribeOn" class="headerlink" title="3. subscribeOn()"></a>3. subscribeOn()</h3><p><code>subscribeOn()</code>切换原理和<code>observeOn()</code>非常相似。</p><p>在<code>Observable.subscribeOn()</code>方法中，创建了一个<code>ObservableSubscribeOn</code>对象。</p><p>我们先进入到<code>subscribeActual()</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 将下游observer包装成为SubscribeOnObserver</span></span><br><span class="line">      <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line"><span class="comment">// 在Observable创建线程调用下游的onSubscribe方法</span></span><br><span class="line">      observer.onSubscribe(parent);</span><br><span class="line">      <span class="comment">// SubscribeTask是一个Runnable对象，其run方法为：source.subscribe(parent)</span></span><br><span class="line">      <span class="comment">// 调用scheduler.scheduleDirect开始执行Runnable</span></span><br><span class="line">      parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>和上面分析的<code>observeOn()</code>类似，<code>scheduler.scheduleDirect()</code>是一个线程切换的过程。</p><p>线程切换之后就会执行<code>source.subscribe(parent)</code>。就这样<code>subscribe()</code>会一直向上传递到数据发射的位置，发射数据的方法的线程自然也会发生改变。</p><p>我们先看看<code>scheduler.scheduleDirect()</code>干了什么，因为我们传入的是<code>Schedulers.io()</code>，<code>scheduleDirect()</code>调的是其基类<code>Scheduler</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="meta">@NonNull</span> Runnable run)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scheduleDirect(run, <span class="number">0L</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="meta">@NonNull</span> Runnable run, <span class="keyword">long</span> delay, <span class="meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line">    <span class="comment">// DisposeTask的run方法就是调用decoratedRun的run方法</span></span><br><span class="line">    DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</span><br><span class="line">    <span class="comment">// w是IoScheduler创建的EventLoopWorker</span></span><br><span class="line">    w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入<code>EventLoopWorker.schedule()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(<span class="meta">@NonNull</span> Runnable action, <span class="keyword">long</span> delayTime, <span class="meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks.isDisposed()) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>threadWorker</code>其实就是继承自<code>NewThreadWorker</code>，直接查看<code>NewThreadWorker.scheduleActual()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, <span class="meta">@NonNull</span> TimeUnit unit, <span class="meta">@Nullable</span> DisposableContainer parent)</span> </span>&#123;</span><br><span class="line">      Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"><span class="comment">// runnable</span></span><br><span class="line">      ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!parent.add(sr)) &#123;</span><br><span class="line">              <span class="keyword">return</span> sr;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Future&lt;?&gt; f;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 根据延时时间来执行ScheduledRunnable</span></span><br><span class="line">          <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">              f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">          &#125;</span><br><span class="line">          sr.setFuture(f);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">          <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">              parent.remove(sr);</span><br><span class="line">          &#125;</span><br><span class="line">          RxJavaPlugins.onError(ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个时候开始的<code>SubscribeTask</code>就会在指定的<code>Schedules.io()</code>线程池中运行了。</p><p><strong>为什么<code>subscribeOn()</code>只有第一次切换有效？</strong></p><p>因为RxJava订阅的时候是从下往上订阅，所以从上往下第一个<code>subscribeOn()</code>就是最后运行的。所以能影响<code>ObservableOnSubscribe</code>这个匿名实现接口的运行环境的只能是最后一次<code>subscribe()</code>操作(也就是调用链的第一次<code>subscribeOn()</code>)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-示例代码&quot;&gt;&lt;a href=&quot;#1-示例代码&quot; class=&quot;headerlink&quot; title=&quot;1. 示例代码&quot;&gt;&lt;/a&gt;1. 示例代码&lt;/h3&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="RxJava" scheme="https://blog.xusheng.online/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2源码解析-订阅流程</title>
    <link href="https://blog.xusheng.online/2019/04/18/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://blog.xusheng.online/2019/04/18/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B/</id>
    <published>2019-04-18T04:33:40.000Z</published>
    <updated>2020-09-13T12:40:43.730Z</updated>
    
    <content type="html"><![CDATA[<p>RxJava就是一种用Java语言实现的响应式编程，通过使用可观察的序列来组成异步和基于事件的程序。</p><p>本文基于代码基于<a href="https://github.com/ReactiveX/RxJava/releases/tag/v2.2.6">RxJava v2.2.6</a>和<a href="https://github.com/ReactiveX/RxAndroid/releases/tag/2.1.0">RxAndroid 2.1.0</a>，文中以<code>Observable</code>为例来进行分析。</p><h3 id="1-使用示例"><a href="#1-使用示例" class="headerlink" title="1. 使用示例"></a>1. 使用示例</h3><p><strong>在App的<code>build.gradle</code>中添加依赖：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;io.reactivex.rxjava2:rxjava:2.2.6&quot;</span></span><br><span class="line">implementation <span class="string">&#x27;io.reactivex.rxjava2:rxandroid:2.1.0&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>开始使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者者</span></span><br><span class="line">val observable = object : ObservableOnSubscribe&lt;String&gt; &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">subscribe</span><span class="params">(emitter: ObservableEmitter&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        emitter.onComplete()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map转换</span></span><br><span class="line">val mapFunc = object : Function&lt;String, Int&gt; &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">apply</span><span class="params">(t: String)</span>: Int </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.toInt() * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line">val observer = object : Observer&lt;Int&gt; &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onComplete: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override fun <span class="title">onSubscribe</span><span class="params">(d: Disposable)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onSubscribe: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override fun <span class="title">onNext</span><span class="params">(t: Int)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onNext: $t&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onError</span><span class="params">(e: Throwable)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onError: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line">Observable.create(observable).map(mapFunc).subscribe(observer)</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;MainActivity: onSubscribe: </span><br><span class="line">D&#x2F;MainActivity: onNext: 10</span><br><span class="line">D&#x2F;MainActivity: onComplete: </span><br></pre></td></tr></table></figure><h3 id="2-订阅流程分析"><a href="#2-订阅流程分析" class="headerlink" title="2. 订阅流程分析"></a>2. 订阅流程分析</h3><p>在分析源码之前，我们先理清这几个类有助于后面的分析：</p><ul><li><code>ObservableSource</code>：数据源，在订阅时会被<code>Observer</code>消耗。它是一个接口。</li><li><code>Observable</code>：<code>ObservableSource</code>的实现类。<code>Observable</code>是一个抽象类，它里面只有一个抽象方法<code>subscribeActual()</code>。它是<code>Observable.subscribe()</code>实际调用的方法。</li><li><code>Emitter</code>：用于发射数据</li></ul><p><code>Observer</code>：数据的接收者(观察者？)</p><p>下面根据例子来看看Rxjava是怎么处理数据的。</p><p><strong>Observable.create()</strong></p><p>先看看<code>Observable.create()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 检查传入的source是否为null</span></span><br><span class="line">    ObjectHelper.requireNonNull(source, <span class="string">&quot;source is null&quot;</span>);</span><br><span class="line">      <span class="comment">// 尝试使用RxJavaPlugins.onAssembly转换ObservableCreate</span></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RxJavaPlugins.onAssembly()</code>是一个hook方法，将传入的<code>Observable</code>对象转换为另一个<code>Observable</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(<span class="meta">@NonNull</span> Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; getOnObservableAssembly() &#123;</span><br><span class="line">    <span class="keyword">return</span> onObservableAssembly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Function&lt;? <span class="keyword">super</span> ConnectableObservable, ? extends ConnectableObservable&gt; getOnConnectableObservableAssembly() &#123;</span><br><span class="line">    <span class="keyword">return</span> onConnectableObservableAssembly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Observable</code>对象是否转换取决于<code>onObservableAssembly</code>是否为空。默认情况下，<code>onObservableAssembly</code>是空值，但是可以通过<code>RxJavaPlugins</code>的静态方法进行get/set。</p><p>由于<code>onObservableAssembly</code>为空所以<code>Observable.create(observable)</code>和<code>ObservableCreate(observable)</code>是相同的。</p><p>例子中的调用方式就可以变为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObservableCreate(observable).map(mapFunc).subscribe(observer)</span><br></pre></td></tr></table></figure><p><strong>map()</strong></p><p>下面进入到<code>map()</code>操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(mapper, <span class="string">&quot;mapper is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码与<code>create()</code>操作符类似，这里直接返回了一个<code>ObservableMap</code>对象。</p><p>再次把<code>ObservableMap</code>带入到调用中就变成这样了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObservableMap(ObservableCreate(observable), mapFunc).subscribe(observer)</span><br></pre></td></tr></table></figure><p>这里我们已经建立了两个<code>Observable</code>对象了，一个用于数据创建的<code>ObservableCreate</code>和一个用于数据转换的<code>ObservableMap</code>。这就是在订阅发生前数据的调流程了。</p><p><strong>每个操作符都会创建一个新的<code>Observable</code>实例，并将上一个<code>Observable</code>的实例作为参数传入到构造函数中。这就是为什么RxJava中的数据为什么会依次经过这些操作符的原因了。</strong></p><blockquote><p>操作符中创建的实例都是<code>Observable</code>的实现类，它们实现<code>subscribeActual()</code>抽象方法。</p></blockquote><p><strong>subscribe()</strong></p><p>接下来我们看看订阅发生后的流程。进入到<code>subscribe()</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, <span class="string">&quot;observer is null&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// onSubscribe也是一个hook方法，和onAssembly()类似</span></span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line">        <span class="comment">// 判断observer是否为null</span></span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">&quot;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 调用真正的订阅</span></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">           <span class="comment">// 直接捕获异常，不向外抛出</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="comment">// can&#x27;t call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">        <span class="comment">// can&#x27;t call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Actually not, but can&#x27;t throw other exceptions due to RS&quot;</span>);</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看上面<code>map</code>的流程我们就知道<code>subscribeActual()</code>现在执行的是<code>ObservableMap</code>中的方法。</p><p>我们看看<code>ObservableMap</code>中是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapObserver</code>是<code>Observer</code>的实现类。将<code>MapObserver</code>带入到订阅后的代码中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObservableCreate(observable).subscribe(ObservableMap.MapObserver(observer, mapFunc))</span><br></pre></td></tr></table></figure><p>接下来就看看<code>ObservableCreate</code>了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        <span class="comment">// observer回调onSubscribe，表示已经开始订阅</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们继续<code>CreateEmitter</code>将代入订阅流程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(ObservableCreate.CreateEmitter(ObservableMap.MapObserver(observer, mapFunc)))</span><br></pre></td></tr></table></figure><blockquote><p>这里执行的时候并没有出现<code>D/MainActivity: onSubscribe: </code>日志，从上面的代码可以看到<code>onSubscribe()</code>不是由<code>CreateEmitter</code>调用的。所以我们知道不管Observable如何切线程，<code>onSubscribe()</code>都是在调用线程中执行的。</p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>我们先基于实例代码来看看操作符和订阅是一步一步执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始调用</span><br><span class="line">Observable.create(observable).map(mapFunc).subscribe(observer)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;》将observable放入ObservableCreate中</span><br><span class="line">ObservableCreate(observable).map(mapFunc).subscribe(observer)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;》将ObservableCreate放入ObservableMap中</span><br><span class="line">ObservableMap(ObservableCreate(observable), mapFunc).subscribe(observer)</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;》 订阅开始</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;》 调用ObservableMap中的subscribeActual，将observer放入MapObserver中</span><br><span class="line">ObservableCreate(observable).subscribe(ObservableMap.MapObserver(observer, mapFunc))</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;》 调用ObservableCreate中的subscribeActual，将MapObserver放入CreateEmitter中</span><br><span class="line">observable.subscribe(ObservableCreate.CreateEmitter(ObservableMap.MapObserver(observer, mapFunc)))</span><br></pre></td></tr></table></figure><p>可以看出在执行<code>subscribe()</code>之前，链式调用一步步从前往后展开，将前面的前面的操作符都会作为参数传入后面的操作符中。</p><p>当执行``subscribe()`执行时，会从最后面的操作符开始订阅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RxJava就是一种用Java语言实现的响应式编程，通过使用可观察的序列来组成异步和基于事件的程序。&lt;/p&gt;
&lt;p&gt;本文基于代码基于&lt;a href=&quot;https://github.com/ReactiveX/RxJava/releases/tag/v2.2.6&quot;&gt;RxJav
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="RxJava" scheme="https://blog.xusheng.online/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit2 源码解析</title>
    <link href="https://blog.xusheng.online/2019/03/19/Retrofit2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.xusheng.online/2019/03/19/Retrofit2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2019-03-19T11:12:52.000Z</published>
    <updated>2020-09-13T12:40:43.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Retrofit2-源码解析"><a href="#Retrofit2-源码解析" class="headerlink" title="Retrofit2 源码解析"></a>Retrofit2 源码解析</h2><p>Retrofit是适用于Android和Java的类型安全的Http客户端，网络请求的工作本质是在OkHttp上完成，而Retrofit仅负责网络请求接口的封装。</p><p>本文代码基于<a href="https://github.com/square/retrofit/releases/tag/parent-2.8.0">Retrofit-2.8.0</a></p><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><ol><li><p>定义Http API接口信息</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">&quot;users/&#123;user&#125;/repos&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listRepos</span><span class="params">(<span class="meta">@Path(<span class="meta-string">&quot;user&quot;</span>)</span> user: <span class="type">String</span>?)</span></span>: Call&lt;ResponseBody&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用Retrofit生成<code>GithubService</code>的实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit: Retrofit = Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .build()</span><br><span class="line"><span class="keyword">val</span> service: GitHubService = retrofit.create(GitHubService::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure></li><li><p>通过<code>GithubService</code>的实现获取请求返回结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> call = service.listRepos(<span class="string">&quot;xshengcn&quot;</span>)</span><br><span class="line"><span class="comment">// val response  = call.execute() // 同步执行</span></span><br><span class="line"><span class="keyword">val</span> callback:Callback&lt;ResponseBody&gt;  = <span class="keyword">object</span> : Callback&lt;ResponseBody&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">ResponseBody</span>&gt;)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;Callback&quot;</span>, <span class="string">&quot;onResponse: <span class="variable">$call</span>, <span class="variable">$response</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">ResponseBody</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">call.enqueue(callback)</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h3><h4 id="2-1-Retrofit-build"><a href="#2-1-Retrofit-build" class="headerlink" title="2.1 Retrofit.build()"></a>2.1 Retrofit.build()</h4><p>我们先看看<code>Retrofit.Builder</code>在创建<code>Retrofit</code>时干了些什么。这里直接查看它的build方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> Retrofit build() &#123;</span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不传入base url就抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有传入自定义的OkHttpClient就创建一个新的</span></span><br><span class="line">    <span class="comment">// OkHttpClient实现了okhttp3.Call.Factory接口</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">    <span class="keyword">if</span> (callFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      callFactory = new OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有设置过callbackExecutor，且此处platform为Android</span></span><br><span class="line">        <span class="comment">// 因此这里被赋值为了MainThreadExecutor</span></span><br><span class="line">    Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">    <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">      callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设置的CallAdapter.Factory添加到集合中</span></span><br><span class="line">    <span class="comment">// 并添加根据不同平台添加默认的CallAdapter.Factory</span></span><br><span class="line">    <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">    callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设置的Converter.Factory添加到集合中</span></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">        new ArrayList&lt;&gt;(</span><br><span class="line">            <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">    <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">    <span class="comment">// 添加了一个内置的BuiltInConverters</span></span><br><span class="line">    converterFactories.add(new BuiltInConverters());</span><br><span class="line">    converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">    <span class="comment">// 并添加根据不同平台添加默认的Converter.Factory</span></span><br><span class="line">    converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new Retrofit(</span><br><span class="line">        callFactory,</span><br><span class="line">        baseUrl,</span><br><span class="line">        unmodifiableList(converterFactories),</span><br><span class="line">        unmodifiableList(callAdapterFactories),</span><br><span class="line">        callbackExecutor,</span><br><span class="line">        validateEagerly);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Retrofit</code>对象已经创建了，其构造器实现都是赋值语句。我们先简单介绍一下几个关键类吧：</p><ul><li><p><code>CallAdapter.Factory</code>：用于创建<code>CallAdapter</code>实例的工厂。</p></li><li><p><code>CallAdapter</code>：将一个Call从响应类型R适配成T类型的适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 将HTTP响应体转换为Java对象时，该对象的类型</span></span><br><span class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回一个代理了call的T</span></span><br><span class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</span><br><span class="line">    </span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Converter.Factory</code>：基于一个类型和目标类型创建一个<code>Converter</code>实例的工厂。</p></li><li><p><code>Converter</code> ：将F类型的值转换为T类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">  @Nullable</span><br><span class="line">  T convert(F value) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-Retrofit-create"><a href="#2-2-Retrofit-create" class="headerlink" title="2.2 Retrofit.create"></a>2.2 Retrofit.create</h4><p>   通过上面的使用步骤，可以看到是Retrofit通过create方法创建了一个具体的实例。直接查看create的源码：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 验证service接口信息</span></span><br><span class="line">validateServiceInterface(service); </span><br><span class="line"><span class="comment">// 通过动态代理返回service实例</span></span><br><span class="line"><span class="keyword">return</span> (T)</span><br><span class="line">    Proxy.newProxyInstance(</span><br><span class="line">        service.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">   </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是调用的Object中的方法，那就直接执行此方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过Platform.get()获取平台信息，这里是Android</span></span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加载service method</span></span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>   <code>InvocationHandler</code>接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。</p><p>   在InvocationHandler中，这里面最重要的就是<code>loadServiceMethod(method).invoke()</code>，通过Method信息获取的ServiceMethod后并调用invoke。</p><p><strong>loadServiceMethod</strong></p><p>那我们先看看``loadServiceMethod(method)`到底干了哪些事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  <span class="comment">// 如果serviceMethodCache中缓存了ServiceMethod直接返回</span></span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将service中的method解析为ServiceMethod</span></span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result); <span class="comment">// 加入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显的看出这里采取了缓存的设计，所以Retrofit使用单例时才能发挥最大的作用。</p><p>这段代码的重点就是<code>ServiceMethod.parseAnnotations(this, method)</code>。那么就继续进入到<code>ServiceMethod</code>。</p><p><strong>ServiceMethod</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Service接口中的方法转化为ServiceMethod</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析方法信息对应的请求信息</span></span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 获取方法的返回值类型</span></span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="comment">// 验证返回类型</span></span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">      <span class="comment">// 方法返回类型不得包含类型变量或通配符</span></span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>,</span><br><span class="line">          returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法返回类型不能是void</span></span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 使用HttpServiceMethod解析</span></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>ServiceMethod</code>是一个抽象类，<code>loadServiceMethod(method).invoke()</code>调用的就是它的抽象方法<code>invoke()</code>。</p></li><li><p>它在解析方法的时候先取出要调用方法的注解、参数以及参数注解等，生成对于的http请求信息。这里的方法太长，就贴了几个重要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.methodAnnotations = method.getAnnotations(); <span class="comment">// 获取方法的注解</span></span><br><span class="line">    <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes(); <span class="comment">// 获取方法的参数类型</span></span><br><span class="line">    <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations(); <span class="comment">// 获取方法的参数注解</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">      parseMethodAnnotation(annotation); <span class="comment">// 解析方法注解, 并判断注解的合法性(例如header是否为空等)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...一些判断</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析注解， 并为httpMethod(GET, POST等), hasBody等赋值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p><code>ServiceMethod</code>解析了部分信息后继续交由<code>HttpServiceMethod</code>来解析，并返回了<code>HttpServiceMethod&lt;ResponseT, ReturnT&gt;</code>。</p></li></ul><p><strong>HttpServiceMethod</strong></p><p><code>HttpServiceMethod</code>是<code>ServiceMethod</code>的子类，我们先来看看它的<code>parseAnnotations</code>是如何工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查接口方法上的注释，以构造使用HTTP的可重用服务方法。 这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Annotation[] annotations = method.getAnnotations(); <span class="comment">// 获取方法的注解</span></span><br><span class="line">  Type adapterType; <span class="comment">// 返回值类型 如Call&lt;Data&gt;或者Observable&lt;Data&gt;</span></span><br><span class="line"> ...</span><br><span class="line">    adapterType = method.getGenericReturnType();</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从传入大CallAdapter.Factory中查找匹配的CallAdapter，如RxJava2CallAdapter</span></span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">      createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">  <span class="comment">// CallAdapter返回的类型 ，如Data</span></span><br><span class="line">  Type responseType = callAdapter.responseType();</span><br><span class="line">  <span class="comment">// 不是有效的返回类型</span></span><br><span class="line">  <span class="keyword">if</span> (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        method,</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">            + getRawType(responseType).getName()</span><br><span class="line">            + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回类型必须包含通用类型（例如Response &lt;String&gt;）</span></span><br><span class="line">  <span class="keyword">if</span> (responseType == Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 从Converter.Factory中查找匹配的Converter，GsonResponseBodyConverter</span></span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">      createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们过滤掉处理协程的相关部分，发现这里做了这几部分工作：</p><ol><li>根据方法的返回值类型等信息从<code>Retrofit.Builder</code>中的<code>callAdapterFactories</code>获取<code>CallAdapter</code>。</li><li>获取到<code>CallAdapter</code>后根据它的<code>responseType()</code>得到的类型获取到对应的<code>Converter</code></li><li>用<code>Converter</code>和<code> callAdapter</code>等创建<code>CallAdapted</code></li></ol><p><strong>CallAdapted</strong></p><p><code>loadServiceMethod(method)</code>获取到ServiceMethod实例就是<code>CallAdapted</code>了，所以invoke调用的就是<code>CallAdapted.invoke()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    CallAdapted(</span><br><span class="line">        RequestFactory requestFactory,</span><br><span class="line">        okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它继承于HttpServiceMethod，而且并没有重写invoke方法。所以这里就是创建好一个<code>OkHttpCall</code>后并通过<code>callAdapter.adapt()</code>返回一个对象。</p><p>这里的CallAdapter是什么呢？我们在<code>Retrofit.build()</code>时添加了一个默认的<code>CallAdapter.Factory</code>，它就是<code>DefaultCallAdapterFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br></pre></td></tr></table></figure><p>我们进入到<code>DefaultCallAdapterFactory</code>查看它通过<code>get()</code>获取的是什么CallAdapter，并且通过<code>callAdapter.adapt(call)</code>返回是什么对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回类型必须通过Call包装，如Call&lt;Foo&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取返回类型 Foo</span></span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line">        <span class="comment">// 如果有SkipCallbackExecutor注解就是空否则是Retrofit#build时传入的</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor =</span><br><span class="line">        Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">            ? <span class="keyword">null</span></span><br><span class="line">            : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为Retrofit#build时并未添加executor，所以返回的是Call本身(OkHttpCall)</span></span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>loadServiceMethod(method).invoke(args != null ? args : emptyArgs)</code>返回的就是一个<code>OkHttpCall</code>对象。</p><p><strong>Call</strong></p><p>这时候Retrofit还没有进行网络请求，当执行<code>execute()</code>或者<code>enqueue()</code>才开始进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      ...</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        ...</span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        ...</span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    ...</span><br><span class="line">      call = rawCall;</span><br><span class="line">      ....</span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">    ...</span><br><span class="line">      T body = responseConverter.convert(catchingBody);</span><br><span class="line">      <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Call</code>在不管调用的是<code>enqueue</code>还是<code>execute</code>，都会创建一个<code>okhttp3.Call</code>，然后调用<code>okhttp3.Call</code>相应的方法。</p><p>在<code>okhttp3.Call</code>取得结果后就通过<code>Converter.Factory</code>创建的Converter解析生成接口的返回值。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ol><li>Retrofit使用了动态代理实现了我们定义的接口。</li><li>在实现接口方法时，Retrofit会通过<code>loadServiceMethod</code>为每一个接口方法构建了一个<code>ServiceMethod</code>对象，并会缓存到ConcurrentHashMap中。</li><li>在<code>ServiceMethod</code>构建时，会根据接口方法的注解类型、参数类型以及参数注解来拼接请求参数、确定请求类型、构建请求体等来确定使用哪个<code>CallAdapter</code>和<code>Converter</code>，并返回<code>CallAdapted</code>对象</li><li><code>ServiceMethod.invoke()</code>调用了<code>CallAdapter.adapt</code>，这里生成了<code>OkHttpCall</code>。当<code>Call</code>执行请求时也就是<code>OkHttpCall</code>在调用方法执行请求。</li><li><code>Call</code>在不管调用的是<code>enqueue</code>还是<code>execute</code>，都会创建一个<code>okhttp3.Call</code>，然后调用<code>okhttp3.Call</code>相应的方法</li><li>在<code>okhttp3.Call</code>取得结果后就通过<code>Converter.Factory</code>创建的Converter解析生成接口的返回值。</li></ol><p>这里并没有使用<code>RxJava2CallAdapterFactory</code>和<code>GsonConverterFactory</code>等，是最基础的Retrofit请求流程了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Retrofit2-源码解析&quot;&gt;&lt;a href=&quot;#Retrofit2-源码解析&quot; class=&quot;headerlink&quot; title=&quot;Retrofit2 源码解析&quot;&gt;&lt;/a&gt;Retrofit2 源码解析&lt;/h2&gt;&lt;p&gt;Retrofit是适用于Android和Ja
      
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.xusheng.online/categories/Android/"/>
    
    
      <category term="源码解析" scheme="https://blog.xusheng.online/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView的缓存机制</title>
    <link href="https://blog.xusheng.online/2019/02/12/RecyclerView%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.xusheng.online/2019/02/12/RecyclerView%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2019-02-12T00:19:15.000Z</published>
    <updated>2020-09-14T07:11:48.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Recycler"><a href="#1-Recycler" class="headerlink" title="1. Recycler"></a>1. Recycler</h3><p>同<code>ListView</code>里的<code>RecycleBin</code>缓存一样，<code>RecyclerView</code>中的缓存也由一个内部类<code>Recycler</code>进行管理。</p><p><code>Recycler</code>里面有四个不同层次的缓存，比<code>ListView</code>层次要更丰富，这与<code>RecyclerView</code>拓展性更好有一定的关系。</p><p><code>Recycler</code>里面主要字段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> ArrayList&lt;ViewHolder&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewHolder&gt;</span><br><span class="line">                mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mRequestedCacheMax = DEFAULT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">int</span> mViewCacheMax = DEFAULT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">        RecycledViewPool mRecyclerPool;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ViewCacheExtension mViewCacheExtension;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CACHE_SIZE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的字段作用如下：</p><ul><li><code>mAttachedScrap</code>、<code>mChangedScrap</code>：<strong>一级缓存</strong>，在layout发生前将屏幕上面的ViewHolder保存起来，供layout中进行复用</li><li><code>mCachedViews</code>：<strong>二级缓存</strong>，默认大小保持在<code>DEFAULT_CACHE_SIZE = 2</code>，可以通过<code>RecyclerView.setItemViewCacheSize(int)</code>方法进行设置 <code>mCachedViews</code>数量如果超出限制，会根据索引将里面旧的移动到<code>RecyclerViewPool</code>中</li><li><code>ViewCacheExtension</code>：<strong>三级缓存</strong>，开发者可以自定义的缓存</li><li><code>RecyclerViewPool</code>：<strong>四级缓存</strong>，可以在多个RecyclerView中共享缓存<br>根据ViewType来缓存ViewHolder，每个ViewType的数组大小默认为<code>DEFAULT_MAX_SCRAP = 5</code>，超过部分会丢弃，可以通过其<code>setMaxRecycledViews(int viewType, int max)</code>方法来控制对应type的缓存池大小。</li></ul><p><code>Recycler</code>的方法本质上就是对上面数据结构的一些操作。主要的方法有：</p><ul><li><code>recycleView(View)</code>：将view对应的ViewHolder移动到<code>mCachedViews</code>中；如果View是scrapped状态，会先unscrap</li><li><code>recycleViewHolderInternal(ViewHolder)</code>：将ViewHolder保存到<code>mCachedViews</code>中</li><li><code>addViewHolderToRecycledViewPool(ViewHolder, boolean)</code>：将ViewHolder保存到<code>RecycledViewPool</code>中</li><li><code>scrapView(View)</code>：将一个attached状态的View保存到<code>mAttachedScrap</code>或<code>mChangedScrap</code>中</li><li><code>getChangedScrapViewForPosition(int)</code>：从<code>mChangedScrap</code>中寻找匹配的ViewHolder</li><li><code>getScrapOrHiddenOrCachedHolderForPosition(int, boolean)</code>：依次从<code>mAttachedScrap</code>、<code>mCachedViews</code>中寻找匹配的ViewHolder</li><li><code>getScrapOrCachedViewForId(long, int, boolean)</code>：依次从<code>mAttachedScrap</code>、<code>mCachedViews</code>中寻找匹配的ViewHolder</li><li><code>tryGetViewHolderForPositionByDeadline(int, boolean, long)</code>：从<code>mChangedScrap</code>、<code>mAttachedScrap</code>、<code>mCachedViews</code>、<code>ViewCacheExtension</code>、<code>RecycledViewPool</code>中进行匹配；若匹配不了，最后会直接调用<code>Adapter.createViewHolder</code>方法进行创建</li><li><code>tryBindViewHolderByDeadline(ViewHolder, int, int, long)</code>：调用<code>Adapter.bindViewHolder</code>方法绑定View</li></ul><h3 id="2-缓存流程"><a href="#2-缓存流程" class="headerlink" title="2. 缓存流程"></a>2. 缓存流程</h3><p><code>RecyclerView</code>的缓存流程同ListView一样，也是体现在了layout过程中。</p><p><code>RecyclerView</code>的layout流程分为三个方法，对应layout step的三个步骤：</p><ol><li><p>State.STEP_START：<code>State.STEP_START</code>状态可以执行，执行完毕后状态变成<code>State.STEP_LAYOUT</code></p><ol><li>处理Adapter的更新，更新一些相关的值</li><li>决定应该执行哪个动画</li><li>保存当前View的动画信息</li><li>如果有必要，执行预测性的layout并保存View动画信息</li></ol></li><li><p>State.STEP_LAYOUT：<code>State.STEP_LAYOUT | State.STEP_ANIMATIONS</code>状态可以执行，执行完毕后状态变成<code>State.STEP_ANIMATIONS</code>。真正执行views的layout；如有必要，该步骤可能执行多次</p></li><li><p>State.STEP_ANIMATIONS：<code>State.STEP_ANIMATIONS | State.STEP_ANIMATIONS</code>状态可以执行，执行开始前状态变成<code>State.STEP_START</code>。执行第一步保存的View的动画信息</p></li></ol><p>我们关注的重点显然是在<code>dispatchLayoutStep2</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The second layout step where we do the actual layout of the views for the final state.</span></span><br><span class="line"><span class="comment">  * This step might be run multiple times if necessary (e.g. measure).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    eatRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line"></span><br><span class="line">    mState.mStructureChanged = <span class="keyword">false</span>;</span><br><span class="line">    mPendingSavedState = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check</span></span><br><span class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>;</span><br><span class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS;</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比较简单，重点在第15行的<code>mLayout.onLayoutChildren(mRecycler, mState)</code>方法中。这里mLayout我们选择最常用的<code>LinearLayoutManager</code>进行分析。<code>LinearLayoutManager.onLayoutChildren</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// layout algorithm:</span></span><br><span class="line">    <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></span><br><span class="line">    <span class="comment">//  item position.</span></span><br><span class="line">    <span class="comment">// 2) fill towards start, stacking from bottom</span></span><br><span class="line">    <span class="comment">// 3) fill towards end, stacking from top</span></span><br><span class="line">    <span class="comment">// 4) scroll to fulfill requirements like stack from bottom.</span></span><br><span class="line">    <span class="comment">// create layout state</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;is pre layout:&quot;</span> + state.isPreLayout());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> || mPendingScrollPosition != NO_POSITION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.getItemCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            removeAndRecycleAllViews(recycler);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPendingSavedState != <span class="keyword">null</span> &amp;&amp; mPendingSavedState.hasValidAnchor()) &#123;</span><br><span class="line">        mPendingScrollPosition = mPendingSavedState.mAnchorPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureLayoutState();</span><br><span class="line">    mLayoutState.mRecycle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// resolve layout direction</span></span><br><span class="line">    resolveShouldLayoutReverse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION</span><br><span class="line">            || mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">        <span class="comment">// calculate anchor position and coordinate</span></span><br><span class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">        mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; (mOrientationHelper.getDecoratedStart(focused)</span><br><span class="line">                    &gt;= mOrientationHelper.getEndAfterPadding()</span><br><span class="line">            || mOrientationHelper.getDecoratedEnd(focused)</span><br><span class="line">            &lt;= mOrientationHelper.getStartAfterPadding())) &#123;</span><br><span class="line">        <span class="comment">// This case relates to when the anchor child is the focused view and due to layout</span></span><br><span class="line">        <span class="comment">// shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows</span></span><br><span class="line">        <span class="comment">// up after tapping an EditText which shrinks RV causing the focused view (The tapped</span></span><br><span class="line">        <span class="comment">// EditText which is the anchor child) to get kicked out of the screen. Will update the</span></span><br><span class="line">        <span class="comment">// anchor coordinate in order to make sure that the focused view is laid out. Otherwise,</span></span><br><span class="line">        <span class="comment">// the available space in layoutState will be calculated as negative preventing the</span></span><br><span class="line">        <span class="comment">// focused view from being laid out in fill.</span></span><br><span class="line">        <span class="comment">// Note that we won&#x27;t update the anchor position between layout passes (refer to</span></span><br><span class="line">        <span class="comment">// TestResizingRelayoutWithAutoMeasure), which happens if we were to call</span></span><br><span class="line">        <span class="comment">// updateAnchorInfoForLayout for an anchor that&#x27;s not the focused view (e.g. a reference</span></span><br><span class="line">        <span class="comment">// child which can change between layout passes).</span></span><br><span class="line">        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Anchor info:&quot;</span> + mAnchorInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LLM may decide to layout items for &quot;extra&quot; pixels to account for scrolling target,</span></span><br><span class="line">    <span class="comment">// caching or predictive animations.</span></span><br><span class="line">    <span class="keyword">int</span> extraForStart;</span><br><span class="line">    <span class="keyword">int</span> extraForEnd;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> extra = getExtraLayoutSpace(state);</span><br><span class="line">    <span class="comment">// If the previous scroll delta was less than zero, the extra space should be laid out</span></span><br><span class="line">    <span class="comment">// at the start. Otherwise, it should be at the end.</span></span><br><span class="line">    <span class="keyword">if</span> (mLayoutState.mLastScrollDelta &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        extraForEnd = extra;</span><br><span class="line">        extraForStart = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extraForStart = extra;</span><br><span class="line">        extraForEnd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    extraForStart += mOrientationHelper.getStartAfterPadding();</span><br><span class="line">    extraForEnd += mOrientationHelper.getEndPadding();</span><br><span class="line">    <span class="keyword">if</span> (state.isPreLayout() &amp;&amp; mPendingScrollPosition != NO_POSITION</span><br><span class="line">            &amp;&amp; mPendingScrollPositionOffset != INVALID_OFFSET) &#123;</span><br><span class="line">        <span class="comment">// if the child is visible and we are going to move it around, we should layout</span></span><br><span class="line">        <span class="comment">// extra items in the opposite direction to make sure new items animate nicely</span></span><br><span class="line">        <span class="comment">// instead of just fading in</span></span><br><span class="line">        <span class="keyword">final</span> View existing = findViewByPosition(mPendingScrollPosition);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> current;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> upcomingOffset;</span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout) &#123;</span><br><span class="line">                current = mOrientationHelper.getEndAfterPadding()</span><br><span class="line">                        - mOrientationHelper.getDecoratedEnd(existing);</span><br><span class="line">                upcomingOffset = current - mPendingScrollPositionOffset;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = mOrientationHelper.getDecoratedStart(existing)</span><br><span class="line">                        - mOrientationHelper.getStartAfterPadding();</span><br><span class="line">                upcomingOffset = mPendingScrollPositionOffset - current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (upcomingOffset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                extraForStart += upcomingOffset;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extraForEnd -= upcomingOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> startOffset;</span><br><span class="line">    <span class="keyword">int</span> endOffset;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> firstLayoutDirection;</span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL</span><br><span class="line">                : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">                : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);</span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    mLayoutState.mInfinite = resolveIsInfinite();</span><br><span class="line">    mLayoutState.mIsPreLayout = state.isPreLayout();</span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForStart;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        startOffset = mLayoutState.mOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstElement = mLayoutState.mCurrentPosition;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForEnd += mLayoutState.mAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForEnd;</span><br><span class="line">        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        endOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">            extraForStart = mLayoutState.mAvailable;</span><br><span class="line">            updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">            mLayoutState.mExtra = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForEnd;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        endOffset = mLayoutState.mOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForStart += mLayoutState.mAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForStart;</span><br><span class="line">        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        startOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForEnd = mLayoutState.mAvailable;</span><br><span class="line">            <span class="comment">// start could not consume all it should. add more items towards end</span></span><br><span class="line">            updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">            mLayoutState.mExtra = extraForEnd;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// changes may cause gaps on the UI, try to fix them.</span></span><br><span class="line">    <span class="comment">// TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have</span></span><br><span class="line">    <span class="comment">// changed</span></span><br><span class="line">    <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// because layout from end may be changed by scroll to position</span></span><br><span class="line">        <span class="comment">// we re-calculate it.</span></span><br><span class="line">        <span class="comment">// find which side we should check for gaps.</span></span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout ^ mStackFromEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> fixOffset = fixLayoutEndGap(endOffset, recycler, state, <span class="keyword">true</span>);</span><br><span class="line">            startOffset += fixOffset;</span><br><span class="line">            endOffset += fixOffset;</span><br><span class="line">            fixOffset = fixLayoutStartGap(startOffset, recycler, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset += fixOffset;</span><br><span class="line">            endOffset += fixOffset;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> fixOffset = fixLayoutStartGap(startOffset, recycler, state, <span class="keyword">true</span>);</span><br><span class="line">            startOffset += fixOffset;</span><br><span class="line">            endOffset += fixOffset;</span><br><span class="line">            fixOffset = fixLayoutEndGap(endOffset, recycler, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset += fixOffset;</span><br><span class="line">            endOffset += fixOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">    <span class="keyword">if</span> (!state.isPreLayout()) &#123;</span><br><span class="line">        mOrientationHelper.onLayoutComplete();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAnchorInfo.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStackFromEnd = mStackFromEnd;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        validateChildOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很长，但还好有一些注释。</p><ol><li><p>首先，从开头到第112行都是第一步的内容：计算锚点坐标以及锚点item的position。谁让112行是<code>onAnchorReady</code>方法呢，太明显了。</p></li><li><p>注意第113行的<code>detachAndScrapAttachedViews</code>方法，该方法会对所有的子View调用<code>scrapOrRecycleView</code>方法。这样所有的子View都会暂时detach掉，并保存到<code>mAttachedScrap</code>或<code>mChangedScrap</code>或<code>mCachedViews</code>中，等待后续复用。</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Temporarily detach and scrap all currently attached child views. Views will be scrapped</span></span><br><span class="line"><span class="comment">    * into the given Recycler. The Recycler may prefer to reuse scrap views before</span></span><br><span class="line"><span class="comment">    * other views that were previously recycled.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> recycler Recycler to scrap views into</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachAndScrapAttachedViews</span><span class="params">(Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> View v = getChildAt(i);</span><br><span class="line">        scrapOrRecycleView(recycler, i, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scrapOrRecycleView</span><span class="params">(Recycler recycler, <span class="keyword">int</span> index, View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ViewHolder viewHolder = getChildViewHolderInt(view);</span><br><span class="line">    <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;ignoring view &quot;</span> + viewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">            &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123;</span><br><span class="line">        removeViewAt(index);</span><br><span class="line">        recycler.recycleViewHolderInternal(viewHolder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        detachViewAt(index);</span><br><span class="line">        recycler.scrapView(view);</span><br><span class="line">        mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   前面提到过<code>mCachedViews</code>如果空间不足，会根据索引将里面旧的移动到<code>RecyclerViewPool</code>中，这样此方法的就将除了<code>ViewCacheExtension</code>之外的缓存全部囊括了。</p><ol start="3"><li>根据计算的值，多次调用<code>fill</code>方法填充子View。<br>显然，<code>fill</code>方法是新重点。该方法和ListView中的<code>fillDown</code>等类似，也是循环计算-填充-计算，我们直接看填充部分。填充部分调用了<code>layoutChunk</code>方法：该方法会首先调用<code>LayoutState.next</code>方法获取一个view；然后会<code>addView</code>，add过程中如果是detach过的，将会view重新attach到RecyclerView上，否则就是remove过了的，直接addView；最后调用<code>measureChildWithMargins</code>、<code>layoutDecoratedWithMargins</code>方法对子View进行测量、布局。<code>layoutChunk</code>方法代码如下：</li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">        LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;received null view when unexpected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if we are laying out views in scrap, this may return null which means there is</span></span><br><span class="line">        <span class="comment">// no more items to layout.</span></span><br><span class="line">        result.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addDisappearingView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addDisappearingView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">    <span class="keyword">int</span> left, top, right, bottom;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLayoutRTL()) &#123;</span><br><span class="line">            right = getWidth() - getPaddingRight();</span><br><span class="line">            left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = getPaddingLeft();</span><br><span class="line">            right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            bottom = layoutState.mOffset;</span><br><span class="line">            top = layoutState.mOffset - result.mConsumed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            top = layoutState.mOffset;</span><br><span class="line">            bottom = layoutState.mOffset + result.mConsumed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        top = getPaddingTop();</span><br><span class="line">        bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            right = layoutState.mOffset;</span><br><span class="line">            left = layoutState.mOffset - result.mConsumed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = layoutState.mOffset;</span><br><span class="line">            right = layoutState.mOffset + result.mConsumed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We calculate everything with View&#x27;s bounding box (which includes decor and margins)</span></span><br><span class="line">    <span class="comment">// To calculate correct layout position, we subtract margins.</span></span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;laid out child at position &quot;</span> + getPosition(view) + <span class="string">&quot;, with l:&quot;</span></span><br><span class="line">                + (left + params.leftMargin) + <span class="string">&quot;, t:&quot;</span> + (top + params.topMargin) + <span class="string">&quot;, r:&quot;</span></span><br><span class="line">                + (right - params.rightMargin) + <span class="string">&quot;, b:&quot;</span> + (bottom - params.bottomMargin));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Consume the available space if the view is not removed OR changed</span></span><br><span class="line">    <span class="keyword">if</span> (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">        result.mIgnoreConsumed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.mFocusable = view.hasFocusable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   很显然，缓存部分的关键就是<code>LayoutState.next</code>方法了：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Gets the view for the next element that we should layout.</span></span><br><span class="line"><span class="comment">  * Also updates current item index to the next item, based on &#123;<span class="doctag">@link</span> #mItemDirection&#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> The next element that we should layout.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrapList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextViewFromScrapList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    mCurrentPosition += mItemDirection;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   我们先略过<code>mScrapList</code>，暂时认为其为null，后面遇到再分析。所以这里调用了<code>RecyclerView.getViewForPosition</code>方法：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   离真相又近了一步，<code>tryGetViewHolderForPositionByDeadline</code>方法里面会对各级缓存进行匹配，这里分段进行解释。</p><ol><li>如果有<code>mChangedScrap</code>，尝试进行匹配</li></ol><pre><code>  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 0) If there is a changed scrap, try to find from there&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mState.isPreLayout()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    holder = getChangedScrapViewForPosition(position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fromScrapOrHiddenOrCache = holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;  这里的  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;isPreLayout()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;  与  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mState.mRunPredictiveAnimations&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;  有直接关系，可以看成前者的值取决与后者，该值在  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatchLayoutStep1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;  过程中被更新；当Item发生了更新时，  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scrapView&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;  方法会将ViewHolder保存到  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mChangedScrap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;  中去。</code></pre><ol start="2"><li>尝试从<code>mAttachedScrap</code>、<code>mCachedViews</code>中寻找匹配的ViewHolder。找到之后会对ViewHolder做一些检查，如果不满足条件，且<code>dryRun</code>为false（实际上就是false），会将ViewHolder清除掉并保存到<code>mCachedViews</code>中。在向<code>mCachedViews</code>中添加缓存时，如果超过了允许的上限(即<code>mViewCacheMax</code>)，将会把旧的缓存移动到<code>RecycledViewPool</code>中。</li></ol><pre><code>  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1) Find by position from scrap/hidden list/cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!validateViewHolderForOffsetPosition(holder)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// recycle holder (and unscrap if relevant) since it can&amp;#x27;t be used&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!dryRun) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// we would like to recycle this but need to make sure it is not used by&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// animation logic etc.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                holder.addFlags(ViewHolder.FLAG_INVALID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder.isScrap()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    removeDetachedView(holder.itemView, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    holder.unScrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder.wasReturnedFromScrap()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    holder.clearReturnedFromScrapFlag();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                recycleViewHolderInternal(holder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            holder = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fromScrapOrHiddenOrCache = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre><ol start="3"><li>如果<code>Adapter.hasStableIds()</code>为true，会根据ItemId和ViewType在<code>mAttachedScrap</code>、<code>mCachedViews</code>中寻找ViewHolder。<code>Adapter</code>中该属性默认为false。</li></ol><pre><code>  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2) Find from scrap/cache via stable ids, if exists&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mAdapter.hasStableIds()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            type, dryRun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// update position&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        holder.mPosition = offsetPosition;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fromScrapOrHiddenOrCache = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre><ol start="4"><li>如果存在<code>ViewCacheExtension</code>，调用<code>ViewCacheExtension.getViewForPositionAndType</code>寻找ViewHolder</li></ol><pre><code>  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; mViewCacheExtension != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// We are NOT sending the offsetPosition because LayoutManager does not&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// know it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; View view = mViewCacheExtension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .getViewForPositionAndType(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, position, type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (view != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        holder = getChildViewHolder(view);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&amp;quot;getViewForPositionAndType returned&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    + &lt;span class=&quot;string&quot;&gt;&amp;quot; a view which does not have a ViewHolder&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    + exceptionLabel());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder.shouldIgnore()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&amp;quot;getViewForPositionAndType returned&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    + &lt;span class=&quot;string&quot;&gt;&amp;quot; a view that is ignored. You must call stopIgnoring before&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    + &lt;span class=&quot;string&quot;&gt;&amp;quot; returning this view.&amp;quot;&lt;/span&gt; + exceptionLabel());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre><ol start="5"><li><p>fallback到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RecycledViewPool</span><br></pre></td></tr></table></figure><p>，看是否有可用的ViewHolder</p></li></ol><pre><code>  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// fallback to pool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (DEBUG) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&amp;quot;tryGetViewHolderForPositionByDeadline(&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                + position + &lt;span class=&quot;string&quot;&gt;&amp;quot;) fetching from shared pool&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    holder = getRecycledViewPool().getRecycledView(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        holder.resetInternal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (FORCE_INVALIDATE_DISPLAY_LIST) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invalidateDisplayListInt(holder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre><ol start="6"><li><p>以上都不满足，最后调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Adapter.createViewHolder</span><br></pre></td></tr></table></figure><p>创建ViewHolder</p></li></ol><pre><code>  &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start = getNanoTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (deadlineNs != FOREVER_NS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;amp;&amp;amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// abort - we have a deadline we can&amp;#x27;t meet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    holder = mAdapter.createViewHolder(RecyclerView.&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ALLOW_THREAD_GAP_WORK) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// only bother finding nested RV if prefetching&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RecyclerView innerView = findNestedRecyclerView(holder.itemView);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (innerView != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            holder.mNestedRecyclerView = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(innerView);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; end = getNanoTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mRecyclerPool.factorInCreateTime(type, end - start);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (DEBUG) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&amp;quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre><p>   在获取到ViewHolder之后，如果需要bind，会调用<code>tryBindViewHolderByDeadline</code>方法，该方法中接着调用<code>Adapter.bindViewHolder</code>方法交给开发者完成绑定工作。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">    <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">    holder.mPreLayoutPosition = position;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Removed holder should be bound and it should&quot;</span></span><br><span class="line">                + <span class="string">&quot; come here only in pre-layout. Holder: &quot;</span> + holder</span><br><span class="line">                + exceptionLabel());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">    bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>tryGetViewHolderForPositionByDeadline</code>方法完成之后会一直返回到<code>LinearLayoutManager.layoutChunk</code>方法中，接着会根据ViewHolder的来源，该attach的attach，该addView的addView，最后measure并layout，一个子View的layout过程就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Recycler&quot;&gt;&lt;a href=&quot;#1-Recycler&quot; class=&quot;headerlink&quot; title=&quot;1. Recycler&quot;&gt;&lt;/a&gt;1. Recycler&lt;/h3&gt;&lt;p&gt;同&lt;code&gt;ListView&lt;/code&gt;里的&lt;code&gt;Recycl
      
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.xusheng.online/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="https://blog.xusheng.online/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>探索Android布局优化</title>
    <link href="https://blog.xusheng.online/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.xusheng.online/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</id>
    <published>2019-01-28T07:47:04.000Z</published>
    <updated>2020-09-13T12:40:43.732Z</updated>
    
    <content type="html"><![CDATA[<p>布局是 Android 应用中直接影响用户体验的关键部分。不合理的布局会导致应用界面运行缓慢甚至会占用大量的内存。</p><h3 id="1-优化方案"><a href="#1-优化方案" class="headerlink" title="1. 优化方案"></a>1. 优化方案</h3><h4 id="1-1-优化布局层次结构"><a href="#1-1-优化布局层次结构" class="headerlink" title="1.1 优化布局层次结构"></a>1.1 优化布局层次结构</h4><p>首先我们应当删除布局中无用的控件。无用的控件不仅占用了inflate的时间，还增加的程序的内存。</p><p>优化视图的层级，例如使用嵌套的 <code>LinearLayout</code> 实例会导致视图层次结构过深。<code>LayoutInflater.inflate()</code>在加载布局的时候会根据布局的层级递归调用<code>rInflate()</code>，这就导致内存占用增加。</p><p>选择性能较高的<code>ViewGroup</code>，例如布局中既可以使用<code>LinearLayout</code>也可以使用<code>RelativeLayout</code>，那么就采用<code>LinearLayout</code>。这是因为<code>RelativeLayout</code>的功能比<code>LinearLayout</code>更加复杂，它的布局过程需要话费更多的CPU时间。</p><p>合理使用<code>LinearLayout</code>的<code>layout_weight</code> 参数，因为每个它子View都需要测量两次。如果是在<code>RecycleView</code>或者<code>ListView</code>中使用时，需要特别注意。</p><h4 id="1-2-布局复用"><a href="#1-2-布局复用" class="headerlink" title="1.2 布局复用"></a>1.2 布局复用</h4><p>布局的复用主要是通过<code>&lt;include/&gt;</code> 和 <code>&lt;merge/&gt;</code>来实现的。<code>&lt;incloud&gt;</code>虽然不会提升界面的性能(如果没有和<code>&lt;merge&gt;</code>一起使用甚至会增加视图的层级)，但是因为它的可重复使用为我们的开发带来了极大的便利。</p><p><code>&lt;incloud&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/app_bg&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center_horizontal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/common_progress_bar&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">&quot;@string/hello&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<code>&lt;incloud&gt;</code>时除了可以为布局添加<code>android:id</code>外还可以修改任何 <code>android:layout_</code>属性，不过必须同时替换 <code>android:layout_height</code> 和 <code>android:layout_width</code> 才能让其他布局属性生效。</p></blockquote><h4 id="1-3-按需加载布局"><a href="#1-3-按需加载布局" class="headerlink" title="1.3 按需加载布局"></a>1.3 按需加载布局</h4><p><code>&lt;ViewStub&gt;</code>提供了按需加载的功能，当需要时才会将<code>ViewStub</code>中的布局加载到内存，这样提高了程序的初始化效率。</p><p><code>ViewStub</code>继承至<code>View</code>，它非常轻量级且宽高都为0，因此它本身不参与任何的布局和绘制过程。比如我们需要先从网络请求数据，然后再加载到布局中。这时候我们可以先加载<code>&lt;ProgressBar&gt;</code>，等数据加载到本地和后通过<code>&lt;ViewStub&gt;</code>显示数据内容。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/common_loading_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/loadingView&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/stubView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/contentView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">&quot;@layout/content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等到需要使用ViewStub时可以按照如下方式进行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> view = contentView.inflate()</span><br><span class="line">   view.contentTv.text = remoteData</span><br></pre></td></tr></table></figure><p>一旦<code>ViewStub</code>调用<code>inflate(</code>后，<code>ViewStub</code>会被替换掉，此时<code>ViewStub</code>不再是整个布局结构的一部分了。此外，<code>ViewStub</code>还不 支持<code>merge</code>标签。</p><h4 id="1-4-绘制优化"><a href="#1-4-绘制优化" class="headerlink" title="1.4 绘制优化"></a>1.4 绘制优化</h4><p>绘制优化的分为是避免过度绘和<code>View#onDraw()</code>优化。</p><p>采取以下几种策略来减少甚至消除过度绘制：</p><ul><li><p>移除布局中不必要的背景</p></li><li><p>减少视图层级</p></li><li><p>降低透明度</p></li></ul><p>开发者模式中的一些设置可以在我们进行过渡绘制优化时提供很大的帮助，下节工具中会提到。</p><p><code>View#onDraw()</code>方法优化：</p><ul><li><code>onDraw()</code>不要创建新的局部对象，比如我们定义<code>Paint</code>的时候就不能在<code>onDraw()</code>中定义。</li><li>优化<code>onDraw()</code>的执行时间。View的绘制帧率保证60fps，即每帧的绘制时间不超过16ms（16ms = 1000/60）。</li></ul><h3 id="2-布局调优工具"><a href="#2-布局调优工具" class="headerlink" title="2. 布局调优工具"></a>2. 布局调优工具</h3><h4 id="2-1-Layout-Inspector"><a href="#2-1-Layout-Inspector" class="headerlink" title="2.1 Layout Inspector"></a>2.1 Layout Inspector</h4><p>Layout Inspector可以帮我们了解布局的层级结构，用来优化布局的合理性。</p><p>当我们的程序运行在模拟器或者真机上时，可以从<strong>Tools &gt; Android &gt; Layout Inspector</strong>打开Layout Inspector验证应用的布局。</p><p>使用方法参考<a href="https://developer.android.com/studio/debug/layout-inspector">使用布局检查器和布局验证工具调试布局</a>。</p><h4 id="2-2-Debug-GPU-overdraw"><a href="#2-2-Debug-GPU-overdraw" class="headerlink" title="2.2 Debug GPU overdraw"></a>2.2 Debug GPU overdraw</h4><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/debug_gpu_overdraw.jpeg" class="" title="debug_gpu_overdraw"><p>当应用在同一帧中多次绘制同一像素的时候，便会发生过度绘制。</p><p>Android 通过颜色来确定过度绘制的次数：</p><ul><li><strong>默认颜色</strong>：没有过度绘制</li><li><strong>蓝色</strong>：1次</li><li><strong>绿色</strong>：2次</li><li><strong>粉色</strong>：3次</li><li><strong>红色</strong>：4次及以上</li></ul><p>一下是Android默认设置过度绘制查看结果：</p><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/overdraw_settings.jpeg" class="" title="overdraw_settings"><blockquote><p>有些时候过度绘制是不可避免的(系统应用都有😭)，我们在优化过度绘制的时候应尽量尝试达到大部分显示默认颜色或仅有 1 次过度绘制（蓝色）的视觉效果。</p></blockquote><h4 id="2-3-Profile-GPU-Rendering"><a href="#2-3-Profile-GPU-Rendering" class="headerlink" title="2.3  Profile GPU Rendering"></a>2.3  Profile GPU Rendering</h4><p>Profile GPU Rendering工具可以显示前一帧所用的相对时间。</p><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/gpu_rendering.jpeg" class="" title="gpu_rendering"> <img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/rendering_settings.jpeg" class="" title="rendering_settings"><p>GPU 渲染模式分析工具以图表的形式显示各个阶段及其相对时间。</p><p>GPU 渲染模式分析图表中显示的每个竖条中的每个分段都表示流水线的一个阶段，并在条形图中使用特定的颜色突出显示。下表统计了渲染阶段对应的颜色及发生的原因（参考<a href="https://developer.android.com/topic/performance/rendering/profile-gpu#psb">使用 GPU 渲染模式分析工具进行分析</a>）：</p><table><thead><tr><th>颜色</th><th>渲染阶段</th><th>说明</th><th>产生原因</th></tr></thead><tbody><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032137188.png" class="" title="image-20200912032137188"></td><td>其它</td><td>除了渲染系统执行其工作所用的时间外的时间。</td><td>用可能包含应在其他线程上执行的回调、Intent 或其他工作。通过<strong>方法跟</strong>踪或<strong>Systrace</strong> 等工具可以查看主线程上运行的任务。</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032158944.png" class="" title="image-20200912032158944"></td><td>输入处理</td><td>表示应用执行输入 Event 回调中的代码所花的时间。</td><td>通常是由于输入处理程序事件回调中的<strong>工作过多或过复杂</strong>导致的。 由于这些回调总是发生在主线程上，因此该问题的解决方法主要是直接优化工作，或者将工作转移到其他线程。</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032211251.png" class="" title="image-20200912032211251"></td><td>动画</td><td>显示的是评估在该帧中运行的所有 Animator 所用的时间。</td><td>通常是因动画的某种属性更改而执行的工作。</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032233543.png" class="" title="image-20200912032233543"></td><td>测量/布局</td><td>视图层次结构中的 测量 和 布局 回调上所花的时间</td><td>通常是由于<strong>需要布局的视图数量过多</strong>，或者出现了其他问题（例如在层次结构的错误位置发生了 <a href="https://developer.android.com/topic/performance/optimizing-view-hierarchies#double">Double Taxation</a> 等）。在这两种情况下，要解决性能问题，都需要改善视图层次结构的性能。</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032301341.png" class="" title="image-20200912032301341"></td><td>绘制</td><td>用于创建和更新视图显示列表的时间。</td><td>如果竖条的此部分很高，则表明这里可能有许多自定义视图绘制，或 onDraw 函数执行的工作很多。</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032316738.png" class="" title="image-20200912032316738"></td><td>同步/上传</td><td>当前帧中将位图对象从 CPU 内存传输到 GPU 内存所需的时间</td><td>帧的所有资源都必须位于 GPU 内存中才能用来绘制帧。这意味着，该指标的值较高可能表示需要加载大量小型资源或少量大型资源</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032326952.png" class="" title="image-20200912032326952"></td><td>发出命令</td><td>是发出将显示列表绘制到屏幕上所需的全部命令所需的时间</td><td>此阶段花费的时间直接反映了系统在给定帧中渲染的显示列表的复杂程度和数量</td></tr><tr><td><img src="/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/image-20200912032342418.png" class="" title="image-20200912032342418"></td><td>处理/交换缓冲区</td><td>表示 CPU 等待 GPU 完成其工作的时间</td><td>如果此竖条升高，则表示应用在 GPU 上执行太多工作。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;布局是 Android 应用中直接影响用户体验的关键部分。不合理的布局会导致应用界面运行缓慢甚至会占用大量的内存。&lt;/p&gt;
&lt;h3 id=&quot;1-优化方案&quot;&gt;&lt;a href=&quot;#1-优化方案&quot; class=&quot;headerlink&quot; title=&quot;1. 优化方案&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.xusheng.online/categories/Android/"/>
    
    
      <category term="性能优化" scheme="https://blog.xusheng.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android中的线程和线程池</title>
    <link href="https://blog.xusheng.online/2019/01/09/Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://blog.xusheng.online/2019/01/09/Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2019-01-09T12:02:21.000Z</published>
    <updated>2020-09-14T06:43:34.922Z</updated>
    
    <content type="html"><![CDATA[<p>在Android应用启动的时候，系统会为该应用创建一个”main”线程。这个线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理，因此又被叫作UI线程。</p><p>如果应用执行比较耗时的操作就会阻塞住整个UI现场，所以这种单线程模式可能会导致性能低下。一旦UI线程被阻塞，线程将无法分派任何事件，此时应用会显示为挂起状态。如果UI线程被阻塞超过几秒钟时间（ 5 秒），就可能会出现“ANR”对话框。</p><p>此外Android中的UI组件并不是线程安全的，不能通过非UI线程访问UI组件。所以在进行多线程编程时有两大原则：</p><ol><li>不要阻塞 UI 线程</li><li>不要在UI线程外访问UI组件</li></ol><p>Android中的线程除了传统的<code>Thread</code>外，还包含<code>AsyncTask</code>、<code>HandlerThread</code>、<code>IntentService</code>等。</p><p>本文源代码基于<a href="https://developer.android.com/about/versions/oreo/android-8.1?hl=zh-cn">Android 8.1</a>。</p><h3 id="1-AsyncTask"><a href="#1-AsyncTask" class="headerlink" title="1. AsyncTask"></a>1. AsyncTask</h3><p>AsyncTask是一种轻量级的异步执行任务类，它可以在线程中执行后台任务，然后将结果返回到UI线程。</p><p>AsyncTask是一个抽象类，它有三个泛型参数。Params表示传入参数类型，Progress表示后台任务执行进度的类型，Result表示后台任务的返回结果的类型。如果AsyncTask不需要传递具体的参数，可以使用Void代替。</p><p>AsyncTask有4个核心方法，它们的含义如下所示：</p><ul><li><code>onPreExecute()</code>：在异步任务执行之前调用，运行在主线程。一般用来做一些准备工作。</li><li><code>doInBackground(vararg Params)</code>：用于执行异步任务，运行在工作线程。可以使用<code>publishProgress(vararg Progress)</code>来更新任务进度。</li><li><code>onProgressUpdate(vararg Progress)</code>：当任务进度发生改变时被调用，运行在主线程。</li><li><code>onPostExecute(Result)</code>：异步任务完成后被调用，运行在主线程。</li></ul><p>下面我们就来定义一个用于下载文件的AsyncTask：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">String, Float, Void</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreExecute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPreExecute()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> params: <span class="type">String</span>?)</span></span>: <span class="built_in">Void</span>? &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> params.indices) &#123;</span><br><span class="line">            repository.downloadFile(params[i])</span><br><span class="line">            publishProgress((i * <span class="number">1f</span>) / params.size)</span><br><span class="line">            <span class="keyword">if</span> (isCancelled) <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressUpdate</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">Float</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onProgressUpdate(*values)</span><br><span class="line">        updateProgress(values)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostExecute</span><span class="params">(result: <span class="type">Void</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPostExecute(result)</span><br><span class="line">        showDownloadSuccessDialog()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCancelled</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCancelled()</span><br><span class="line">        showCancelDialog()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行异步任务的方法也很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DownloadTask().execute(<span class="string">&quot;url1&quot;</span>, <span class="string">&quot;url2&quot;</span>, <span class="string">&quot;url3&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>AsyncTask的工作原理</strong></p><p>下面我们就来看看AsyncTask是怎么工作的，先从它的<code>execute()</code>开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                        + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params; <span class="comment">// 将传入的参数赋值给mWorker</span></span><br><span class="line">    exec.execute(mFuture); <span class="comment">// 执行任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到**<code>execute()</code>的执行线程必须是主线程**。<code>execute()</code>执行时调用了<code>executeOnExecutor()</code>，并传入了默认的<code>sDefaultExecutor</code>。</p><p>在<code>executeOnExecutor</code>判断了当前的状态，这里需要注意<strong>一个AsyncTask只能执行一次</strong>。</p><p><code>executeOnExecutor</code>先调用了<code>onPreExecute()</code>接着执行了<code>exec.execute(mFuture)</code>。</p><p>接下来，先看看<code>sDefaultExecutor</code>是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">       Runnable mActive;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 将Runnable包装并添加到mTasks的末尾</span></span><br><span class="line">           <span class="comment">// 这里只是添加Runnable对象，而里面的run方法现在并没有执行</span></span><br><span class="line">           mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       r.run();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">// 当任务结束后再从mTasks取出任务执行</span></span><br><span class="line">                       scheduleNext();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="comment">// 执行下一个任务</span></span><br><span class="line">           <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">               scheduleNext();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 从mTasks取出任务并执行</span></span><br><span class="line">           <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// THREAD_POOL_EXECUTOR才是AsyncTask的执行器</span></span><br><span class="line">               THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 静态</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">               sPoolWorkQueue, sThreadFactory);</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>sDefaultExecutor</code>的作用是将一个<code>Runnable</code>包装并添加到<code>ArrayDeque&lt;Runnable&gt;</code>，然后使用<code>THREAD_POOL_EXECUTOR</code>去执行<code>Runnable</code>。当<code>Runnable</code>执行完成后接着调用<code>scheduleNext()</code>取出下一个执行。</p><p><code>sDefaultExecutor</code>就是一个串行的线程池，一个进程中所有的<code>AsyncTask</code>全部在这个串行线程池中排队执行。而<code>THREAD_POOL_EXECUTOR</code>才是<code>AsyncTask</code>的执行器。</p><p>接下来看看<code>mWorker</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">      mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              mTaskInvoked.set(<span class="keyword">true</span>); <span class="comment">// 设置任务已经被调用</span></span><br><span class="line">              Result result = <span class="keyword">null</span>; <span class="comment">// 结果</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                  <span class="comment">//noinspection unchecked</span></span><br><span class="line">                  result = doInBackground(mParams); <span class="comment">// 调用doInBackground执行异步任务</span></span><br><span class="line">                  Binder.flushPendingCommands();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                  mCancelled.set(<span class="keyword">true</span>); <span class="comment">// 设置任务被取消</span></span><br><span class="line">                  <span class="keyword">throw</span> tr;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  postResult(result); <span class="comment">// 发送结果</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">      Params[] mParams;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>mWorker</code>是<code>WorkerRunnable</code>的实例，<code>WorkerRunnable</code>是一个抽象类，里面只有一个<code>mParams</code>成员变量和一个来自<code>Callable</code>的接口方法<code>call()</code>。</p><p>在<code>mWorker</code>的<code>call()</code>方法中先设置<code>mTaskInvoked</code>表明任务已经被调用，然后调用<code>doInBackground(mParams)</code>来执行异步的任务。当任务出现异常时设置<code>mCancelled</code>，最后使用<code>postResult</code>去发送结果。</p><p>在开始的时候我们就知道<code>doInBackground(params)</code>是在后台执行，<code>onPostExecute()</code>和<code>onCancelled()</code>是在主线程执行。</p><p>在<code>executeOnExecutor()</code>中执行<code>exec.execute(mFuture)</code>才会将任务切换到后台线程中执行，我们来看看<code>mFuture</code>与<code>mWorker</code>直接的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">        mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; <span class="comment">// 当mWorker.call()执行完后调用</span></span><br><span class="line">                <span class="comment">// 如果任务没有被调用</span></span><br><span class="line">                <span class="comment">// 提交结果</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">        <span class="keyword">if</span> (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the</span></span><br><span class="line"><span class="comment">     * given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">                    result = c.call();</span><br><span class="line">       ...</span><br><span class="line">                    set(result);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">     ...   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>FutureTask</code>的作用是将传入的<code>Callable</code>在执行<code>run</code>的时候调用，所以<code>mWorker</code>中的<code>doInBackground()</code>也就切换到后台环境中了。</p><p>接下来看看<code>postResult(result)</code>和是怎么把结果发送到UI线程的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 通过Looper来获取Handler对象</span></span><br><span class="line">       <span class="comment">// 如果传入的callbackLooper为空就使用Looper.getMainLooper()</span></span><br><span class="line">       mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">           ? getMainHandler()</span><br><span class="line">           : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getMainHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</span><br><span class="line">           <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">               sHandler = <span class="keyword">new</span> InternalHandler(Looper.getMainLooper());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sHandler;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部Handler</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">           <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                   <span class="comment">// There is only one result</span></span><br><span class="line">                   <span class="comment">// 调用AsyncTask.finish</span></span><br><span class="line">                   <span class="comment">// finish将结果返回</span></span><br><span class="line">                   result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                   <span class="comment">// 调用AsyncTask.onProgressUpdate</span></span><br><span class="line">                   result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">           onCancelled(result);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           onPostExecute(result);</span><br><span class="line">       &#125;</span><br><span class="line">       mStatus = Status.FINISHED;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@WorkerThread</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用handler发送进度</span></span><br><span class="line">       <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">           getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                   <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 利用handler发送结果</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">               <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">       message.sendToTarget();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在AsyncTask里有一个内部Handler对象<code>InternalHandler</code>，<code>publishProgress</code>和<code>postResult</code>都是发送对应Message在<code>InternalHandler</code>中<code>handleMessage()中处理</code>，最后将结果回调给AsyncTask的方法。</p><p><strong>AsyncTask流程总结</strong></p><p>AsyncTask利用<code>SerialExecutor</code>，<code>ThreadPoolExecutor</code>和<code>InternalHandler</code>来完成任务线程的切换：</p><ol><li><p>当AsyncTask开始被执行的时候调用<code>onPreExecute()</code>。</p></li><li><p>将AsyncTask执行的参数传给<code>WorkerRunnable</code>，<code>WorkerRunnable</code>的call方法里面会调用AsyncTask的<code>doInBackground(mParams)</code></p></li><li><p>将<code>WorkerRunnable</code>传入<code>FutureTask</code>的构造方法中，<code>FutureTask</code>会在run方法执行的时候调用<code>WorkerRunnable</code>的call方法。</p></li><li><p><code>SerialExecutor</code>将<code>FutureTask</code>加入到队列，然后使用<code>ThreadPoolExecutor</code>执行<code>FutureTask</code>。</p></li><li><p><code>FutureTask</code>被执行后，<code>WorkerRunnable</code>里call方法就会被调用，所以<code>doInBackground(mParams)</code>此时运行在非UI线程来。当<code>doInBackground(mParams)</code>返回结果后就调用<code>postResult()</code>来返回结果。</p></li><li><p><code>postResult()</code>使用<code>InternalHandler</code>发送<code>MESSAGE_POST_RESULT</code>消息，然后<code>InternalHandler</code>使用<code>handleMessage</code>处理这些消息。</p></li><li><p><code>InternalHandler</code>根据消息的类别来调用<code>onCancelled()</code>、<code>onPostExecute()</code>和<code>onProgressUpdate()</code>，此时这些方法就运行在<code>InternalHandler</code>的线程了。</p></li><li><p>当我们手动更新进度调用<code>publishProgress()</code>时，也是发生<code>MESSAGE_POST_PROGRESS</code>，与上一步相同。</p></li></ol><h3 id="2-HandlerThread"><a href="#2-HandlerThread" class="headerlink" title="2. HandlerThread"></a>2. HandlerThread</h3><p><code>HandlerThread</code>继承了Thread，它里面持有Handler对象。它在<code>HandlerThread</code>运行的时候使用<code>Looper.prepare()</code>来创建线程的Looper对象，然后调用<code>Looper.loop()</code>开启消息循环。这样当有Message进来，就会在该线程中处理此Message。</p><p>一下是它的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare(); <span class="comment">// 创建线程Looper对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop(); <span class="comment">// 开启消息循环</span></span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们比较熟悉的HandlerThread使用场景是IntentService，具体分析移步到<a href="http://blog.xusheng.online/2018/06/29/Service/#3-IntentService">IntentService</a>。</p><h3 id="3-ThreadPoolExecutor"><a href="#3-ThreadPoolExecutor" class="headerlink" title="3. ThreadPoolExecutor"></a>3. ThreadPoolExecutor</h3><p>ThreadPoolExecutor是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">Java</a>提供给我们的线程池的实现类。</p><p>线程池可以解决两个不同问题：</p><ol><li><p>由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，</p></li><li><p>并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。</p></li></ol><p>ThreadPoolExecutor的构造方法提供了一系列参数来配置线程池：</p><ul><li>corePoolSize：池中所保存的线程数，包括空闲线程。</li><li>maximumPoolSize：线程池中允许存在的最大线程数。</li><li>keepAliveTime：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li><li>unit：keepAliveTime 参数的时间单位。</li><li>workQueue：执行前用于保持任务的队列。此队列仅保持由 <code>execute</code> 方法提交的 <code>Runnable</code> 任务。</li></ul><p>一般来说，我们不会通过它的构造方法来创建线程池，而是使用工具类<code>Executors</code>的静态方法来获取我们要创建的线程池对象。<code>Executors</code>可以为我们创建四种常用的线程池：</p><ol><li><p><strong>FixedThreadPool</strong></p><p>这是一个线程数量固定、队列大小没有限制的线程池。在任何时候，线程都将会被激活以处理任务。线程池中的线程不会停止直到调用<code>shutdown</code>。由于<code>FixedThreadPool</code>只有核心线程并且这些核心线程不会被回收，这意味着它能够更快速的响应外界的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>SingleThreadExecutor</strong></p><p>这是一个单一线程、队列大小没有限制的线程池。其内部只有一个线程，可以确保所有任务都在同一个线程中按顺序执行。<code>SingleThreadExecutor</code>的意义在于统一外界任务到一个线程中，这使得这些任务之间不需要处理线程同步问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>CachedThreadPool</strong></p><p>这是一个线程数量不定的线程池，它只有非核心线程，并且其最大线程数为<code>Integer.MAX_VALUE</code>。线程池中的空闲线程都有超时机制，这个超时时常为60s，超过这个时间的闲置线程就会被回收。<code>CachedThreadPool</code>的任务队列可以简单的理解为一个无法存储元素的队列，因此这将导致任何任务都会立刻执行。</p><p>从其特性来看，这类线程池适合执行大量耗时较少的任务。当整个线程池处理闲置状态时，线程池中的线程都会因为超时而被停止，这个时候<code>CachedThreadPool</code>之中实际上是没有线程的，它几乎不占用任何系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ScheduledThreadPool</strong></p><p>这是一个核心线程数量固定、非核心线程数量没有限制、非核心线程闲置时间10s的线程池。此类线程池主要用于执行定时任务和具有固定周期的重复任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android应用启动的时候，系统会为该应用创建一个”main”线程。这个线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理，因此又被叫作UI线程。&lt;/p&gt;
&lt;p&gt;如果应用执行比较耗时的操作就会
      
    
    </summary>
    
    
      <category term="Framework" scheme="https://blog.xusheng.online/categories/Framework/"/>
    
    
      <category term="Thread" scheme="https://blog.xusheng.online/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>探索Android启动优化</title>
    <link href="https://blog.xusheng.online/2018/12/27/%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.xusheng.online/2018/12/27/%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2018-12-27T10:59:26.000Z</published>
    <updated>2020-09-13T12:40:43.732Z</updated>
    
    <content type="html"><![CDATA[<p>对于客户端应用来说，启动速度是用户对于APP的第一体验。用户在使用APP时，交互最多最频繁的也就是APP启动页面。如果启动加载过慢，很可能造成用户对APP的印象过差，更有可能导致用户的卸载行为。</p><h3 id="1-APP的启动方式"><a href="#1-APP的启动方式" class="headerlink" title="1. APP的启动方式"></a>1. APP的启动方式</h3><p>  Android的启动方式分为冷启动、热启动、温启动。一般在做APP启动优化的时候都是基于冷启动的基础上。</p><h4 id="1-1-冷启动（cold-start）"><a href="#1-1-冷启动（cold-start）" class="headerlink" title="1.1 冷启动（cold start）"></a>1.1 冷启动（cold start）</h4><p>  冷启动是指应用从头开始启动，这时候的后台并没有该应用的进程（如APP首次启动、进程被杀等）。</p><p>  在冷启动开始的时候，系统会开始创建应用进程：</p><blockquote><ol><li>加载并启动应用</li><li>在应用启动后创建应用的空白窗口</li><li>创建应用进程</li></ol></blockquote><p>  系统创建完应用进程之后，应用进程就负责后续的任务：</p><blockquote><ol><li>创建应用对象（Application create）</li><li>创建主线程</li><li>创建主Activity</li><li>加载布局（inflate views）</li><li>布局屏幕（layout screen）</li><li>绘制首帧（initial draw）</li></ol></blockquote><p>  应用进程完成第一次绘制后，系统进程会将掉当前显示的后台窗口替换为主Activity。这时候用户就可以开始使用应用，至此应用启动完成。</p><p><strong>应用创建</strong></p><p>  当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么程序启动时会先出现一段时间的黑屏(白屏)。</p><p>如果有Application，系统会<code>onCreate()</code>在Application对象上调用该方法。之后，应用程序会生成主线程（也称为UI线程），并通过创建主要活动来执行任务。</p><p>从这一点开始，APP就按照他的应用程序生命周期阶段进行。</p><p><strong>Activity创建</strong></p><p>  应用程序进程创建活动后，活动将执行以下操作：</p><ol><li><p>初始化值。</p></li><li><p>调用构造函数。</p></li><li><p>调用回调方法，例如 Activity.onCreate()，对应Activity的当前生命周期状态。</p><p>通常，该onCreate()方法对加载时间的影响最大，因为它以最高的开销执行工作：加载和填充视图，以及初始化活动运行所需的对象。</p></li></ol><h4 id="1-2-热启动（hot-start）"><a href="#1-2-热启动（hot-start）" class="headerlink" title="1.2 热启动（hot start）"></a>1.2 热启动（hot start）</h4><p>  热启动比冷启动简单的多。系统只需要将Activity从后台切换到到前台，并不会执行应用创建等系列任务。但是在应用完成Activity绘制之前，系统进程也会显示空白窗口。</p><h4 id="1-3-温启动（warm-start）"><a href="#1-3-温启动（warm-start）" class="headerlink" title="1.3 温启动（warm start）"></a>1.3 温启动（warm start）</h4><p>  温启动的场景有很多，它包含了在冷启动期间发生的部分操作。常见的场景有：</p><blockquote><ol><li>用户在退出应用后又重新打开冷应用。此时应用进程可能已经存在，但是应用必须通过调用<code>onCreate()</code>重新创建</li><li>应用被系统杀死，然后用户有重新启动了应用。此时应用进程和Activity都需要重建，但是通过<code>onSaveInstanceState()</code>保存的数据能够帮助恢复数据。</li></ol></blockquote><h3 id="2-启动时间检测"><a href="#2-启动时间检测" class="headerlink" title="2. 启动时间检测"></a>2. 启动时间检测</h3><p>  APP的启动时间是指从应用初始化到显示启动的Activity的这段时间。</p><h4 id="2-1-通过logcat查看启动时间"><a href="#2-1-通过logcat查看启动时间" class="headerlink" title="2.1 通过logcat查看启动时间"></a>2.1 通过logcat查看启动时间</h4><p>在 Android 4.4及更高版本中，logcat 通过 <code>Displayed</code> 日志来输出从启动进程到在屏幕上完成对应 Activity 的绘制所用的时间。日志的显示类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityTaskManager: Displayed [package_name]&#x2F;[activity]: +132ms</span><br></pre></td></tr></table></figure><p>这里显示的时间包含一下事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动进程 --&gt; 初始化对象 --&gt; 创建并初始化Activity --&gt; 填充布局 --&gt; 绘制首帧</span><br></pre></td></tr></table></figure><h4 id="2-2-通过adb命令查看启动时间"><a href="#2-2-通过adb命令查看启动时间" class="headerlink" title="2.2 通过adb命令查看启动时间"></a>2.2 通过adb命令查看启动时间</h4><p>  通过手动执行adb命令来查看启动时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -S -W [package_name]&#x2F;[activity]</span><br></pre></td></tr></table></figure><p>查看输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Starting: Intent &#123; act&#x3D;android.intent.action.MAIN cat&#x3D;[android.intent.category.LAUNCHER] cmp&#x3D;[package_name]&#x2F;[activity] &#125;</span><br><span class="line">Status: ok</span><br><span class="line">LaunchState: COLD </span><br><span class="line">Activity: [package_name]&#x2F;[activity]</span><br><span class="line">TotalTime: 704</span><br><span class="line">WaitTime: 706</span><br><span class="line">Complete</span><br></pre></td></tr></table></figure><h4 id="2-3-完全显示所用时间（reportFullyDrawn）"><a href="#2-3-完全显示所用时间（reportFullyDrawn）" class="headerlink" title="2.3 完全显示所用时间（reportFullyDrawn）"></a>2.3 完全显示所用时间（reportFullyDrawn）</h4><p>  在Android 4.4之后可以在Activity中手动调用<code>reportFullyDrawn()</code>，通知系统Activity已经完成加载。此时logcat中显示的时间为创建应用对象到手动调用``reportFullyDrawn()`的时间，输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityTaskManager: Fully drawn [package_name]&#x2F;[activity]: +1s3ms</span><br></pre></td></tr></table></figure><h3 id="3-冷启动优化"><a href="#3-冷启动优化" class="headerlink" title="3. 冷启动优化"></a>3. 冷启动优化</h3><p>  当应用启动出现以下情况时，将被视作启动时间过长。为了更好的用户体验，需要对APP的启动进行优化。</p><blockquote><ul><li>冷启动用了 5 秒或更长时间。</li><li>温启动用了 2 秒或更长时间。</li><li>热启动用了 1.5 秒或更长时间。</li></ul></blockquote><h4 id="3-1-设置启动屏幕背景"><a href="#3-1-设置启动屏幕背景" class="headerlink" title="3.1 设置启动屏幕背景"></a>3.1 设置启动屏幕背景</h4><p>  为了优化系统创建应用进程时创建的空白窗口导致启动时白屏。我们可以使用Activity的<code>WindowBackground</code>主题背景属性，为Activity提供默认的背景页面。</p><p>drawable布局文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> <span class="attr">android:opacity</span>=<span class="string">&quot;opaque&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:src</span>=<span class="string">&quot;@drawable/logo&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  设置启动也的样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme.Launcher&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/background_launcher<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后在清单文件中设置style：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme.Launcher&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>  如果需要切回正常的主题，最简单的方法是先调用<code>setTheme(R.style.AppTheme)</code>，然后再调用 <code>super.onCreate()</code> 和 <code>setContentView()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplashActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        setTheme(R.style.R.style.AppTheme)</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-Application-create优化"><a href="#3-2-Application-create优化" class="headerlink" title="3.2 Application create优化"></a>3.2 Application create优化</h4><p>  一般来说，我们引用的很多第三方库都是在Application中初始化。假设Application的初始化操作有友盟，百度，bugly，数据库，IM，图片加载库，网络请求库，广告sdk，地图，推送等。这些会导致Application加载缓慢，需要异步执行。下面是简单的使用线程去初始化第三方sdk：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    initUMengPush()</span><br><span class="line">    initBadidu()</span><br><span class="line">    initBlugy()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-Activity-create优化"><a href="#3-3-Activity-create优化" class="headerlink" title="3.3 Activity create优化"></a>3.3 Activity create优化</h4><p>Activity的优化部分主要在于布局的优化，<a href="http://blog.xusheng.online/2019/01/28/Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">Android布局优化</a></p><h4 id="3-4-使用App-Startup"><a href="#3-4-使用App-Startup" class="headerlink" title="3.4 使用App Startup"></a>3.4 使用App Startup</h4><blockquote><p>The App Startup library provides a straightforward, performant way to initialize components at application startup. Both library developers and app developers can use App Startup to streamline startup sequences and explicitly set the order of initialization.</p></blockquote><p>App Startup库提供了一种直接、高效的方法在应用程序启动时初始化组件。sdk库和app的开发人员都可以使用App Startup来简化并明确设置初始化顺序。</p><p>参考：<a href="https://developer.android.com/topic/libraries/app-startup">App Startup</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于客户端应用来说，启动速度是用户对于APP的第一体验。用户在使用APP时，交互最多最频繁的也就是APP启动页面。如果启动加载过慢，很可能造成用户对APP的印象过差，更有可能导致用户的卸载行为。&lt;/p&gt;
&lt;h3 id=&quot;1-APP的启动方式&quot;&gt;&lt;a href=&quot;#1-APP
      
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.xusheng.online/categories/Android/"/>
    
    
      <category term="性能优化" scheme="https://blog.xusheng.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制</title>
    <link href="https://blog.xusheng.online/2018/11/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.xusheng.online/2018/11/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2018-11-21T14:28:43.000Z</published>
    <updated>2020-09-14T07:19:45.953Z</updated>
    
    <content type="html"><![CDATA[<p>Android中的消息机制其实是指<strong>Handler</strong>的运行机制。Handler可以轻松的将一个任务切换到Handler所在的线程中运行。比如我们从获取到网络获取数据然后更新UI，由于在Android中不能在主线程中去发松网络请求，同时也不能够在子线程中去访问UI控件。这时候就可以从子线程中获取数据，然后通过Handler将更新UI的操作切换到主线程中执行。</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Android的消息机制由<code>Handler</code>、<code>Message</code>、<code>MessageQueue</code>和<code>Looper</code>四个要素组成。</p><p>Handler在创建的时候会使用当前线程的Looper来构造消息循环模型，如果当前线程中没有Looper就会抛出运行时异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决的办法就是在主线程中创建Handler，或者在子线程创建之前调用<code>Looper.prepare()</code>去初始化Looper。</p><p>Handler创建完成之后，Looper和MessageQueue就能与Handler一起工作了。Handler将Message发送到MessageQueue中，Looper会取出消息并交由<code>Handler.handleMessage()</code>处理。由于Looper运行在创建Handler的线程，这样Handler中的业务逻辑就被切换到创建Handler所在的线程中去了。</p><blockquote><p><code>Handler.post(Runnable)</code>最终也是通过发送Message实现的。</p></blockquote><h3 id="2-消息机制分析"><a href="#2-消息机制分析" class="headerlink" title="2. 消息机制分析"></a>2. 消息机制分析</h3><h4 id="2-1-ThreadLocal"><a href="#2-1-ThreadLocal" class="headerlink" title="2.1 ThreadLocal"></a>2.1 ThreadLocal</h4><p>在执行<code>Looper.prepare()</code>和<code>Looper myLooper()</code>都会使用到ThreadLocal，所以我们需要先了解一下ThreadLocal的工作原理。</p><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在各个线程中存储不同的数据。</p><p>ThreadLocal 内部维护了一个 <strong>ThreadLocalMap</strong>，ThreadLocalMap将当前线程作为key来保存我们传入的数据。我们使用ThreadLocal的<code> get()</code>、<code>set() </code>方法其实都是调用了这个ThreadLocalMap类对应的<code> get()</code>、<code>set() </code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    Thread t = Thread.currentThread();   </span><br><span class="line">    ThreadLocalMap map = getMap(t);   </span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)   </span><br><span class="line">        <span class="keyword">return</span> (T)map.get(<span class="keyword">this</span>);   </span><br><span class="line">    <span class="comment">// Maps are constructed lazily.  if the map for this thread   </span></span><br><span class="line">    <span class="comment">// doesn&#x27;t exist, create it, with this ThreadLocal and its   </span></span><br><span class="line">    <span class="comment">// initial value as its only entry.   </span></span><br><span class="line">    T value = initialValue();   </span><br><span class="line">    createMap(t, value);   </span><br><span class="line">    <span class="keyword">return</span> value;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>我们就不继续往下深入ThreadLocalMap了，现在回到Looper中看看它是怎样使用ThreadLocal的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们使用<code>Looper.prepare()</code>的时候就能将Looper对象添加到当前线程中了。</p><h4 id="2-2-Message"><a href="#2-2-Message" class="headerlink" title="2.2 Message"></a>2.2 Message</h4><p>Message的作用是定义一条可以被发送到Handler的消息。</p><p>Message可以通过构造方法创建，也可以通过<code>Message.obtain()</code>来创建。我们看看<code>Message.obtain()</code>创建的Message有什么不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool; <span class="comment">// 静态变量，消息池</span></span><br><span class="line">Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>; <span class="comment">// sPool长度计数器</span></span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">           <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Message m = sPool; <span class="comment">// sPool头节点</span></span><br><span class="line">               sPool = m.next; <span class="comment">// 将sPool后移以为</span></span><br><span class="line">               m.next = <span class="keyword">null</span>;</span><br><span class="line">               m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">               sPoolSize--; <span class="comment">// 长度减1</span></span><br><span class="line">               <span class="keyword">return</span> m; <span class="comment">// 返回头节点</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Message里的sPool是一个单向链表，它的结构类似如下：</p><img src="/2018/11/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Link_zh.png" class="" title="Link_zh"><p>如果sPool不为空，将sPool后移一位，然后将原来的头结点m返回，同时计数减1。如果为空就新建Message。这里可以看出Message使用<code>obtain()</code>是可以复用Message的，所以Message的创建方式最好还是<code>obtain()</code>，这样可以用到缓存池里面的缓存对象。</p><p>了解了Message复用之后，我们来看看Message是怎么回收的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果Message的flags是FLAG_IN_USE</span></span><br><span class="line">    <span class="comment">// 在obtain的时候已经将flags设为0了</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行回收操作</span></span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    <span class="comment">// 清空消息中的成员变量</span></span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool; </span><br><span class="line">            sPool = <span class="keyword">this</span>; <span class="comment">// 将Message放入sPool头节点</span></span><br><span class="line">            sPoolSize++;  <span class="comment">// sPool长度加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Message的flags为FLAG_IN_USE，<code>recycle()</code>会直接返回，而不会执行<code>recycleUnchecked()</code>。当Message在<code>obtain()</code>的时候flags已经被设置为0，在执行<code>recycle()</code>的时候就会调用<code>recycleUnchecked()</code>。</p><p><code>recycleUnchecked()</code>会将flags设置为FLAG_IN_USE，然后清空里面的成员属性。然后添加到sPool的头节点。</p><p>这样保证了我们在复用Message的时候拿到的是一个干净的Message。</p><h4 id="2-3-MessageQueue"><a href="#2-3-MessageQueue" class="headerlink" title="2.3 MessageQueue"></a>2.3 MessageQueue</h4><p>MessageQueue主要有两个操作：Message的插入<code>enqueueMessage()</code>和Message的取出<code>next()</code>。</p><p>MessageQueue内部也是通过单向链表来维护Message队列的，和<code>Message.sPool</code>一样。</p><p>我们先来看一下插入Message的方法<code>enqueueMessage()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// MessageQueue在退出的时候mQuitting会被设置为true</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle(); <span class="comment">// 回收Message</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse(); <span class="comment">// 标记Message</span></span><br><span class="line">        msg.when = when; </span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">// 将message插入mMessages链表中</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 将Message添加为链表的头节点</span></span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 根据when将Message插入到mMessages链表中</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            <span class="comment">// native方法</span></span><br><span class="line">            <span class="comment">// 唤醒阻塞状态</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enqueueMessage()</code>就是添加Message和唤醒阻塞线程的操作。添加Message根据传入的when来插入到链表中，这时候就能体现出链表的效率了。</p><p>接下来看一下插入Message的方法<code>next()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">     <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// 待处理的空闲handler数量</span></span><br><span class="line">     <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">     <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>; <span class="comment">// 下一次轮询时间</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 刷新挂起命令</span></span><br><span class="line">             Binder.flushPendingCommands();</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// native</span></span><br><span class="line">         <span class="comment">// 如果没有消息，进入阻塞状态</span></span><br><span class="line">         nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">             Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">             Message msg = mMessages;</span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     prevMsg = msg;</span><br><span class="line">                     msg = msg.next;</span><br><span class="line">                 &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                     nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// Got a message.</span></span><br><span class="line">                     mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         prevMsg.next = msg.next;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         mMessages = msg.next;</span><br><span class="line">                     &#125;</span><br><span class="line">                     msg.next = <span class="keyword">null</span>;</span><br><span class="line">                     <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                     msg.markInUse();</span><br><span class="line">                     <span class="comment">// 返回Message</span></span><br><span class="line">                     <span class="keyword">return</span> msg;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// No more messages.</span></span><br><span class="line">                 nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                 dispose();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">                处理空闲Handler的操作，省略</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">         pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">         nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>next()</code>取出消息的操作是一个死循环，在循环中根据下次轮询的时间<code>nextPollTimeoutMillis</code>来刷新挂起。如果没有Message则从调用native方法<code>nativePollOnce()</code>进入阻塞状态，直到<code>enqueueMessage()</code>中进行唤醒。</p><h4 id="2-4-Looper"><a href="#2-4-Looper" class="headerlink" title="2.4 Looper"></a>2.4 Looper</h4><p>Looper在Android消息机制扮演着消息循环的角色，它会一直从MessageQueue中取出Message（假如MessageQueue没有阻塞的话）。</p><p>Looper通过调用<code>prepare()</code>来为当前线程创建一个Looper对象，然后调用<code>loop()</code>来开启消息循环。我们主要看看<code>loop()</code>是如何循环消息的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">// 当前线程Looper对象</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                        + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 从MessageQueue中取出消息</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只有msg为null时才跳出循环</span></span><br><span class="line">                <span class="comment">// MessageQueue.next方法只有在MessageQueue退出的时候才返回null</span></span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                        msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// message的handler分发消息</span></span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回收消息</span></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper最重要的方法是<code>loop()</code>方法，只有调用了此方法消息循环系统才会真正开始运行。<code>loop()</code>是一个死循环，唯一跳出循环的条件是<code>MessageQueue.next()</code>返回null(MessageQueue只有在退出的时候才会返回null)。</p><p>上面的代码主要干了这些事：</p><ol><li>开启一个死循环</li><li>从MessageQueue中取出消息</li><li>将消息发送给Handler的<code>dispatchMessage()</code></li><li>回收消息</li></ol><h4 id="2-5-Handler"><a href="#2-5-Handler" class="headerlink" title="2.5 Handler"></a>2.5 Handler</h4><p>Handler主要用于发送消息以及处理消息。它发送消息的方法最终都会执行<code>enqueueMessage()</code>，其实就是调用<code>MessageQueue.enqueueMessage()</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Handler &#123;</span><br><span class="line">    final Looper mLooper;</span><br><span class="line">    final MessageQueue mQueue;</span><br><span class="line">    ...</span><br><span class="line">    public Handler(@Nullable Callback callback, boolean async) &#123;</span><br><span class="line">        mLooper &#x3D; Looper.myLooper();</span><br><span class="line">        mQueue &#x3D; mLooper.mQueue;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,</span><br><span class="line">            long uptimeMillis) &#123;</span><br><span class="line">        msg.target &#x3D; this;</span><br><span class="line">        msg.workSourceUid &#x3D; ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        if (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 使用Looper中的MessageQueue插入消息</span><br><span class="line">        return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法最后都会通过<code>MessageQueue.enqueueMessage()</code>向中插入新消，然后通过<code>Looper.loop()</code>从<code>MessageQueue.next()</code>中获取出来，最后由Looper传递给<code>msg.target.dispatchMessage()</code>来处理。这时Handler就进入了处理消息的阶段。</p><p>我们来看看<code>dispatchMessage()</code>是怎样把消息传入到<code>handleMessage()</code>中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       ...</span><br><span class="line">   &#125;       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果是post(Runnable)</span></span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">       message.callback.run();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Handler处理消息的过程如下：</p><ol><li><p>如果Message的callback不为空，执行它的run方法</p></li><li><p>如果通过Handler的Callback不为空，执行它的handleMessage方法</p></li><li><p>如果都为空，则执行Handler的handleMessage方法</p><p>Handler的子类为了能够接受Message需要实现handleMessage方法</p></li></ol><h3 id="3-主线程的消息循环"><a href="#3-主线程的消息循环" class="headerlink" title="3. 主线程的消息循环"></a>3. 主线程的消息循环</h3><p>Android的主线程就是<code>ActivityThread</code>，入口方法和Java程序一样也是<code>main()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> Handler sMainThreadHandler;  <span class="comment">// set once in main()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">       thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           sMainThreadHandler = thread.getHandler();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">           Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                   LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">       Looper.loop();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mH;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到在main方法中通过使用<code>Looper.prepareMainLooper()</code>来创建了一个Looper对象，然后调用<code>Looper.loop()</code>来开启循环。</p><p>在这里还创建了一个<code>ActivityThread.H</code>的handler，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVER                = <span class="number">113</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_SERVICE          = <span class="number">114</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_ARGS            = <span class="number">115</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_SERVICE            = <span class="number">116</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONFIGURATION_CHANGED   = <span class="number">118</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLEAN_UP_CONTEXT        = <span class="number">119</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GC_WHEN_IDLE            = <span class="number">120</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_SERVICE            = <span class="number">121</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNBIND_SERVICE          = <span class="number">122</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_SERVICE            = <span class="number">123</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOW_MEMORY              = <span class="number">124</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROFILER_CONTROL        = <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_BACKUP_AGENT     = <span class="number">128</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DESTROY_BACKUP_AGENT    = <span class="number">129</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUICIDE                 = <span class="number">130</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVE_PROVIDER         = <span class="number">131</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_PACKAGE_BROADCAST = <span class="number">133</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULE_CRASH          = <span class="number">134</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_HEAP               = <span class="number">135</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_ACTIVITY           = <span class="number">136</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPING                = <span class="number">137</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SET_CORE_SETTINGS       = <span class="number">138</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE_PACKAGE_COMPATIBILITY_INFO = <span class="number">139</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_PROVIDER           = <span class="number">141</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSTABLE_PROVIDER_DIED  = <span class="number">142</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_ASSIST_CONTEXT_EXTRAS = <span class="number">143</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSLUCENT_CONVERSION_COMPLETE = <span class="number">144</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PROVIDER        = <span class="number">145</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_NEW_ACTIVITY_OPTIONS = <span class="number">146</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTER_ANIMATION_COMPLETE = <span class="number">149</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_BINDER_TRACKING = <span class="number">150</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_BINDER_TRACKING_AND_DUMP = <span class="number">151</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOCAL_VOICE_INTERACTION_STARTED = <span class="number">154</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACH_AGENT = <span class="number">155</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLICATION_INFO_CHANGED = <span class="number">156</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN_ISOLATED_ENTRY_POINT = <span class="number">158</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTE_TRANSACTION = <span class="number">159</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RELAUNCH_ACTIVITY = <span class="number">160</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PURGE_RESOURCES = <span class="number">161</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>为什么在主线程中调用Looper.loop()不导致线程阻塞？</p><blockquote><p>Looper.loop()是一个死循环，它会不断的调用<code>MessageQueue.next()</code>来读取MessageQueue中的消息。</p><p>next 操作是一个阻塞操作，当MessageQueue中没有消息的时候 next 方法会一直阻塞, 进而导致 loop 阻塞。我们知道<code>nativePollOnce()</code>是让线程阻塞，<code>nativeWake()</code>是用来唤醒的。那我们发送一次Message并完成处理后MessageQueue是不是就会一直阻塞呢？</p><p>Android是基于事件的，在屏幕刷新、系统广播等都会往主线程的MessageQueue中添加消息，然后通过<code>nativeWake()</code>唤醒线程。</p><p>实际上可以理解为, 主线程也是随时挂起, 随时被阻塞的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android中的消息机制其实是指&lt;strong&gt;Handler&lt;/strong&gt;的运行机制。Handler可以轻松的将一个任务切换到Handler所在的线程中运行。比如我们从获取到网络获取数据然后更新UI，由于在Android中不能在主线程中去发松网络请求，同时也不能够在
      
    
    </summary>
    
    
      <category term="Framework" scheme="https://blog.xusheng.online/categories/Framework/"/>
    
    
      <category term="Handler" scheme="https://blog.xusheng.online/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>探索Android中的ClassLoader</title>
    <link href="https://blog.xusheng.online/2018/11/03/%E6%8E%A2%E7%B4%A2Android%E4%B8%AD%E7%9A%84ClassLoader/"/>
    <id>https://blog.xusheng.online/2018/11/03/%E6%8E%A2%E7%B4%A2Android%E4%B8%AD%E7%9A%84ClassLoader/</id>
    <published>2018-11-03T15:04:32.000Z</published>
    <updated>2020-09-13T12:40:43.731Z</updated>
    
    <content type="html"><![CDATA[<p>对于Java程序来说，编写程序就是在编写类，运行程序就是在运行Java编译后的class文件。在程序运行时，需要将class文件加载到jvm中才可以使用，负责加载这些class文件就是Java中的ClassLoader。</p><h3 id="1-ClassLoader的加载机制"><a href="#1-ClassLoader的加载机制" class="headerlink" title="1. ClassLoader的加载机制"></a>1. ClassLoader的加载机制</h3><p>ClassLoader加载类的过程就是<code>loadClass(String class_name, boolean resolve)</code>的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;? loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;? loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;? c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;? findBootstrapClassOrNull(String name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;? findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassLoader加载的机制就是双亲委托，当类加载器收到加载类或者资源的请求时，通常都是先委托给父类加载器，也就是说当父类加载器找不到指定的类或资源时，自身才会执行实际的类加载过程，具体的加载过程如下：</p><ol><li><p>源classloader判断该class是否已加载，如果已加载，则直接返回class，反之则委托给父类加载器。</p></li><li><p>父类加载器判断是否加载过该 Class，如果已加载，则直接返回 Class，如果没有则委托给祖父类加载器。</p></li><li><p>依此类推，直到始祖类加载器（引用类加载器）。</p></li><li><p>始祖类加载器判断是否加载过该class，如果已加载则直接返回class，如果没有加载则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功就直接返回，如果载入失败则委托给始祖类的字类加载器。</p></li><li><p>始祖类加载器的字类加载同样尝试加载类class，并在失败时委托给其子类加载器</p></li><li><p>依次类推直到源类加载器</p></li><li><p>源类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则字节返回class，否则抛出<code>ClassNotFoundException</code></p></li></ol><h3 id="2-1-Android中的ClassLoader"><a href="#2-1-Android中的ClassLoader" class="headerlink" title="2.1 Android中的ClassLoader"></a>2.1 Android中的ClassLoader</h3><p>Android平台抛弃了传统JVM需要的.jar文件，而是采用体积更小的.dex文件。因此，Android自定义了一些ClassLoader以满足对dex加载。</p><p><strong><a href="https://android.googlesource.com/platform/libcore/+/refs/tags/android-9.0.0_r60/dalvik/src/main/java/dalvik/system/PathClassLoader.java">PathClassLoader</a></strong></p><p>提供一个简单的<code>ClassLoader</code>实现，该实现对本地文件系统中的文件和目录列表进行操作，但不尝试从网络中加载类。Android将此类用于其系统类加载器和应用程序类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建PathClassLoader对指定文件和目录列表进行操作的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath 包含类和资源的jar / apk文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个PathClassLoader对两个给定的文件和目录列表进行操作的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath 包含类和资源的jar / apk文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> librarySearchPath 包含native库的目录列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是是<code>PathClassLoader</code>的全部代码了，我们可以看到它单纯的继承了<code>BaseDexClassLoader</code>，然后重写了构造方法。</p><p><strong><a href="https://android.googlesource.com/platform/libcore/+/refs/tags/android-9.0.0_r60/dalvik/src/main/java/dalvik/system/DexClassLoader.java">DexClassLoader</a></strong></p><p>从<code>.jar</code>和<code>.apk</code>文件中加载类<code>classes.dex</code>，可以从未安装的应用中执行代码。因此我们用它来加载插件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来加载包含 class.dex 的 .jar 和 .apk 文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath 包含类和资源的jar / apk文件列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory 存放优化后的 dex，不建议使用此参数，并且自API 26起无效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> librarySearchPath 包含native库的目录列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和PathClassLoader一样，DexClassLoader也只是继承了BaseDexClassLoader。看来，只要弄清楚了BaseDexClassLoader就能理解PathClassLoader和DexClassLoader的加载机制了。</p><blockquote><p><a href="https://github.com/xshengcn/PluginDemo">这个Demo</a>简单的演示类如何使用DexClassLoader来加载插件。</p></blockquote><p><strong><a href="https://android.googlesource.com/platform/libcore/+/refs/tags/android-9.0.0_r60/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java">BaseDexClassLoader</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(dexPath, optimizedDirectory, librarySearchPath, parent, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent, <span class="keyword">boolean</span> isTrusted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, <span class="keyword">null</span>, isTrusted);</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">        Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是BaseDexClassLoader加载类的关键代码，首先构造方法中通过创建了一个<code>DexPathList</code>对象，然后重写了<code>findClass()</code>，并使用<code>DexPathList</code>来加载类。</p><p>所以我们接下来进入**<a href="https://android.googlesource.com/platform/libcore/+/refs/tags/android-9.0.0_r60/dalvik/src/main/java/dalvik/system/DexPathList.java">DexPathList</a>**中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">&quot;.dex&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zipSeparator = <span class="string">&quot;!/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader definingContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Element[] dexElements;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                       String librarySearchPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(definingContext, dexPath, librarySearchPath, optimizedDirectory, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">                String librarySearchPath, File optimizedDirectory, <span class="keyword">boolean</span> isTrusted) &#123;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// 使用传入的文件路径来生成Element数组</span></span><br><span class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                suppressedExceptions, definingContext, isTrusted);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                             List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, <span class="keyword">boolean</span> isTrusted) &#123;</span><br><span class="line">        Element[] elements = <span class="keyword">new</span> Element[files.size()];</span><br><span class="line">        <span class="keyword">int</span> elementsPos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123; <span class="comment">// 遍历文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123; <span class="comment">// 如果文件是一个目录</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="comment">// We support directories for looking up resources. Looking up resources in</span></span><br><span class="line">                <span class="comment">// directories is useful for running libcore tests.</span></span><br><span class="line">                elements[elementsPos++] = <span class="keyword">new</span> Element(file);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                String name = file.getName();</span><br><span class="line">                DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">                ...</span><br><span class="line">                        dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">                        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            elements[elementsPos++] = <span class="keyword">new</span> Element(dex, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">if</span> (dex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        elements[elementsPos++] = <span class="keyword">new</span> Element(file);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        elements[elementsPos++] = <span class="keyword">new</span> Element(dex, file);</span><br><span class="line">                    &#125;</span><br><span class="line">               ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.logW(<span class="string">&quot;ClassLoader referenced unknown path: &quot;</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory, ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Element[] elements)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file, loader, elements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>, loader, elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> File path;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line">        <span class="keyword">private</span> ClassPathURLStreamHandler urlHandler;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; findClass(String name, ClassLoader definingContext,</span><br><span class="line">                                  List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">            <span class="keyword">return</span> dexFile != <span class="keyword">null</span> ? dexFile.loadClassBinaryName(name, definingContext, suppressed)</span><br><span class="line">                    : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到DexPathList在构造方法中将传入的参数生成一个<code>Element</code>数组，然后<code>findClass()</code>的时候遍历<code>Element</code>数组，使用<code>Element#findClass()</code>去加载类。</p><p><code>Element#findClass()</code>真正调用的是<code>dexFile.loadClassBinaryName</code>，在<code>DexFile</code>中是通过native来实现类加载的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于Java程序来说，编写程序就是在编写类，运行程序就是在运行Java编译后的class文件。在程序运行时，需要将class文件加载到jvm中才可以使用，负责加载这些class文件就是Java中的ClassLoader。&lt;/p&gt;
&lt;h3 id=&quot;1-ClassLoader的
      
    
    </summary>
    
    
      <category term="Framework" scheme="https://blog.xusheng.online/categories/Framework/"/>
    
    
      <category term="Animation" scheme="https://blog.xusheng.online/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>View的工作流程</title>
    <link href="https://blog.xusheng.online/2018/10/16/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://blog.xusheng.online/2018/10/16/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</id>
    <published>2018-10-16T13:21:12.000Z</published>
    <updated>2020-09-14T07:28:03.504Z</updated>
    
    <content type="html"><![CDATA[<p>View的工作流程指measure、layout、draw三大流程，即测量、布局和绘制。其中，measure确定View的测量宽高，layout确定View的最终宽高和四个顶点的位置，而draw则将View绘制到屏幕上。</p><h3 id="1-measure过程"><a href="#1-measure过程" class="headerlink" title="1. measure过程"></a>1. measure过程</h3><h4 id="1-1-View的measure过程"><a href="#1-1-View的measure过程" class="headerlink" title="1.1 View的measure过程"></a>1.1 View的measure过程</h4><p>View的measure过程由其<code>measure</code>方法来完成，这是一个final类型的方法，这意味着子类不能重写其方法。在View的<code>measure</code>方法中回去调用View的<code>onMeasure</code>方法，因此只需要看<code>onMeasure</code>的实现即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setMeasuredDimension</code>方法会设置View的测量宽高。我们接着看<code>getDefaultSize</code>和<code>getSuggestedMinimumWidth()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getDefaultSize</code>我们只看AT_MOST和EXACTLY的情况，因此可以简单的理解为此方法就是返回的size就是specSize。 至于UNSPECIFIED，一般用于系统内部的测量过程，此时，View的大小为<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>。从源码中可以看出，如果View没有背景，那么View的宽度为mMinWidth（即android:minWidth指定的值）；如果View有背景，则宽度为<code>max(mMinWidth, mBackground.getMinimumWidth())</code>。mBackground是一个Drawable对象，其<code>getMinimumWidth</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class="line">    <span class="keyword">return</span> intrinsicWidth &gt; <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此<code>getMinimumWidth</code>返回的就是Drawable的原始宽度，若没有原始宽度则返回0。不是所有的Drawable对象都有原始宽度，ShapeDrawable没有原始宽高，而BitmapDrawable就有。</p><h4 id="1-2-自定义View为何需要重写onMeasure方法"><a href="#1-2-自定义View为何需要重写onMeasure方法" class="headerlink" title="1.2 自定义View为何需要重写onMeasure方法"></a>1.2 自定义View为何需要重写onMeasure方法</h4><p>从<code>getDefaultSize</code>的实现来看，View的宽高从specSize决定，所以<strong>直接继承View的自定义控件需要重写<code>onMeasure</code>方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content相当于使用match_parent</strong>。</p><p>这是因为如果View使用wrap_content，那么其specMode对应AT_MOST，且由上面代码可以看出宽高为specSize；在由上面的表得知，此时View的specSize就是parentSize，而parentSize就是父容器可用剩余空间。这种效果和在布局中使用match_parent效果一样。解决办法就是给View指定一个默认的内部宽高，在wrap_content时设置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST ) &#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        setMeasuredDimension(widthMeasureSpec, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-ViewGroup的measure过程"><a href="#1-3-ViewGroup的measure过程" class="headerlink" title="1.3 ViewGroup的measure过程"></a>1.3 ViewGroup的measure过程</h4><p>对于ViewGroup来说，除了完成自己的measure外，还会遍历调用所有子元素的<code>measure</code>方法，各个子元素再递归执行这个过程。ViewGroup是一个抽象类，因此它并没有重写View的<code>onMeasure</code>方法，这个方法需要具体的ViewGroup类（比如LinearLayout、RelativeLayout等）来实现。下面我们通过LinearLayout来分析。 首先我们看一下<code>LinearLayout#onMeasure</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinearLayout会根据orientation的值来调用不同的方法，此处我们选择竖直方向的<code>measureVertical</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// See how tall everyone is. Also remember max width.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> useExcessSpace = lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="comment">// Optimization: don&#x27;t bother measuring children who are only</span></span><br><span class="line">            <span class="comment">// laid out using excess space. These views will get measured</span></span><br><span class="line">            <span class="comment">// later if we have space to distribute.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">            <span class="comment">// Determine how big this child would like to be. If this or</span></span><br><span class="line">            <span class="comment">// previous children have given a weight, then we allow it to</span></span><br><span class="line">            <span class="comment">// use all available space (and we will shrink things later</span></span><br><span class="line">            <span class="comment">// if needed).</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> usedHeight = totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                    heightMeasureSpec, usedHeight);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum height</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reconcile our calculated size with the heightMeasureSpec</span></span><br><span class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码描述了主要逻辑，我们可以看出在LinearLayout的<code>measureVertical</code>方法会在会判断LinearLayout的heightSpecMode。如果是精确模式且子元素高为0、有权重，则直接设置高度，然后跳过测量；如果是AT_MOST，则需要测量。系统会通过<code>measureChildBeforeLayout</code>—&gt;<code>measureChildWithMargins</code>—&gt;<code>child.measure</code>，这样各个子元素就依次进入measure过程，然后系统会通过mTotalLength变量存储自身测量出来的高度。每测量一个元素，mTotalLength就会增加，增加部分包括子元素的高度以及子元素的在竖直方向上的margin。 子元素测量完成后，LinearLayout会测量自己的大小，其具体过程是通过<code>View#resolveSizeAndState</code>方法来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveSizeAndState</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec, <span class="keyword">int</span> childMeasuredState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对竖直的LinearLayout而言，它在水平方向的测量过程遵循View的测量过程。在竖直方向的测量过程和View稍有不同：如果是match_parent或具体数字（也就是EXACTLY模式），那么其过程和View一样；如果是wrap_content，那么其高度是所有子元素加上竖直方向padding之和，但是不能超过父容器的剩余空间。</p><p>View的measure过程是三大流程中最复杂的一个，measure完成后，可以通过<code>getMeasuredWidth/Height</code>方法来获取View的测量宽高。需要注意，在某些极端情况下，系统会进行多次测量，此时在<code>onMeasure</code>中拿到的测量宽高可能是不准确的，比较好的方式是在<code>onLayout</code>中去获取测量宽高。</p><h4 id="1-4-Activity中获取View宽高的几种方式"><a href="#1-4-Activity中获取View宽高的几种方式" class="headerlink" title="1.4 Activity中获取View宽高的几种方式"></a>1.4 Activity中获取View宽高的几种方式</h4><p><strong>1. Activity/View#onWindowFocusChanged</strong><br>注意，此方法伴随着Activity的生命周期会被多次回调，具体来说，当Activity得到焦点和失去焦点时会被回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasWindowFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasWindowFocus);</span><br><span class="line">    <span class="keyword">if</span> (hasWindowFocus) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. View#post(Runnable)</strong><br>使用post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable，View也初始化好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3. ViewTreeObserver#onGlobalLayoutListener</strong><br><code>ViewTreeObserver#onGlobalLayoutListener</code>接口会在View树的状态发生改变或者View树内部View可见性发生改变时回调。需要注意的是，伴随着View树的状态改变，此接口会被多次回调，因此可以在适当的时候取消监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ViewTreeObserver observer = view.getViewTreeObserver();</span><br><span class="line">observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        view.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int</span> width = view.getMeasuredWidth();</span><br><span class="line">        <span class="keyword">int</span> height = view.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>4. View#measure</strong><br>可以手动对View进行measure操作来获取View的宽高。但是此方法比较复杂，且有局限性。但在某些情景下（比如，自定义ViewGroup，需要事先获取子View的宽高）非常适用了。</p><h3 id="2-layout过程"><a href="#2-layout过程" class="headerlink" title="2. layout过程"></a>2. layout过程</h3><p>Layout过程比Measure过程简单多了，ViewGroup的位置被确定后，会在onLayout中遍历所有的子元素并调用其layout方法，在layout方法又会调用onLayout方法。layout方法确定View本身的位置，onLayout方法会确定所有子元素的位置。</p><h4 id="3-2-1-View的layout过程"><a href="#3-2-1-View的layout过程" class="headerlink" title="3.2.1 View的layout过程"></a>3.2.1 View的layout过程</h4><p>View的layout过程非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">new</span> RoundScrollbarRenderer(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoundScrollbarRenderer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于View来说，最终都会通过<code>setFrame</code>方法来设定View的四个位置参数，这些参数一旦确定，View在父容器中的位置也就确定了。然后会调用<code>onLayout</code>方法，此方法会让父容器用来确定子元素位置，在View和ViewGroup中都是一个空实现，在各个ViewGroup的子类中会实现。最后，如果View设置有<code>OnLayoutChangeListener</code>监听器，会回调这些监听器的方法。 下面是<code>setFrame</code>的部分代码，这里我们看到有对四个位置参数的赋值操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mLeft &#x3D; left;</span><br><span class="line">mTop &#x3D; top;</span><br><span class="line">mRight &#x3D; right;</span><br><span class="line">mBottom &#x3D; bottom;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-ViewGroup的layout过程"><a href="#3-2-2-ViewGroup的layout过程" class="headerlink" title="3.2.2 ViewGroup的layout过程"></a>3.2.2 ViewGroup的layout过程</h4><p>ViewGroup本身的layout过程调用的是<code>super.layout</code>方法，不同的是ViewGroup还要对子元素进行layout操作。但是由于ViewGroup是一个抽象类，所以<code>onLayout</code>在ViewGroup中是一个空实现。我们这里看LinearLayout的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> childTop;</span><br><span class="line">    <span class="keyword">int</span> childLeft;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Where right end of child should go</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</span><br><span class="line">    <span class="keyword">int</span> childRight = width - mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Space available for child</span></span><br><span class="line">    <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (majorGravity) &#123;</span><br><span class="line">       <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">           <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">           childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">       <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">           childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           childTop = mPaddingTop;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childTop += measureNullChild(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                    (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                gravity = minorGravity;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                            + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                childTop += mDividerHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            childTop += lp.topMargin;</span><br><span class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                    childWidth, childHeight);</span><br><span class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是只看竖直方向的<code>layoutVertical</code>方法，这个方法逻辑还是很清楚的。它会对所有子元素调用<code>setChildFrame</code>方法，其中childTop会不断累加，这就意味着后面的元素被放置在靠下的位置。并且<code>setFrame</code>中传入的width、height两个参数就是这个子元素的测量宽高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br></pre></td></tr></table></figure><p>至于<code>setChildFrame</code>方法，它仅仅是调用子元素的<code>layout</code>方法。这样layout操作就会传递到子元素中，子元素会继续这么执行，一直到完成整个View树的layout过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;        </span><br><span class="line">    child.layout(left, top, left + width, top + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-draw过程"><a href="#3-3-draw过程" class="headerlink" title="3.3 draw过程"></a>3.3 draw过程</h3><p>draw过程更简单，我们看下<code>View#draw</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">     * in the appropriate order:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1. Draw the background</span></span><br><span class="line"><span class="comment">     *      2. If necessary, save the canvas&#x27; layers to prepare for fading</span></span><br><span class="line"><span class="comment">     *      3. Draw view&#x27;s content</span></span><br><span class="line"><span class="comment">     *      4. Draw children</span></span><br><span class="line"><span class="comment">     *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">     *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we&#x27;re done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Here we do the full fledged routine...</span></span><br><span class="line"><span class="comment">     * (this is an uncommon case where speed matters less,</span></span><br><span class="line"><span class="comment">     * this is why we repeat some of the tests that have been</span></span><br><span class="line"><span class="comment">     * done above)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> drawTop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawBottom = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawLeft = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> topFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> bottomFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> leftFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> rightFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2, save the canvas&#x27; layers</span></span><br><span class="line">    <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = mScrollX + paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    <span class="keyword">int</span> bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>) fadeHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip the fade length if top and bottom fades overlap</span></span><br><span class="line">    <span class="comment">// overlapping fades produce odd-looking artifacts</span></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also clip horizontal fades if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        bottomFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        rightFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> solidColor = getSolidColor();</span><br><span class="line">    <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较长，但是注释非常清楚，View的绘制过程遵循以下6步：</p><ol><li>绘制背景 <code>drawBackground(canvas)</code> -&gt; <code>background.draw(canvas);</code></li><li>如果必要，为滚动的fading效果保存图层</li><li>绘制自己 <code>onDraw(canvas)</code></li><li>绘制children <code>dispatchDraw(canvas)</code></li><li>如果必要，绘制滚动的fading效果并恢复图层</li><li>绘制装饰（比如foreground、scrollbars）<code>onDrawForeground(canvas)</code></li></ol><p>其中，如果View本身是透明的，则不需要绘制背景以及自身，所以跳过了1、3两步；其次，如果View本身不处于滑动状态，则不需要绘制滑动状态的fading效果，所以跳过2、5两步。</p><p><code>onDraw</code>方法在View是一个空实现，供具体的View来实现draw效果；ViewGroup也更加不会实现该方法，但具体ViewGroup子类会根据自身需要进行重写该方法（比如LinearLayout）。<br><code>dispatchDraw</code>方法在View内部也是一个空实现，因为其没有children，ViewGroup会重写该方法，ViewGroup子类不会重写该方法。</p><p><strong>注意：View有一个特殊的方法</strong><code>setWillNotDraw</code>。<strong>如果View不需要绘制任何内容，那么可以设置这个标记为true，系统会进行相应的优化。默认情况下，View没有开启这个标记位，而ViewGroup会默认开启。</strong> 所以，当我们的自定义控件继承至ViewGroup并且本身需要通过<code>onDraw</code>来绘制内容时，需要关闭WILL_NOT_DRAW标记位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If this view doesn&#x27;t do any drawing on its own, set this flag to</span></span><br><span class="line"><span class="comment"> * allow further optimizations. By default, this flag is not set on</span></span><br><span class="line"><span class="comment"> * View, but could be set on some View subclasses such as ViewGroup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Typically, if you override &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125;</span></span><br><span class="line"><span class="comment"> * you should clear this flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> willNotDraw whether or not this View draw on its own</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-View刷新重绘"><a href="#4-View刷新重绘" class="headerlink" title="4. View刷新重绘"></a>4. View刷新重绘</h3><p>View重绘和更新可以使用<code>invalidate()</code>和<code>requestLayout()</code>方法，其主要区别如下：</p><ul><li><code>invalidate()</code>方法只会执行onDraw方法</li><li><code>requestLayout()</code>只会执行onMeasure方法和onLayout方法，并不会执行onDraw方法</li></ul><p>所以当我们进行View更新时，若仅View的显示内容发生改变且新显示内容不影响View的大小、位置，则只需调用<code>invalidate()</code>方法；若View宽高、位置发生改变且显示内容不变，只需调用<code>requestLayout()</code>方法；若两者均发生改变，则需调用两者，按照View的绘制流程，推荐先调用<code>requestLayout()</code>方法再调用<code>invalidate()</code>方法。</p><p>与<code>invalidate()</code>方法类似的还有一个<code>postInvalidate()</code>，两者作用都是刷新View，区别在于：</p><ul><li><code>invalidate</code>方法用于UI线程中重新刷新View</li><li><code>postInvalidate</code>方法用于非UI线程中重新刷新View，这里借助了<code>ViewRootHandler</code>来达成目的</li></ul><p><code>ViewRootHandler</code>看着比较陌生，其实我们经常接触到。比如我们调用<code>View.post(Runnable)</code>方法，处理Runnable的就是这个<code>ViewRootHandler</code>了。</p><h3 id="5-自定义View"><a href="#5-自定义View" class="headerlink" title="5. 自定义View"></a>5. 自定义View</h3><h4 id="5-1-自定义View的分类"><a href="#5-1-自定义View的分类" class="headerlink" title="5.1 自定义View的分类"></a>5.1 自定义View的分类</h4><p>自定义View大致可以分为四类：</p><ol><li>继承View重写onDraw方法<br>此方法主要用于实现一些不方便通过组合控件的方式来实现的不规则的效果。很显然，这只能通过<code>onDraw</code>绘制实现。<strong>采用这种方式需要支持wrap_content，且padding也需要处理。</strong></li><li>继承ViewGroup重写onMeasure、onLayout<br>这种方式主要实现组合控件的自定义布局。<strong>需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局。</strong></li><li>继承特定的View<br>此方法一般用于拓展某种已有的View功能，不需要自己支持wrap_content以及padding。</li><li>继承特定的ViewGroup<br>一般用来实现组合控件。采用这种方式不需要自己处理测量和布局两个过程。</li></ol><h4 id="5-2-自定义View注意事项"><a href="#5-2-自定义View注意事项" class="headerlink" title="5.2 自定义View注意事项"></a>5.2 自定义View注意事项</h4><ol><li>让View支持wrap_content<br>直接继承View或ViewGroup的控件，如果不在<code>onMeasure</code>对wrap_content特殊处理，那么wrap_content无法正常使用。</li><li>如有必要，让View支持padding<br>直接继承View的控件，如果不在draw方法中处理paidding，那么padding属性无法起作用。直接继承ViewGroup的控件需要在<code>onMeasure</code>和<code>onLayout</code>中考虑自身的padding和子元素的margin，不然导致失效。</li><li>如要需要在View中使用Handler，用<code>post(Runnable)</code>方法代替</li><li>View中如果有线程或者动画，需要在适当的时候停止<br>如果有线程或者动画需要停止时，可以在<code>onDetachedFromWindow</code>中停止。当包含View的Activity退出或者当前View被remove时，View的此方法会回调。与此方法对应的是<code>onAttachedFromWindow</code>。当包含此View的Activity启动时会回调。同时，当View变得不可见时，我们也需要停止，否则有可能会造成内存泄露。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;View的工作流程指measure、layout、draw三大流程，即测量、布局和绘制。其中，measure确定View的测量宽高，layout确定View的最终宽高和四个顶点的位置，而draw则将View绘制到屏幕上。&lt;/p&gt;
&lt;h3 id=&quot;1-measure过程&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://blog.xusheng.online/categories/Android/"/>
    
    
      <category term="View" scheme="https://blog.xusheng.online/tags/View/"/>
    
  </entry>
  
</feed>

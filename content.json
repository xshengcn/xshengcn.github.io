{"meta":{"title":"X Blog","subtitle":"","description":"","author":"Hsum","url":"https://blog.xusheng.online","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-09-13T12:40:43.718Z","updated":"2020-09-13T12:40:43.718Z","comments":false,"path":"/404.html","permalink":"https://blog.xusheng.online/404.html","excerpt":"","text":""},{"title":"分类","date":"1969-12-31T16:00:00.000Z","updated":"2020-09-13T12:40:43.740Z","comments":false,"path":"categories/index.html","permalink":"https://blog.xusheng.online/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"1969-12-31T16:00:00.000Z","updated":"2020-09-13T12:40:43.741Z","comments":false,"path":"tags/index.html","permalink":"https://blog.xusheng.online/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-09-13T12:40:43.740Z","updated":"2020-09-13T12:40:43.740Z","comments":false,"path":"about/index.html","permalink":"https://blog.xusheng.online/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"Jetpack App Startup","slug":"Jetpack-App-Startup","date":"2020-07-19T11:34:05.000Z","updated":"2020-09-13T12:40:43.724Z","comments":true,"path":"2020/07/19/Jetpack-App-Startup/","link":"","permalink":"https://blog.xusheng.online/2020/07/19/Jetpack-App-Startup/","excerpt":"","text":"App Startup 是Jetpack套件新增的功能。它为应用程序提供类一种更加高效的方式来初始化组件的方式。 下面我们就来了解一下App Startup的使用方法和原理。 1. 开始使用导入依赖 为了使用App Startup，我们需要将它的依赖添加到build.gradle中 1implementation &quot;androidx.startup:startup-runtime:1.0.0-alpha03&quot; 初始化组件 初始化组件时需要我们自定义实现Initializer： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 初始化组件Aclass AAAInitializer : Initializer&lt;Int&gt; &#123; companion object &#123; private const val TAG = &quot;AAAInitializer&quot; &#125; override fun create(context: Context): Int &#123; Log.d(TAG, &quot;create: &quot;) return 0 &#125; override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123; return listOf(BBBInitializer::class.java) &#125;&#125;// 初始化组件Bclass BBBInitializer : Initializer&lt;Int&gt; &#123; companion object &#123; private const val TAG = &quot;BBBInitializer&quot; &#125; override fun create(context: Context): Int &#123; Log.d(TAG, &quot;create: &quot;) return 0 &#125; override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123; return listOf(CCCInitializer::class.java) &#125;&#125;// 初始化组件Cclass CCCInitializer : Initializer&lt;Int&gt; &#123; companion object &#123; private const val TAG = &quot;CCCInitializer&quot; &#125; override fun create(context: Context): Int &#123; Log.d(TAG, &quot;create: &quot;) return 0 &#125; override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123; return emptyList() &#125;&#125; 定义时Initializer，必须实现2种方法： create(context)：提供ApplicationContext并初始化组件。 dependencies()：返回在初始化当前依赖项之前需要初始化的依赖项列表。 设置Initializer在应用启动时运行的顺序。如果AAAInitializer依赖BBBInitializer，并且BBBInitializer依赖CCCInitializer，那么CCCInitializer首先运行，其次是BBBInitializer，最后是AAAInitializer。 注册Initializer 对于要在应用程序启动时自动初始化的组件，需要在AndroidManifest文件中的&lt;meta-data&gt;条目中对其Initializer进行声明。 123456789101112131415&lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;meta-data android:name=&quot;com.github.demo.AAAInitializer&quot; android:value=&quot;androidx.startup&quot; /&gt; &lt;meta-data android:name=&quot;com.github.demo.BBBInitializer&quot; android:value=&quot;androidx.startup&quot; /&gt; &lt;meta-data android:name=&quot;com.github.demo.CCCInitializer&quot; android:value=&quot;androidx.startup&quot; /&gt;&lt;/provider&gt; App Startup能够通过读取AndroidManifest文件中InitializationProvider条目下的&lt;meta-data&gt;条目来自动检测组件，以在应用程序加载后进行初始化。 在注册时只要声明最高级的Initializer就可以。 应用程序运行后的输出如下： 123D&#x2F;CCCInitializer: create: D&#x2F;BBBInitializer: create: D&#x2F;AAAInitializer: create: 延迟初始化 当我们应用的组件不需要在启动时进行初始化，我们可以将&lt;meta-data&gt;指定的Initializer移除。还可以使用tools:node=&quot;remove&quot;来确保合并工具在合并Manifest文件时从其它Manifest文件中删除。 123456789&lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;meta-data android:name=&quot;com.github.demo.DDDInitializer&quot; tools:node=&quot;remove&quot; /&gt;&lt;/provider&gt; 当我们需要手动初始化时可以这样调用： 1AppInitializer.getInstance(applicationContext).initializeComponent(DDDInitializer::class.java) 2. 工作原理InitializationProvider 在查看InitializationProvider之前，我们先自定义一个ContentProvider，来看看它是怎么启动的： 12345678910111213141516171819202122class App :Application() &#123; override fun attachBaseContext(base: Context?) &#123; super.attachBaseContext(base) Log.d(&quot;AppStartup&quot;, &quot;Application attachBaseContext: &quot;) &#125; override fun onCreate() &#123; super.onCreate() Log.d(&quot;AppStartup&quot;, &quot;Application onCreate:&quot;) &#125;&#125;class CustomProvider : ContentProvider() &#123; override fun onCreate(): Boolean &#123; Log.d(&quot;AppStartup&quot;, &quot;Provider onCreate: &quot;) return true &#125; ...&#125; 启动应用之后日志输入如下： 123D&#x2F;AppStartup: Application attachBaseContext: D&#x2F;AppStartup: Provider onCreate: D&#x2F;AppStartup: Application onCreate: 可以发现ContentProvider#onCreate()在Application#onCreate()之前运行。这是因为这个样，很多的第三方库已经不需要我们去手动调用初始化了，比如Leakcanary等。 InitializationProvider就是是App Startup的初始化的入口，我们看看它是如何调用Initializer来初始化的： 12345678910111213public final class InitializationProvider extends ContentProvider &#123; @Override public boolean onCreate() &#123; Context context = getContext(); if (context != null) &#123; // 使用AppInitializer来发现和初始化Initializer AppInitializer.getInstance(context).discoverAndInitialize(); &#125; else &#123; throw new StartupException(&quot;Context cannot be null&quot;); &#125; return true; &#125;&#125; 可以看到，这里只是调用了AppInitializer中discoverAndInitialize的方法，然后就直接返回了。 那我们跟着进入discoverAndInitialize()： AppInitializer discoverAndInitialize() 123456789101112131415161718192021222324252627282930313233343536final Set&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; mDiscovered; // 用来保存已经发现的Initializervoid discoverAndInitialize() &#123; ... ComponentName provider = new ComponentName(mContext.getPackageName(), InitializationProvider.class.getName()); // 获取InitializationProvider的信息 ProviderInfo providerInfo = mContext.getPackageManager() .getProviderInfo(provider, GET_META_DATA); // 获取InitializationProvider的&lt;meta-data&gt;节点 // 它将我们传入的android:name作为key，android:value作为value Bundle metadata = providerInfo.metaData; // 这个字符串就是“androidx_startup” String startup = mContext.getString(R.string.androidx_startup); if (metadata != null) &#123; // 如果Provider中有&lt;meta-data&gt;节点 Set&lt;Class&lt;?&gt;&gt; initializing = new HashSet&lt;&gt;(); Set&lt;String&gt; keys = metadata.keySet(); // 遍历key for (String key : keys) &#123; String value = metadata.getString(key, null); if (startup.equals(value)) &#123; // 判断value Class&lt;?&gt; clazz = Class.forName(key); // 获取类对象 if (Initializer.class.isAssignableFrom(clazz)) &#123; //判断Initializer是不是clazz的父类 Class&lt;? extends Initializer&lt;?&gt;&gt; component = (Class&lt;? extends Initializer&lt;?&gt;&gt;) clazz; mDiscovered.add(component); // 添加到mDiscovered中 if (StartupLogger.DEBUG) &#123; StartupLogger.i(String.format(&quot;Discovered %s&quot;, key)); &#125; // 去初始化 doInitialize(component, initializing); &#125; &#125; &#125; &#125; ... &#125; 在discoverAndInitialize被调用的时候，它先获取InitializationProvider的metaData，然后将中的Initializer存入到已经mDiscovered中，最有调用doInitialize()去执行Initializer的相关操作。 doInitialize() 这里我们就可以看到Initializer的相关方法被执行了： 12345678910111213141516171819202122232425262728293031323334353637383940414243 final Map&lt;Class&lt;?&gt;, Object&gt; mInitialized; // 用来保存已经初始化的组件&lt;T&gt; T doInitialize( @NonNull Class&lt;? extends Initializer&lt;?&gt;&gt; component, @NonNull Set&lt;Class&lt;?&gt;&gt; initializing) &#123; ... Object result; // 如果该组件已经初始化，直接从mInitialized获取 if (!mInitialized.containsKey(component)) &#123; initializing.add(component); try &#123; // 通过反射创建Initializer对象 Object instance = component.getDeclaredConstructor().newInstance(); Initializer&lt;?&gt; initializer = (Initializer&lt;?&gt;) instance; List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies = initializer.dependencies(); // 调用dependencies()获取依赖 // 如果当前Initializer依赖其它的Initializer // 那么先去进行其它Initializer初始化 // 这就是为什么在manifest中只要注册优先级最高的Initializer的原因 if (!dependencies.isEmpty()) &#123; for (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123; if (!mInitialized.containsKey(clazz)) &#123; // 递归实现依赖的Initializer doInitialize(clazz, initializing); &#125; &#125; &#125; // 调用create()方法初始化我们的组件 result = initializer.create(mContext); initializing.remove(component); mInitialized.put(component, result); &#125; catch (Throwable throwable) &#123; throw new StartupException(throwable); &#125; &#125; else &#123; result = mInitialized.get(component); &#125; return (T) result; ... &#125; &#125; 上面的代码可以明显的看到Initializer对象是通过反射来创建的。当Initializer对象创建好之后就调用dependencies()来看看它依赖哪些组件，如果有依赖那就创建它依赖的Initializer，如果没有那就执行initializer.create()来初始化我们的组件。 这里是App Start的完整流程了。 如果当我们手动调用Initializer进行初始化的时候，它也会去执行doInitialize： 123public &lt;T&gt; T initializeComponent(@NonNull Class&lt;? extends Initializer&lt;T&gt;&gt; component) &#123; return doInitialize(component, new HashSet&lt;Class&lt;?&gt;&gt;());&#125;","categories":[],"tags":[{"name":"Startup","slug":"Startup","permalink":"https://blog.xusheng.online/tags/Startup/"}]},{"title":"kotlin-函数字面值","slug":"kotlin-函数字面值","date":"2020-07-06T16:58:28.000Z","updated":"2020-09-13T12:40:43.731Z","comments":true,"path":"2020/07/07/kotlin-函数字面值/","link":"","permalink":"https://blog.xusheng.online/2020/07/07/kotlin-%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E5%80%BC/","excerpt":"","text":"1. 背景androidx.core:core-ktx:1.1.0这个包大大提高了我们开发的效率，比如之前使用SharedPreferences的时候需要这样： 12345val editor = sharedPreferences.edit() editor.putString(&quot;name&quot;, &quot;张三&quot;) editor.putInt(&quot;age&quot;, 18) editor.putString(&quot;avatar&quot;, &quot;http://xxxx&quot;) editor.apply() 而且一旦忘记使用apply()或者commit()，那就白提交了。ktx这个包出现后，我们的代码就变成这样了: 12345sharedPreferences.edit &#123; putString(&quot;name&quot;, &quot;张三&quot;) putInt(&quot;age&quot;, 18) putString(&quot;avatar&quot;, &quot;http://xxxx&quot;)&#125; 对比上面的是不是简单了很多？ 虽然知道了用法，但是我们也要看看它是怎么实现的，打开它的源码： 12345678910111213@SuppressLint(&quot;ApplySharedPref&quot;)inline fun SharedPreferences.edit( commit: Boolean = false, action: SharedPreferences.Editor.() -&gt; Unit) &#123; val editor = edit() action(editor) if (commit) &#123; editor.commit() &#125; else &#123; editor.apply() &#125;&#125; 代码也很简单，但是action: SharedPreferences.Editor.() -&gt; Unit是什么东西？我们之前传递函数时不都是这样写func: () -&gt; Unit这样的吗？ 2. 函数字面值参考: What does .() mean in Kotlin? 和 Function literals with receiver。 什么叫函数字面值 Function types with receiver, such as A.(B) -&gt; C, can be instantiated with a special form of function literals – function literals with receiver. 带有接收者的函数类型，例如 A.(B) -&gt; C，可以用特殊形式的函数字面值实例化—— 带有接收者的函数字面值。 As said above, Kotlin provides the ability to call an instance of a function type with receiver providing the receiver object. 如上所述，Kotlin 提供了调用带有接收者（提供接收者对象）的函数类型实例的能力。 函数字面值，有的也叫函数字面量(function literal，可以参考Scala函数字面量)。 函数字面值（量）就是一段函数文本，可以当作参数传递。函数字面值在默认情况下没有名称，但是可以通过将它们绑定到一个变量来给它一个名字。 在 Kotlin 中，let、run，apply等都是一种 函数字面值。 A.(B) -&gt; C与(A) -&gt; B的区别 Inside the body of the function literal, the receiver object passed to a call becomes an implicit this, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a this expression. 在这样的函数字面值内部，传给调用的接收者对象成为隐式的this，以便访问接收者对象的成员而无需任何额外的限定符，亦可使用 this 表达式 访问接收者对象。 对比ktx中的方法，如果我们没有使用函数字面值，而是使用(A) -&gt; B这中函数类型的话可以写成这样： 12345678910111213@SuppressLint(&quot;ApplySharedPref&quot;)fun SharedPreferences.edit( commit: Boolean = false, action: (SharedPreferences.Editor) -&gt; Unit) &#123; val editor = edit() action(editor) if (commit) &#123; editor.commit() &#125; else &#123; editor.apply() &#125;&#125; 再来看看怎么调用它： 12345sharedPreferences.edit &#123; it.putString(&quot;name&quot;, &quot;张三&quot;) it.putInt(&quot;age&quot;, 18) it.putString(&quot;avatar&quot;, &quot;http://xxxx&quot;)&#125; 这里的this调用的就不是SharedPreferences.Editor了，这时候就需要使用默认的it来访问SharedPreferences.Editor里面的方法了。这种场景下使用相比ktx里的实现显得有些丑陋了。 总结一下A.(B) -&gt; C与(A) -&gt; B的区别就是：**A.(B) -&gt; C里的this代表的是自身实例，(A) -&gt; B里的this代表的是外部类的实例**。 3. 函数字面值的使用TextWatcher 如果我们想要监听TextView内容的变化一般都会这样写： 12345678910textView.addTextChangedListener(object : TextWatcher &#123; override fun afterTextChanged(s: Editable?) &#123; &#125; override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; &#125; &#125;) 看看如何使用函数字面值改造它： 12345678910111213141516171819202122232425262728293031323334inline fun TextView.textWatcher(init: TextWatcherAdapter.() -&gt; Unit) = addTextChangedListener(TextWatcherAdapter().apply(init))class TextWatcherAdapter : TextWatcher &#123; private var _beforeChanged: ((CharSequence?, Int, Int, Int) -&gt; Unit)? = null private var _onChanged: ((CharSequence?, Int, Int, Int) -&gt; Unit)? = null private var _afterChanged: ((Editable?) -&gt; Unit)? = null override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123; _beforeChanged?.invoke(s, start, count, after) &#125; override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123; _onChanged?.invoke(s, start, before, count) &#125; override fun afterTextChanged(s: Editable?) &#123; _afterChanged?.invoke(s) &#125; fun beforeChanged(listener: (CharSequence?, Int, Int, Int) -&gt; Unit) &#123; _beforeChanged = listener &#125; fun onChanged(listener: (CharSequence?, Int, Int, Int) -&gt; Unit) &#123; _onChanged = listener &#125; fun afterChanged(listener: (Editable?) -&gt; Unit) &#123; _afterChanged = listener &#125;&#125; 先来看看怎么使用，然后在解释上面的代码： 12345textView.textWatcher &#123; afterChanged &#123; Log.d(TAG, &quot;onCreate: $it&quot;) &#125;&#125; 假如我们只需要监视它修改后的改动，直接在方法体里调用afterChanged就行了。如果有需要，还可以继续在textWatcher方法体里使用beforeChanged和onChanged。 现在就来解释一下上面的那个方法： TextWatcherAdapter是继承自TextWatcher，所以addTextChangedListener(watcher)并没有什么不同。 TextWatcherAdapter().apply(init)方法返回的就是TextWatcherAdapter本身，因为我们要使用TextWatcherAdapter里面的方法所以使用了函数字面值。开始的时候说了apply是一种函数字面值，现在我们看一下apply()： 123456public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block()&#125; 不用管contract是什么，我们现在可以知道apply的作用是：以“ this”值作为接收者调用指定的函数block并返回“ this”值。而TextWatcherAdapter().apply(init)等价于: 123TextWatcherAdapter().apply&#123; init()&#125; 这就是我们熟悉的apply写法了。 为什么要定义_onChanged等变量然后添加onChanged()这些方法呢？ 因为在textView.textWatcher&#123;&#125;方法体里面使用afterTextChanged的话，我们只是调用它的方法。而我们需要的是监听它的回调，所以当onTextChanged()被调用的时候我们需要回调到textChanged中才能去响应监听。 接下来再来看看我是怎样改进其它的模块。 RuntimePermission 我们项目中用到的动态权限申请框架是florent37/RuntimePermission。它原始的用法也很简单： 12345678val permission = RuntimePermission(this)permission.request(Manifest.permission.CAMERA).ask()permission.onAccepted &#123;&#125;permission.onDenied &#123; &#125; 其实它也有kotlin版的，方法比这个更简单。 我们先来改造它： 123456789101112131415161718192021222324252627282930inline fun FragmentActivity.askPermissions(vararg permission: String, func: RuntimePermissionHelper.() -&gt; Unit) &#123; return RuntimePermissionHelper(this).apply(func).ask(permission.toList())&#125;class RuntimePermissionHelper(activity: FragmentActivity) &#123; private val runtimePermission = RuntimePermission(activity) fun onAccepted(func: (() -&gt; Unit)? = null) &#123; runtimePermission.onAccepted &#123; func?.invoke() &#125; &#125; fun onDenied(func: (() -&gt; Unit)? = null) &#123; runtimePermission.onDenied &#123; func?.invoke() &#125; &#125; fun onForeverDenied(func: (() -&gt; Unit)? = null) &#123; runtimePermission.onForeverDenied &#123; func?.invoke() &#125; &#125; fun onResponse(func: (() -&gt; Unit)? = null) &#123; runtimePermission.onResponse &#123; func?.invoke() &#125; &#125; fun ask(permissions: List&lt;String&gt;) &#123; runtimePermission.request(permissions).ask() &#125;&#125; 然后就可以在Activity中这样使用它: 12345678askPermissions(Manifest.permission.CAMERA) &#123; onAccepted &#123; // do accepted &#125; onDenied &#123; // do denied &#125;&#125; 到此，函数字面值基本已经被我们了解了。使用好函数字面值不仅能是代码函数减少，更能加强代码的可读性。","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.xusheng.online/tags/Kotlin/"}]},{"title":"kotlin Coroutines","slug":"kotlin协程","date":"2020-06-26T06:42:36.000Z","updated":"2020-09-13T15:45:03.024Z","comments":true,"path":"2020/06/26/kotlin协程/","link":"","permalink":"https://blog.xusheng.online/2020/06/26/kotlin%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"Coroutines一般我们都会成协程，单看这个翻译我们很难去理解它的意思。Coroutines其实是由两个单词组合而成的，分别是cooperation和routine。cooperation是指合作，routine指的是例行程序、常规作业，所以我们可以把它翻译为合作的例行程序。 routine在这里指的是程序中的方法，所以说这种将方法协同其它方法来共同作业的方式就叫做Coroutines。 Coroutines允许方法暂停执行(suspend)后再恢复执行(resume)，而被暂停的方法状态运行被保留，恢复后再以暂停前的状态继续执行。 1. 开始使用kotlin coroutines不包含在stdlib包中，需要我们单独引入： 1implementation &#x27;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7&#x27; 我们先从一个简单的例子开始，使用界面来展示一个获取验证码倒计时。 先来看看没有使用Coroutines之前我们的写法： 123456789101112131415val countDown = object :AsyncTask&lt;Void, Int, Void&gt;() &#123; override fun doInBackground(vararg params: Void?): Void? &#123; for (i in 60 downTo 0) &#123; publishProgress(i) Thread.sleep(1_000) &#125; return null &#125; override fun onProgressUpdate(vararg values: Int?) &#123; super.onProgressUpdate(*values) textView.text = &quot;$&#123;values.elementAtOrNull(0)&#125;秒&quot; &#125;&#125;countDown.execute() 再来对比一下使用Coroutines： 123456GlobalScope.launch(Dispatchers.Main) &#123; for(i in 60 downTo 0) &#123; textView.text = &quot;$&#123;i&#125;秒&quot; delay(1_000) &#125;&#125; 是不是相比使用AsyncTask简单的多(另外，Android中有专门的CountDownTimer来实现计时器)，下面我们来看看它们的具体含义。 2. ScopeScope指的是Coroutines的作用范围。 GlobalScope继承自CoroutineScope，它的作用范围伴随着整个应用程序的生命周期。： 123public interface CoroutineScope &#123; public val coroutineContext: CoroutineContext&#125; 当然我们在实际开发的时候不会经常去使用GlobalScope，而是按照Activity或者Fragment的生命周期来使用自定义的CoroutineScope，当生命周期完成的时候取消GlobalScope里的运行方法： 12345678910111213141516171819202122232425class MainActivity : AppCompatActivity(), CoroutineScope &#123; var countDownJob: Job? = null override val coroutineContext: CoroutineContext get() = EmptyCoroutineContext override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) countDownJob = launch &#123; for (i in 60 downTo 0) &#123; textView.text = &quot;$&#123;i&#125;秒&quot; delay(1_000) &#125; &#125; &#125; override fun onDestroy() &#123; super.onDestroy() countDownJob?.cancel() &#125;&#125; 下面我们来介绍一下Job和CoroutineContext。 3. JobJob从字面意思来看，就是指工作。 从Scope的角度来说，Scope可以管理它作用域下面所有的方法，当Scope取消的时候就会取消掉Scope中所有在执行的方法。假如我们现在有一个上传和一个下载的方法同时在Scope中运行，当我们要取消下载的时候就不能使用Scope.cancel()，而是轮到Job出场了。 我们可以看到，Scope使用launch扩展方法的时候返回的就是一个Job。所以Job就是单个Coroutines的生命周期。 123456789101112 wait children+-----+ start +--------+ complete +-------------+ finish +-----------+| New | -----&gt; | Active | ---------&gt; | Completing | -------&gt; | Completed |+-----+ +--------+ +-------------+ +-----------+ | cancel &#x2F; fail | | +----------------+ | | V V +------------+ finish +-----------+ | Cancelling | --------------------------------&gt; | Cancelled | +------------+ +-----------+ 来自Job类的注解 4. CoroutineContextCoroutineContext指的就是Coroutines的上下文。 协程中的代码是在CoroutineContext中执行的，CoroutineContext为我们提供了异步运行/执行代码所需的执行环境。 CoroutineContext是各种不同元素的集合，其中主元素是协程中的 Job。对于Scope 、CoroutineContext 、Job 三者间的关系，简单的来说就是：Scope 包含了CoroutinContext，而CoroutineContext 里Element就是Job。 想要对CoroutineContext有更多了解，可以参考Coroutine Context and Scope。 5. DispatcherDispatcher就是Coroutines中的调度器。它其实就是Kotlin为我们封装好的CoroutineContext。 在Kotlinx coroutine中有四种Dispatcher分别是： Dispatchers.Main：就是主线程的包装，在Android 需要操作到UI 线程 通常会用它 Dispatchers.Default：默认的Dispatcher，将协程执行限制在共享的后台线程池中 Dispatchers.IO：基于Default 去加强的Dispatchers。它跟Default 最本质的区别在于，它开的线程数量会比较多，以Default 来说是N ( JVM 给的数量，个平台机子会不同)，而IO 则会给上64 个，如果JVM 给更多，那就更多那样。 Dispatchers.Unconfined：不局限于任何特定线程的Dispatcher，通常他会跑在执行该Coroutines 的线程 上，但是在suspend后被回复可能会跑到另一个线程 上。 像是MainScope 的CoroutineContext 是supervisorJob() + Dispatcher.Main，所以MainScop 实质上是提供一个主线程 为context 的Scope。 在Android 上Dispatcher.Main 会将launch 的程序跑在UI 线程上，那Dispatcher.IO 则会将launch 的程序跑在worker 线程上，通常会用来跑耗时作业，其实就是用比较简易的方式决定Coroutines 执行的CoroutineContext。 6. Suspend这时候轮到Coroutines中最重要的suspend了，先来看一段代码： 123suspend fun fetchUser() = withContext (Dispatchers.IO) &#123; // fetch user from network&#125; withContext(Dispathcers.IO) 的意思就是要让这东西跑在Worker 线程上。 另外可以看到，这个方法 前面加了一个suspend ，表示执行到这个function 时是可以被suspend (暂停)的。 在Coroutines的代码块中，线程的代码在到达 suspend 函数的时候被掐断，接下来协程会从这个 suspend 函数开始继续往下执行，不过是在withContext指定的线程。在 suspend 函数执行完成之后，会根据传入的Dispatcher将线程切回到原来的线程。 suspend关键字 起到的并不是切换线程的作用，而是用于IDE的提示。所以fun 前面注记的suspend 必须要在coroutineScope 的launch 、runBlocking 内或者是其他的suspend method 才能够被使用。 7. 总结这篇主要是记录Kotlin Coroutines的相关介绍。如需深入了解可以查看Android 上的 Kotlin 协程和Coroutines for asynchronous programming and more等官方文档。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.xusheng.online/categories/Kotlin/"}],"tags":[{"name":"Coroutines","slug":"Coroutines","permalink":"https://blog.xusheng.online/tags/Coroutines/"}]},{"title":"Kotlin委托属性(Delegate)","slug":"Kotlin委托属性-Delegate","date":"2020-05-26T14:51:28.000Z","updated":"2020-09-13T12:40:43.727Z","comments":true,"path":"2020/05/26/Kotlin委托属性-Delegate/","link":"","permalink":"https://blog.xusheng.online/2020/05/26/Kotlin%E5%A7%94%E6%89%98%E5%B1%9E%E6%80%A7-Delegate/","excerpt":"","text":"使用Kotlin某些功能我们很容易编写简洁易读的代码。由于有了数据类(data class)，扩展函数(extensions)和委托属性(delegate)等，与Java类相比，Kotlin类通常更小而且更易阅读。 1. 基础委托只是一个提供属性值并处理其更改的类。这使我们可以将getter-setter逻辑从属性本身移动或委托到单独的类，从而使我们可以重用此逻辑。 假如我们想要一个始终为大写字符串的属性param，我们可以在它的属性设置器里进行下面的操作： 123456class UpperCaseDemo&#123; var param:String = &quot;&quot; set(value) &#123; field = value.toUpperCase() &#125;&#125; 如果对上面的语法感到困惑，请参考kotlin文档中的属性与字段。 假如我们要在其它的类中重用此功能该怎么办？这时候就轮到Delegate上场了： 12345678910class UpperCaseDelegate : ReadWriteProperty&lt;Any?, String&gt; &#123; private var upperCaseValue = &quot;&quot; override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return upperCaseValue &#125; override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; upperCaseValue = value.toUpperCase() &#125;&#125; Delegate只是具有两个方法的类：用于获取和设置属性的值。为了提供更多信息，它通过KProperty类的实例提供了它正在使用的属性，并通过提供了具有该属性的对象thisRef。下面我们将使用修改UpperCaseDemo： 123class UpperCaseDemo&#123; var param:String by UpperCaseDelegate()&#125; 这等效于： 12345678910class UpperCaseDemo &#123; private val delegate = UpperCaseDelegate() var param: String get() &#123; return delegate.getValue(this, this::param) &#125; set(value) &#123; delegate.setValue(this, this::param, value) &#125;&#125; ::param是一个运算符，它返回该属性的KProperty类的实例。 Delegate尽管非常的简单，但是它可能对我们开发人员有很大的帮助。因此，我们来编写一些帮助我们开发的一些Android实例。 2. 使用delegate简化操作我们经常会将一些参数传递给Fragment，通常类似这样： 123456789101112131415161718192021222324class DelegateFragment : Fragment() &#123; private var name: String? = null private var age: Int? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) arguments?.let &#123; args -&gt; name = args.getString(ARGS_NAME) age = args.getInt(ARGS_AGE) &#125; &#125; companion object &#123; private const val ARGS_NAME = &quot;name&quot; private const val ARGS_AGE = &quot;age&quot; fun newInstance(name: String, age: Int): DelegateFragment = DelegateFragment().apply &#123; arguments = Bundle().apply &#123; putString(ARGS_NAME, name) putInt(ARGS_AGE, age) &#125; &#125; &#125;&#125; 我们需要为每个属性编写相同的代码，如果有很多的属性可能会显得非常的混乱。我们下一步将使用属性委托来美化代码。 Fragment的参数存储在一个Bundle对象中，该对象具有用于放置不同类型的值。我们做一个扩展函数，尝试将任意类型的值放入Bundle中，如果不支持该类型则抛出异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061fun &lt;T : Any&gt; Bundle.put(key: String, value: T?) &#123; when (value) &#123; null -&gt; putString(key, null) is Boolean -&gt; putBoolean(key, value) is Byte -&gt; putByte(key, value) is Char -&gt; putChar(key, value) is Double -&gt; putDouble(key, value) is Float -&gt; putFloat(key, value) is Int -&gt; putInt(key, value) is Long -&gt; putLong(key, value) is Short -&gt; putShort(key, value) is Bundle -&gt; putBundle(key, value) is CharSequence -&gt; putCharSequence(key, value) is Parcelable -&gt; putParcelable(key, value) is BooleanArray -&gt; putBooleanArray(key, value) is ByteArray -&gt; putByteArray(key, value) is CharArray -&gt; putCharArray(key, value) is DoubleArray -&gt; putDoubleArray(key, value) is FloatArray -&gt; putFloatArray(key, value) is IntArray -&gt; putIntArray(key, value) is LongArray -&gt; putLongArray(key, value) is ShortArray -&gt; putShortArray(key, value) is Array&lt;*&gt; -&gt; &#123; val componentType = value::class.java.componentType!! @Suppress(&quot;UNCHECKED_CAST&quot;) // Checked by reflection. when &#123; Parcelable::class.java.isAssignableFrom(componentType) -&gt; &#123; putParcelableArray(key, value as Array&lt;Parcelable&gt;) &#125; String::class.java.isAssignableFrom(componentType) -&gt; &#123; putStringArray(key, value as Array&lt;String&gt;) &#125; CharSequence::class.java.isAssignableFrom(componentType) -&gt; &#123; putCharSequenceArray(key, value as Array&lt;CharSequence&gt;) &#125; Serializable::class.java.isAssignableFrom(componentType) -&gt; &#123; putSerializable(key, value) &#125; else -&gt; &#123; val valueType = componentType.canonicalName throw IllegalArgumentException( &quot;Illegal value array type $valueType for key \\&quot;$key\\&quot;&quot; ) &#125; &#125; &#125; is Serializable -&gt; putSerializable(key, value) else -&gt; &#123; if (Build.VERSION.SDK_INT &gt;= 18 &amp;&amp; value is IBinder) &#123; putBinder(key, value) &#125; else if (Build.VERSION.SDK_INT &gt;= 21 &amp;&amp; value is Size) &#123; putSize(key, value) &#125; else if (Build.VERSION.SDK_INT &gt;= 21 &amp;&amp; value is SizeF) &#123; putSizeF(key, value) &#125; else &#123; val valueType = value.javaClass.canonicalName throw IllegalArgumentException(&quot;Illegal value type $valueType for key \\&quot;$key\\&quot;&quot;) &#125; &#125; &#125;&#125; 然后创建Delegate： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class FragmentArgumentDelegate&lt;T : Any&gt; : ReadWriteProperty&lt;Fragment, T&gt; &#123; @Suppress(&quot;UNCHECKED_CAST&quot;) override fun getValue( thisRef: Fragment, property: KProperty&lt;*&gt; ): T &#123; val key = property.name return thisRef.arguments ?.get(key) as? T ?: throw IllegalStateException(&quot;Property $&#123;property.name&#125; could not be read&quot;) &#125; override fun setValue( thisRef: Fragment, property: KProperty&lt;*&gt;, value: T ) &#123; val args = thisRef.arguments ?: Bundle().also(thisRef::setArguments) val key = property.name args.put(key, value) &#125;&#125;// 当属性允许为空时class FragmentArgumentNullableDelegate&lt;T : Any&gt; : ReadWriteProperty&lt;Fragment, T?&gt; &#123; @Suppress(&quot;UNCHECKED_CAST&quot;) override fun getValue( thisRef: Fragment, property: KProperty&lt;*&gt; ): T? &#123; val key = property.name return thisRef.arguments?.get(key) as? T &#125; override fun setValue( thisRef: Fragment, property: KProperty&lt;*&gt;, value: T? ) &#123; val args = thisRef.arguments ?: Bundle().also(thisRef::setArguments) val key = property.name value?.let &#123; args.put(key, it) &#125; ?: args.remove(key) &#125;&#125; Delegate从Fragment的Arguments中读取属性，当属性的值发生改变时，Delegate将检索Fragment Argument，然后使用Bundle.put扩展函数将新值写入Arguments。 ReadWriteProperty是一个接受两个类型参数的接口。我们将第一个设置为Fragment，使该Delegate仅可用于Fragment内的属性。这使我们可以使用Fragment实例thisRef并管理其参数。ReadWriteProperty的第二个类型参数确定属性可以具有哪种类型的值。 接下来，我们创建一些扩展函数方便使用： 12345fun &lt;T : Any&gt; argument(): ReadWriteProperty&lt;Fragment, T&gt; = FragmentArgumentDelegate()fun &lt;T : Any&gt; argumentNullable(): ReadWriteProperty&lt;Fragment, T?&gt; = FragmentArgumentNullableDelegate() 最终我们就可以这样使用Delegate来传递args： 12345678910111213141516class DelegateFragment : Fragment() &#123; private var name: String by argument() private var age: Int? by argumentNullable() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125; companion object &#123; fun newInstance(name: String, age: Int): DelegateFragment = DelegateFragment().apply &#123; this.name = name this.age = age &#125; &#125;&#125; 这里的this.name = name并不是直接对对象赋值。可以查看编译后的字节码发现是通过delegate.setvalue()来管理的。 123456789101112131415161718192021222324252627 @NotNull public final DelegateFragment newInstance(@NotNull String name, int age) &#123; Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;); DelegateFragment var3 = new DelegateFragment(); boolean var4 = false; boolean var5 = false; int var7 = false; var3.setName(name); var3.setAge(age); return var3; &#125; private final String getName() &#123; return (String)this.name$delegate.getValue(this, $$delegatedProperties[0]);&#125;private final void setName(String var1) &#123; this.name$delegate.setValue(this, $$delegatedProperties[0], var1);&#125;private final Integer getAge() &#123; return (Integer)this.age$delegate.getValue(this, $$delegatedProperties[1]);&#125;private final void setAge(Integer var1) &#123; this.age$delegate.setValue(this, $$delegatedProperties[1], var1);&#125; 3. 结论Delegate的功能完全不止上面的实例，有到许多其他方法在应用程序中使用它们。例如自定义View、SharedPreferences等等。这里的目的是为了演示什么是强大的属性委托，以及可以实现什么。如果想要更进一步的了解，可以查阅文档Delegated Properties。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.xusheng.online/categories/Kotlin/"}],"tags":[{"name":"Delegate","slug":"Delegate","permalink":"https://blog.xusheng.online/tags/Delegate/"}]},{"title":"LeakCanary源码解析","slug":"LeakCanary源码解析","date":"2020-04-18T10:06:33.000Z","updated":"2020-09-13T12:40:43.728Z","comments":true,"path":"2020/04/18/LeakCanary源码解析/","link":"","permalink":"https://blog.xusheng.online/2020/04/18/LeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"LeakCanary是适用于Android的内存泄漏检测库。 本文基于LeakCanary最新2.2版本进行分析。 1. 开始使用要使用LeakCanary，只需要将leakcanary-android添加到项目的build.gradle中，无需在项目中修改代码。 1234dependencies &#123; &#x2F;&#x2F; debugImplementation because LeakCanary should only run in debug builds. debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.2&#39;&#125; 2. 源码分析2.1 LeakCanary初始化分析 LeakCanary为什么不需要修改项目中的代码就可以使用呢，它在何时进行初始化操作？ LeakCanary巧妙的利用了ContentProvider来进行初始化操作，ContentProvider的onCreate()方法会在Application的onCreate()方法之前被系统回调。所以只需要在AndroidManifest.xml中配置一下这个ContentProvider，然后在onCreate()方法中进行初始化即可。 AndroidManifest.xml 123456&lt;application&gt; &lt;provider android:name=&quot;leakcanary.internal.AppWatcherInstaller$MainProcess&quot; android:authorities=&quot;$&#123;applicationId&#125;.leakcanary-installer&quot; android:exported=&quot;false&quot; /&gt;&lt;/application&gt; AppWatcherInstaller.kt 1234567891011121314internal sealed class AppWatcherInstaller : ContentProvider() &#123; internal class MainProcess : AppWatcherInstaller() ... override fun onCreate(): Boolean &#123; val application = context!!.applicationContext as Application InternalAppWatcher.install(application) return true &#125; ...&#125; 该ContentProvider除了在onCreate方法中进行了初始化处理，其他方法都是空实现。在onCreate方法中调用了InternalAppWatcher.install(Application)方法完成了LeakCanary的初始化操作。 InternalAppWatcher.kt 123456789101112131415161718192021222324252627282930313233internal object InternalAppWatcher &#123; ... // 延迟5秒抛出任务 private val checkRetainedExecutor = Executor &#123; mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis) &#125; val objectWatcher = ObjectWatcher( clock = clock, checkRetainedExecutor = checkRetainedExecutor, isEnabled = &#123; AppWatcher.config.enabled &#125; ) fun install(application: Application) &#123; ... checkMainThread() // 如果已经初始化了，则不需要再次install if (this::application.isInitialized) &#123; return &#125; InternalAppWatcher.application = application val configProvider = &#123; AppWatcher.config &#125; // 安装ActivityDestroyWatcher、FragmentDestroyWatcher ActivityDestroyWatcher.install(application, objectWatcher, configProvider) FragmentDestroyWatcher.install(application, objectWatcher, configProvider) // 回调InternalLeakCanary onAppWatcherInstalled(application) &#125; ...&#125; 在上面的这个install方法中，干了两件事: Activity、Fragment销毁的观察者的安装。 回调InternalLeakCanary.invoke()。 下面我们逐步分析这两件事情的具体内容。 2.2 Activity、Fragment观察ActivityDestroyWatcher.kt 进入到ActivityDestroyWatcher#install方法中： 12345678910111213141516171819202122private val lifecycleCallbacks = object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123; override fun onActivityDestroyed(activity: Activity) &#123; if (configProvider().watchActivities) &#123; objectWatcher.watch( activity, &quot;$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback&quot; ) &#125; &#125; &#125;companion object &#123; fun install( application: Application, objectWatcher: ObjectWatcher, configProvider: () -&gt; Config ) &#123; val activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider) application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks) &#125;&#125; 上面的逻辑很简单，就是对于每个Activity，在其onDestroy方法调用之后，调用objectWatcher.watch观察这个Activity。 然后我们看看Fragment的观察逻辑。 FragmentDestroyWatcher.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354fun install( application: Application, objectWatcher: ObjectWatcher, configProvider: () -&gt; AppWatcher.Config) &#123; // 这里等同于val fragmentDestroyWatchers = mutableListOf&lt;Function1&lt;Activity, Unit&gt;&gt;() val fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; Unit&gt;() if (SDK_INT &gt;= O) &#123; // 添加android.app.Fragment的观察者 fragmentDestroyWatchers.add( AndroidOFragmentDestroyWatcher(objectWatcher, configProvider) ) &#125; // 获取androidx.fragment.app.Fragment的观察者AndroidXFragmentDestroyWatcher // 如果存在则添加 getWatcherIfAvailable( ANDROIDX_FRAGMENT_CLASS_NAME, ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME, objectWatcher, configProvider )?.let &#123; fragmentDestroyWatchers.add(it) &#125; // 获取android.support.v4.app.Fragment的观察者AndroidSupportFragmentDestroyWatcher // 如果存在则添加 getWatcherIfAvailable( ANDROID_SUPPORT_FRAGMENT_CLASS_NAME, ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME, objectWatcher, configProvider )?.let &#123; fragmentDestroyWatchers.add(it) &#125; if (fragmentDestroyWatchers.size == 0) &#123; return &#125; // 注册生命周期监听 application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123; override fun onActivityCreated( activity: Activity, savedInstanceState: Bundle? ) &#123; // 在Activity创建时对所有Fragment进行观察 for (watcher in fragmentDestroyWatchers) &#123; watcher(activity) &#125; &#125; &#125;)&#125; FragmentDestroyWatcher会根据不同的Fragment来创建*FragmentDestroyWatcher。这里的*FragmentDestroyWatcher是实现Function&lt;Activity,Unit&gt;接口。在Activity调用onCreate之后，使用*FragmentDestroyWatcher.invoke()来处理对Fragment的监听。 AndroidOFragmentDestroyWatcher、AndroidXFragmentDestroyWatcher和AndroidSupportFragmentDestroyWatcher的源码都非常类似，只是针对的Fragment不同而调用的API不同而已。但是AndroidXFragmentDestroyWatcher多了对ViewModel的监听，下面就以它为例看看具体是如何实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051internal class AndroidXFragmentDestroyWatcher( private val objectWatcher: ObjectWatcher, private val configProvider: () -&gt; Config) : (Activity) -&gt; Unit &#123; private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() &#123; override fun onFragmentCreated( fm: FragmentManager, fragment: Fragment, savedInstanceState: Bundle? ) &#123; // 在fragment创建的时候安装ViewModelClearedWatcher ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider) &#125; override fun onFragmentViewDestroyed( fm: FragmentManager, fragment: Fragment ) &#123; val view = fragment.view if (view != null &amp;&amp; configProvider().watchFragmentViews) &#123; objectWatcher.watch( view, &quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroyView() callback &quot; + &quot;(references to its views should be cleared to prevent leaks)&quot; ) &#125; &#125; override fun onFragmentDestroyed( fm: FragmentManager, fragment: Fragment ) &#123; // 在销毁后观察fragment if (configProvider().watchFragments) &#123; objectWatcher.watch( fragment, &quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroy() callback&quot; ) &#125; &#125; &#125; override fun invoke(activity: Activity) &#123; if (activity is FragmentActivity) &#123; val supportFragmentManager = activity.supportFragmentManager supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true) // 安装ViewModelClearedWatcher ViewModelClearedWatcher.install(activity, objectWatcher, configProvider) &#125; &#125;&#125; 实际上就是向Activity的FragmentManager注册FragmentLifecycleCallbacks，这样在Fragment调用onDestroyView和onDestory之后就能观察Fragment的View或者Fragment本身了。 ViewModelClearedWatcher则是通过获取ViewModelStore.mMap，然后在执行生命周期onCleared遍历mMap的value进行观察。ViewModel的分析使用可以查看Jetpack之ViewModel，这里就不继续贴里面的代码了。 2.3 InternalLeakCanary在Activity和Fragment的观察者之后，还调用了onAppWatcherInstalled(application)，这个方法做了什么工作呢？ onAppWatcherInstalled的定义为private val onAppWatcherInstalled: (Application) -&gt; Unit, 然后在init中通过反射将InternalLeakCanary复制给onAppWatcherInstalled。 123456789101112private val onAppWatcherInstalled: (Application) -&gt; Unitinit &#123; val internalLeakCanary = try &#123; val leakCanaryListener = Class.forName(&quot;leakcanary.internal.InternalLeakCanary&quot;) leakCanaryListener.getDeclaredField(&quot;INSTANCE&quot;) .get(null) &#125; catch (ignored: Throwable) &#123; NoLeakCanary &#125; @kotlin.Suppress(&quot;UNCHECKED_CAST&quot;) onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit&#125; onAppWatcherInstalled(application)相当于调用了InternalLeakCanary#invoke()。所以接着查看InternalLeakCanary#invoke()即可，该方法也是完成了一些初始化操作，如下： 1234567891011121314151617181920212223242526272829303132333435override fun invoke(application: Application) &#123; this.application = application // 内存泄漏时回调该类的方法 AppWatcher.objectWatcher.addOnObjectRetainedListener(this) val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider) //使用默认的GcTrigger val gcTrigger = GcTrigger.Default val configProvider = &#123; LeakCanary.config &#125; //使用HandlerThread + Handler 来处理后台任务 val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME) handlerThread.start() val backgroundHandler = Handler(handlerThread.looper) heapDumpTrigger = HeapDumpTrigger( application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper, configProvider ) // 检测App是否可见 application.registerVisibilityListener &#123; applicationVisible -&gt; this.applicationVisible = applicationVisible heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible) &#125; // 为resumedActivity赋值 registerResumedActivityListener(application) // 动态添加Shortcut addDynamicShortcut(application) disableDumpHeapInTests()&#125; AppWatcher.objectWatcher其实就是InternalAppWatcher.objectWatcher, 这里添加了一个OnObjectRetainedListener监听器。 heapDumper的作用是通过Debug.dumpHprofData(heapDumpFile.absolutePath)将堆转储到文件中。 gcTrigger是通过调用Runtime.getRuntime().gc()来出发gc操作。 HeapDumpTrigger 是用来管理Heap Dump的。当objectWatcher的监听器触发之后，就会调用heapDumpTrigger.onObjectRetained()。 2.4 小结先不去管ObjectWatcher.OnObjectRetainedListener是怎么触发的，也不去关心HeapDumpTrigger.onObjectRetained进行了何种操作，我们先把初始化相关的流程捋清楚在去查看它们的以下原理。 LeakCanary通过ContentProviderAppWatcherInstaller在创建的时候执行InternalAppWatcher.install()操作。InternalAppWatcher定义了ObjectWatcher对象，在InternalAppWatcher.install()中分别将objectWatcher传递给ActivityActivityDestroyWatcher和FragmentDestroyWatcher用来观察Activity和Fragment的销毁，然后回调用InternalLeakCanary.invoke完成操作。InternalLeakCanary.invoke则是为objectWatcher添加对象保留监听器，并在监听器触发的时候调用HeapDumpTrigger.onObjectRetained。 这样LeakCanary就初始化安装完毕了，下面我们看看ObjectWatcher是如何观察Activity和Fragment，并触发HeapDumpTrigger方法的，以及HeapDumpTrigger被触发后进行哪些操作。 3. 内存泄漏3.1 ObjectWatcher现在我们来看看ObjectWatcher.watch(Any)方法，Activity、Fragment都是由该方法进行观察的，所以最后还是统一回到了这里。 12345678910111213141516171819202122232425262728293031323334353637@Synchronized fun watch(watchedObject: Any) &#123; watch(watchedObject, &quot;&quot;)&#125;@Synchronized fun watch( watchedObject: Any, description: String) &#123; if (!isEnabled()) &#123; return &#125; // 将ReferenceQueue中出现的弱引用移除 removeWeaklyReachableObjects() val key = UUID.randomUUID() .toString() // 观测时间 val watchUptimeMillis = clock.uptimeMillis() // 创建一个自定义弱引用KeyedWeakReference // 调用了基类的WeakReference&lt;Any&gt;(referent, referenceQueue)构造器 // KeyedWeakReference在被回收前后出现在ReferenceQueue中 val reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue) SharkLog.d &#123; &quot;Watching &quot; + (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else &quot;instance of $&#123;watchedObject.javaClass.name&#125;&quot;) + (if (description.isNotEmpty()) &quot; ($description)&quot; else &quot;&quot;) + &quot; with key $key&quot; &#125; // 将KeyedWeakReference保存到map中 watchedObjects[key] = reference // 主线程5秒后会执行 checkRetainedExecutor.execute &#123; moveToRetained(key) &#125;&#125; 这段代码的逻辑是： 将要观测的对象使用WeakReference保存起来，并在构造时传入一个ReferenceQueue。在垃圾回收器扫描它所管辖的内存区域过程中，一旦gc发现对象是可被被回收(弱可达)，就会把它放到ReferenceQueue中。 5秒钟之后再检查一下是否出现在了引用队列中，若出现了，则没有泄露。（为什么默认的是5秒呢？） 下面我们进一步查看removeWeaklyReachableObjects()与moveToRetained(key)： removeWeaklyReachableObjects() 1234567891011private fun removeWeaklyReachableObjects() &#123; // WeakReferences are enqueued as soon as the object to which they point to becomes weakly // reachable. This is before finalization or garbage collection has actually happened. var ref: KeyedWeakReference? do &#123; ref = queue.poll() as KeyedWeakReference? if (ref != null) &#123; watchedObjects.remove(ref.key) &#125; &#125; while (ref != null)&#125; 所以 removeWeaklyReachableObjects() 方法的作用就是将可被回收(弱可达)的对象从watchedObjects中移除。 moveToRetained(key) 1234567@Synchronized private fun moveToRetained(key: String) &#123; removeWeaklyReachableObjects() val retainedRef = watchedObjects[key] if (retainedRef != null) &#123; retainedRef.retainedUptimeMillis = clock.uptimeMillis() onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125; &#125; 同样的，先执行一次removeWeaklyReachableObjects()， 那么剩下的对象就可以被认为有可能产生内存泄漏。这时候记录下内存泄漏的时间，然后回调所有监听器执行onObjectRetained()。 3.2 HeapDumpTrigger上面我们看到ObjectWatcher中的onObjectRetained会执行HeapDumpTrigger.onObjectRetained()，那么我们就进入到这个方法中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131fun onObjectRetained() &#123; scheduleRetainedObjectCheck( reason = &quot;found new object retained&quot;, rescheduling = false )&#125;private fun scheduleRetainedObjectCheck( reason: String, rescheduling: Boolean, delayMillis: Long = 0L) &#123; val checkCurrentlyScheduledAt = checkScheduledAt if (checkCurrentlyScheduledAt &gt; 0) &#123; // 同一时间只能出现一次任务 val scheduledIn = checkCurrentlyScheduledAt - SystemClock.uptimeMillis() SharkLog.d &#123; &quot;Ignoring request to check for retained objects ($reason), already scheduled in $&#123;scheduledIn&#125;ms&quot; &#125; return &#125; else &#123; val verb = if (rescheduling) &quot;Rescheduling&quot; else &quot;Scheduling&quot; val delay = if (delayMillis &gt; 0) &quot; in $&#123;delayMillis&#125;ms&quot; else &quot;&quot; SharkLog.d &#123; &quot;$verb check for retained objects$&#123;delay&#125; because $reason&quot; &#125; &#125; checkScheduledAt = SystemClock.uptimeMillis() + delayMillis // 使用backgroundHandler去检查被保留的对象(objectWatcher.watchedObjects) backgroundHandler.postDelayed(&#123; checkScheduledAt = 0 checkRetainedObjects(reason) &#125;, delayMillis)&#125;private fun checkRetainedObjects(reason: String) &#123; val config = configProvider() // A tick will be rescheduled when this is turned back on. if (!config.dumpHeap) &#123; SharkLog.d &#123; &quot;Ignoring check for retained objects scheduled because $reason: LeakCanary.Config.dumpHeap is false&quot; &#125; return &#125; // objectWatcher.watchedObjects中剩余的引用个数， // 得到个数之前仍然会执行removeWeaklyReachableObjects() var retainedReferenceCount = objectWatcher.retainedObjectCount if (retainedReferenceCount &gt; 0) &#123; // 手动调用System.gc() gcTrigger.runGc() // 重新获取个数 retainedReferenceCount = objectWatcher.retainedObjectCount &#125; // 检测当前保留对象数量 if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return if (!config.dumpHeapWhenDebugging &amp;&amp; DebuggerControl.isDebuggerAttached) &#123; // 默认Debug的时候不执行，并安排在20秒后 onRetainInstanceListener.onEvent(DebuggerIsAttached) showRetainedCountNotification( objectCount = retainedReferenceCount, contentText = application.getString( R.string.leak_canary_notification_retained_debugger_attached ) ) scheduleRetainedObjectCheck( reason = &quot;debugger is attached&quot;, rescheduling = true, delayMillis = WAIT_FOR_DEBUG_MILLIS ) return &#125; val now = SystemClock.uptimeMillis() val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123; // 60秒只会执行一次，并重新安排时间 onRetainInstanceListener.onEvent(DumpHappenedRecently) showRetainedCountNotification( objectCount = retainedReferenceCount, contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait) ) scheduleRetainedObjectCheck( reason = &quot;previous heap dump was $&#123;elapsedSinceLastDumpMillis&#125;ms ago (&lt; $&#123;WAIT_BETWEEN_HEAP_DUMPS_MILLIS&#125;ms)&quot;, rescheduling = true, delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis ) return &#125; SharkLog.d &#123; &quot;Check for retained objects found $retainedReferenceCount objects, dumping the heap&quot; &#125; dismissRetainedCountNotification() dumpHeap(retainedReferenceCount, retry = true)&#125;private fun checkRetainedCount( retainedKeysCount: Int, retainedVisibleThreshold: Int): Boolean &#123; val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount lastDisplayedRetainedObjectCount = retainedKeysCount if (retainedKeysCount == 0) &#123; // 没有被保留的对象，说明没有泄漏 SharkLog.d &#123; &quot;Check for retained object found no objects remaining&quot; &#125; if (countChanged) &#123; onRetainInstanceListener.onEvent(NoMoreObjects) showNoMoreRetainedObjectNotification() &#125; return true &#125; if (retainedKeysCount &lt; retainedVisibleThreshold) &#123; // 被保留的对象小于5个 if (applicationVisible || applicationInvisibleLessThanWatchPeriod) &#123; // 当前应用可见，或者不可见时间间隔少于 5s，重新安排到 2s 后 if (countChanged) &#123; onRetainInstanceListener.onEvent(BelowThreshold(retainedKeysCount)) &#125; showRetainedCountNotification( objectCount = retainedKeysCount, contentText = application.getString( R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold ) ) scheduleRetainedObjectCheck( reason = &quot;found only $retainedKeysCount retained objects (&lt; $retainedVisibleThreshold while app visible)&quot;, rescheduling = true, delayMillis = WAIT_FOR_OBJECT_THRESHOLD_MILLIS ) return true &#125; &#125; return false&#125; 先进入onObjectRetained()，该方法会调用scheduleRetainedObjectCheck()。此方法也就是在后台线程中执行checkRetainedObjects()来检查泄漏的对象： 首先获取保留对象的个数，如果大于0，则GC一次之后再次获取 。 如果gc后的保留数为0直接返回。如果保留对象小于5个并且应用可见，或者不可见时间间隔少于 5s，重新安排scheduleRetainedObjectCheck()到 2s 后。否则进行下一步操作。 如果config里面配置的“调试时不允许dump heap”为false（默认值）且正在调试，则20s之后再试 判断lastHeapDumpUptimeMillis和当前时间间隔，如果小于60秒则重新安排scheduleRetainedObjectCheck()。 执行dumpHeap()。 dumpHeap 12345678910111213141516171819202122232425262728293031323334353637private fun dumpHeap( retainedReferenceCount: Int, retry: Boolean) &#123; saveResourceIdNamesToMemory() val heapDumpUptimeMillis = SystemClock.uptimeMillis() KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis // 获取hprof文件 val heapDumpFile = heapDumper.dumpHeap() if (heapDumpFile == null) &#123; if (retry) &#123; SharkLog.d &#123; &quot;Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms&quot; &#125; // 如果文件为空并且重试时重新安排任务 scheduleRetainedObjectCheck( reason = &quot;failed to dump heap&quot;, rescheduling = true, delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS ) &#125; else &#123; SharkLog.d &#123; &quot;Failed to dump heap, will not automatically retry&quot; &#125; &#125; showRetainedCountNotification( objectCount = retainedReferenceCount, contentText = application.getString( R.string.leak_canary_notification_retained_dump_failed ) ) return &#125; lastDisplayedRetainedObjectCount = 0 // 设置HeapDump时间 lastHeapDumpUptimeMillis = SystemClock.uptimeMillis() //这些对象我们已经 dump 出来分析了，所以没必要保留它们了 objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis) // 使用HeapAnalyzerService分析hprof文件 HeapAnalyzerService.runAnalysis(application, heapDumpFile)&#125; 首先调用 HeapDumper.dumpHeap() 获取 hprof 文件，接着调用ObjectWatcher.clearObjectsWatchedBefore() 清理被观察的watchedObjects，最后调用 HeapAnalyzerService.runAnalysis() 进行分析。HeapAnalyzerService启动了一个前台进程然后使用HeapAnalyzer对文件进行分析，这里就不继续跟进了。 4. 总结 LeakCanary通过注册ContentProvider来实现初始化。 注册Activity、Fragment的生命周期监听，当对象销毁时触发ObjectWatcher.watch()。 ObjectWatcher.watch()将对象包装成KeyedReference，并关联到ReferenceQueue。 延迟5秒根据ReferenceQueue来清除watchedObjects中弱可达的值。 如果watchedObjects中包含对象的引用，那么通知监听器。 监听器触发HeapDumpTrigger.onObjectRetained()。 onObjectRetained安排后台检查对象并手动调用System.gc()来查看对象保留。 进行dumpHeap() 生成hprof文件，并启动HeapAnalyzerService来分析hprof文件。","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"LeakCanary","slug":"LeakCanary","permalink":"https://blog.xusheng.online/tags/LeakCanary/"}]},{"title":"Jetpack之ViewModel","slug":"Jetpack之ViewModel","date":"2019-11-29T05:30:50.000Z","updated":"2020-09-13T12:40:43.726Z","comments":true,"path":"2019/11/29/Jetpack之ViewModel/","link":"","permalink":"https://blog.xusheng.online/2019/11/29/Jetpack%E4%B9%8BViewModel/","excerpt":"","text":"Jetpack之ViewModel解析ViewModel类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 官网介绍：ViewModel指南 1. 简单使用1.1 创建自定义ViewModel创建自定义ViewModel有两种方式，最大的区别是ViewMode中不能引用Activity、Fragment的实例。主要原因是：为了防止内存泄漏。如果在某种场景下需要用到上下文Context，在继承ViewMode的时候，可以选择继承AndroidViewModel。 123456789class MainViewModel : ViewModel() &#123; private val _userName = MutableLiveData&lt;String&gt;() val userName: LiveData&lt;String&gt; get() = _userName fun setUserName(text: String) &#123; _userName.value = text &#125;&#125; 1.2 在Activity中使用12345678910111213override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val viewModel = ViewModelProvider(this).get(MainViewModel::class.java) viewModel.userName.observe(this, Observer &#123; nameTv.text = it &#125;) changeNameBtn.setOnClickListener &#123; viewModel.setUserName(&quot;张三&quot;) &#125;&#125; 通过ViewModelProvider获取到MainViewModel的实例，然后在Activity中观察MainViewModel中的数据变化和调用其方法。 1.3 ViewModel的生命周期ViewMode在Activity被finish后才会销毁，否则在Activity的生命周期范围内会一直保存在内存中，或者当依附的Fragment detached后进行销毁。 使用官网的一张图来标注Activity的生命周期与ViewMode的生命周期关联，如下图所示： 2. ViewModel原理2.1 Activity重建时对象的保存在分析ViewModel的源码之前，我们先来看一下Activity是如何保存对象的。 在Activity中除了使用onSaveInstanceState()来保存数据和onRestoreInstanceState()恢复数据之外，还有另外的接口回调：onRetainNonConfigurationInstance()和getLastNonConfigurationInstance()。当修改Activity的代码如下时，运行的结果和之前完全一致： 12345678910111213141516171819202122232425262728293031323334353637383940class MainActivity : Activity(), LifecycleOwner &#123; private val lifecycleRegistry = LifecycleRegistry(this) private var viewModel: MainViewModel? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) getViewModel().userName.observe(this, Observer &#123; nameTv.text = it &#125;) changeNameBtn.setOnClickListener &#123; getViewModel().setUserName(&quot;张三&quot;) recreate() &#125; &#125; private fun getViewModel(): MainViewModel &#123; if (viewModel == null) &#123; var lastStore = lastNonConfigurationInstance as? MainViewModel if (lastStore == null) &#123; lastStore = MainViewModel() &#125; viewModel = lastStore &#125; return viewModel!! &#125; override fun onRetainNonConfigurationInstance(): Any? &#123; return viewModel &#125; override fun getLifecycle(): Lifecycle &#123; return lifecycleRegistry &#125;&#125; 2.2 创建ViewModelProvider在Activity中，我们会调用以下方法来获取到ViewModel实例： 1ViewModelProvider(this).get(MainViewModel::class.java) 在ViewModelProvider中有三个构造方法： 123456789101112131415public ViewModelProvider(@NonNull ViewModelStoreOwner owner) &#123; this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory() : NewInstanceFactory.getInstance());&#125;public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125; public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; mViewModelStore = store;&#125; 在Activity的代码中并没有传入ViewModelStoreOwner和ViewModelProvider.Factory对象，说明AppCompatActivity或者其父类中实现了ViewModelStoreOwner接口，找到ComponentActivity发现其不仅实现了ViewModelStoreOwner，还实现了ViewModelProvider.Factory接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner &#123; ... @NonNull @Override public ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;); &#125; if (mViewModelStore == null) &#123; NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; &#125; return mViewModelStore; &#125; @NonNull @Override public ViewModelProvider.Factory getDefaultViewModelProviderFactory() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;); &#125; if (mDefaultFactory == null) &#123; mDefaultFactory = new SavedStateViewModelFactory( getApplication(), this, getIntent() != null ? getIntent().getExtras() : null); &#125; return mDefaultFactory; &#125; @Override @Nullable public final Object onRetainNonConfigurationInstance() &#123; Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) &#123; // No one called getViewModelStore(), so see if there was an existing // ViewModelStore from our last NonConfigurationInstance NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; viewModelStore = nc.viewModelStore; &#125; &#125; if (viewModelStore == null &amp;&amp; custom == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci; &#125; &#125; ComponentActivity实现getViewModelStore()的时候先尝试从getLastNonConfigurationInstance()获取使用onRetainNonConfigurationInstance()保存的对象，如果没有才会创建。getDefaultViewModelProviderFactory则是直接返回了SavedStateViewModelFactory对象。 2.3 ViewModelStoreViewModelStore类的方法非常简单，它使用了HashMap来缓存了ViewModel。并提供clear()来清理ViewModel。 12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; Set&lt;String&gt; keys() &#123; return new HashSet&lt;&gt;(mMap.keySet()); &#125; /** * 清除内部存储并通知ViewModels不再使 */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.clear(); &#125; mMap.clear(); &#125;&#125; 2.4 ViewModelProvider.FactoryViewModelProvider.Factory是一个接口，作用是将传入的Class对象生成具体的ViewModel实例。通过ComponentActivity中默认的实现可以看到SavedStateViewModelFactory通过反射来创建ViewModel： 1234567891011121314151617181920212223242526272829303132333435public interface Factory &#123; @NonNull &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass);&#125;public final class SavedStateViewModelFactory extends ViewModelProvider.KeyedFactory&#123; ... @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; if (isAndroidViewModel) &#123; constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); &#125; else &#123; constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); &#125; if (constructor == null) &#123; return mFactory.create(modelClass); &#125; SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); try &#123; T viewmodel; if (isAndroidViewModel) &#123; viewmodel = constructor.newInstance(mApplication, controller.getHandle()); &#125; else &#123; viewmodel = constructor.newInstance(controller.getHandle()); &#125; viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; &#125; ... &#125;&#125; 2.5 获取ViewModel在ViewModelProvider创建完成之后，调用get()就能获取到ViewModel。这里先尝试从ViewModelStore中或取ViewModel，如果不存在则使用ViewModelProvider.Factory创建，并将创建的实例存入到ViewModelStore。 12345678910111213141516171819202122232425262728293031323334@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); &#125; return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);&#125;@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; if (mFactory instanceof OnRequeryFactory) &#123; ((OnRequeryFactory) mFactory).onRequery(viewModel); &#125; return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; if (mFactory instanceof KeyedFactory) &#123; viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); &#125; else &#123; viewModel = (mFactory).create(modelClass); &#125; mViewModelStore.put(key, viewModel); return (T) viewModel;&#125; 3. 总结当我们在Activity中去实例化ViewModelProvider时，所依赖的activity在其内部会调用getViewModelStore方法去获取一个ViewModelStore对象。如果没有从ViewModelStore中获取到ViewModel对象则创建一个，并保存起来，然后调用ViewModelProvider.get方法将我们的viewmodel实例通过ViewModelStore进行保存管理，当我们的activity的状态发生改变，如旋转屏幕，此时系统会调用onRetainNonConfigurationInstance方法，在这个方法内会将我们的ViewModelStore进行保存。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://blog.xusheng.online/categories/Jetpack/"}],"tags":[{"name":"ViewModel","slug":"ViewModel","permalink":"https://blog.xusheng.online/tags/ViewModel/"}]},{"title":"Jetpack之LiveData","slug":"Jetpack之LiveData","date":"2019-11-02T08:11:07.000Z","updated":"2020-09-13T12:40:43.726Z","comments":true,"path":"2019/11/02/Jetpack之LiveData/","link":"","permalink":"https://blog.xusheng.online/2019/11/02/Jetpack%E4%B9%8BLiveData/","excerpt":"","text":"LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。 本文用到的源代码基于androidx.lifecycle:lifecycle-livedata:2.2.0。 官网介绍：LiveData指南 1. 简单使用1.1 在ViewModel定义LiveData12345678class MyViewModel : ViewModel() &#123; private val _liveData: MutableLiveData&lt;String&gt; = MutableLiveData() val liveData get() = _liveData fun updateValue(value: String) &#123; _liveData.setValue(value) &#125;&#125; 由于 LiveData 是一个 抽象类，我们不能直接创建它的实例。官方两个它的子类MutableLiveData和MediatorLiveData，它们分别有这不同的使用场景： MutableLiveData：将postValue(value)和setValue()方法公开，允许外部访问 MediatorLiveData：允许合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。 当我们要更新LiveData中的数据时，通过调用updateValue(value)即可。 1.2 观察LiveData数据的变化1234567override fun onCreate(saveInstanceState: Bundle?) &#123; ... viewModel.liveData.observe(this, Observer &#123; Log.d(TAG, &quot;onCreate: $it&quot;) &#125;) ...&#125; 2. 源码分析2.1 Observer为LiveData添加观察者的方式特别简单，调用其observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)方法即可： 123456789101112131415161718192021222324252627282930313233public abstract class LiveData&lt;T&gt; &#123; // 用来存放Observer和Observer的包装对象ObserverWrapper private SafeIterableMap&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt; mObservers = new SafeIterableMap&lt;&gt;(); @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123; assertMainThread(&quot;observe&quot;); // 判断observe是不是在主线程执行 if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // 如果当前Lifecycle处于DESTROYED状态，直接返回 // ignore return; &#125; // 将owner, observer包装成LifecycleBoundObserver对象 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); // 保存LifecycleBoundObserver到mObservers中，如果存在则返回已存在的值 ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); // 防止重复添加 if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); &#125; if (existing != null) &#123; return; &#125; // 为Lifecycle添加LifecycleBoundObserver owner.getLifecycle().addObserver(wrapper); &#125;&#125;// 定义观察者的接口public interface Observer&lt;T&gt; &#123; void onChanged(T t);&#125; observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)中接收两个参数，LifecycleOwer和Observer的实现。我们提供的观察者observer在被包装成LifecycleBoundObserver之后，既被添加到了LiveData的观察者集合中，又被添加到了了Lifecycle的观察者集合中。 LiveData本身定义的观察者Observer是很简单的，只有一个onChanged方法，在LiveData数据发生变化时被调用。为了让LiveData与生命周期关联，才有了 LifecycleBoundObserver。 Livecycle相关的解析可以查看Jetpack之LiveData。 LifecycleBoundObserver继承自ObserverWrapper，我们先看看ObserverWrapper中的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private abstract class ObserverWrapper &#123; // LiveData原始的观察者，也就是我们传入的 final Observer&lt;? super T&gt; mObserver; // 是否处于活动状态 boolean mActive; // 版本号，默认为START_VERSION int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;? super T&gt; observer) &#123; mObserver = observer; &#125; abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) &#123; return false; &#125; void detachObserver() &#123; &#125; void activeStateChanged(boolean newActive) &#123; // 如果活动状态没有发生改变则返回 if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we&#x27;d never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; // LiveData中的方法，空实现 onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; // LiveData中的方法，空实现 onInactive(); &#125; if (mActive) &#123; // LiveData中的方法 // ObserverWrapper处于活动状态时会分发值 dispatchingValue(this); &#125; &#125;&#125; ObserverWrapper的主要职责是处理活动状态的变化。这里的mActive值的是被包装者mObserver是否处于活动状态，处于活动状态的观察者可以接收LiveData数据的变化，否则则不能。 Livedata本身也是有活动状态的，LiveData的活动状态取决于它本身的观察者中是否至少有一个处于“Active”状态。当LiveData从非活动状态变为活动状态时onActive()会被调用，从活动状态变为非活动状态时onInactive()会被调用。 再来看看对ObserverWrapper进一步的包装LifecycleBoundObserver： 12345678910111213141516171819202122232425262728293031323334353637class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; // Lifecycle持有者 LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; // Lifecycle至少是STARTED时才允许活动 return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; // 当Lifecycle处于DESTROYED时，从LiveData中移除观察者 if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; // 当生命周期改变时就调用ObserverWrapper的activeStateChanged activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; // 从Lifecycle观察者中移除 mOwner.getLifecycle().removeObserver(this); &#125;&#125; LifecycleBoundObserver实现了GenericLifecycleObserver接口，这就可以做到： 当生命周期变化时改变是否处于活动状态 当生命周期处于DESTROYED时，从LiveDatah和Lifecycle中移除观察者。 总结一下LiveData添加观察者的流程和内容： 接收一个LifecycleOwer和用户传入的Observer 将LifecycleOwer和Observer包装成LifecycleBoundObserver，并将包装后的对象添加到LiveData和Lifecycle的观察者中 在生命周期改变时设置LifecycleBoundObserver的活动状态 在生命周期为DESTROYED时，从LiveDatah和Lifecycle中移除观察者 此外LiveData还可以通过observeForever(@NonNull Observer&lt;? super T&gt; observer)来添加观察者。其实就是没有绑定生命周期的观察者，也可以手动移除。 2.2 setValueLiveData需要在两种情况下分发数据： LiveData本身的数据发生改变时 LiveData中的某个观察者因为生命周期的变化处于活动时 改变LiveData的数据需要使用其setValue(T value)或者postValue(T value)方法。这取决于是否在主线程传入数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public abstract class LiveData&lt;T&gt; &#123; // 数据锁，postValue时使用 final Object mDataLock = new Object(); // LiveData的初始版本 static final int START_VERSION = -1; // 初始情况下LiveData static final Object NOT_SET = new Object(); // LiveData的数据 private volatile Object mData = NOT_SET; // 通过postValue设置数据 volatile Object mPendingData = NOT_SET; // 用于和ObserverWrapper中的version进行比较，防止重复通知 private int mVersion = START_VERSION; private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125; &#125;; protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; // 切换到主线程调用setValue ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125; @MainThread protected void setValue(T value) &#123; assertMainThread(&quot;setValue&quot;); // mVersion递增 mVersion++; mData = value; // 分发mData数据变化 dispatchingValue(null); &#125; // 如果当前线程不在主线程就会抛出异常 private static void assertMainThread(String methodName) &#123; if (!ArchTaskExecutor.getInstance().isMainThread()) &#123; throw new IllegalStateException(&quot;Cannot invoke &quot; + methodName + &quot; on a background&quot; + &quot; thread&quot;); &#125; &#125;&#125; 可以看出postValue()最终还是调用的setValue()。setValue()也很简单，增加版本号、设置数据、然后调用dispatchingValue()分发数据。 我们继续跟进``dispatchingValue()`： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public abstract class LiveData&lt;T&gt; &#123; private boolean mDispatchingValue; private boolean mDispatchInvalidated; private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; // 只分发处于活动状态的ObserverWrapper return; &#125; // 如果ObserverWrapper应该为不活动时，将ObserverWrapper不活动 // 例如LifecycleBoundObserver收到ON_STOP事件处于CREATED状态时就不会分发数据 // 这里再一次进行了判断 if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; // 如果数据已经是最新的了就不需要分发 if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; // 重新设置ObserverWrapper的版本号 observer.mLastVersion = mVersion; // 回调我们传入的Observer方法 observer.mObserver.onChanged((T) mData); &#125; @SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */ void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; // mDispatchingValue和mDispatchInvalidated防止在数据分发的时候 // LiveData的数据再次发生改变 if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; // 如果传入的ObserverWrapper不为空，只需要对传入的ObserverWrapper分发数据 considerNotify(initiator); initiator = null; &#125; else &#123; // 对所有的ObserverWrapper进行分发数据 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false; &#125;&#125; 这里可以看出，当LiveData的数据发生变化时，对所有观察者考虑是否通知数据的变化；某个观察者的变为活动时，只对这个观察者只对该观察者本身考虑是否通知数据的变化。 在通知观察者的时候同样会和ObserverWrapper的版本号进行比对，避免重复通知。 2.3 MediatorLiveDataMediatorLiveData也是LiveData的子类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MediatorLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt; &#123; private SafeIterableMap&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; mSources = new SafeIterableMap&lt;&gt;(); @MainThread public &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) &#123; Source&lt;S&gt; e = new Source&lt;&gt;(source, onChanged); Source&lt;?&gt; existing = mSources.putIfAbsent(source, e); if (existing != null &amp;&amp; existing.mObserver != onChanged) &#123; throw new IllegalArgumentException( &quot;This source was already added with the different observer&quot;); &#125; if (existing != null) &#123; return; &#125; // 如果有观察者 if (hasActiveObservers()) &#123; // e.mLiveData.observeForever e.plug(); &#125; &#125; @MainThread public &lt;S&gt; void removeSource(@NonNull LiveData&lt;S&gt; toRemote) &#123; Source&lt;?&gt; source = mSources.remove(toRemote); if (source != null) &#123; // 其实调用的就是source.mLiveData.removeObserver() source.unplug(); &#125; &#125; @CallSuper @Override protected void onActive() &#123; // 如果MediatorLiveData处于活动状态时 for (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123; source.getValue().plug(); &#125; &#125; @CallSuper @Override protected void onInactive() &#123; // 如果MediatorLiveData处于非活动状态时 for (Map.Entry&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; source : mSources) &#123; source.getValue().unplug(); &#125; &#125; private static class Source&lt;V&gt; implements Observer&lt;V&gt; &#123; final LiveData&lt;V&gt; mLiveData; final Observer&lt;? super V&gt; mObserver; int mVersion = START_VERSION; Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) &#123; mLiveData = liveData; mObserver = observer; &#125; void plug() &#123; // 为mLiveData添加观察者 mLiveData.observeForever(this); &#125; void unplug() &#123; // 移除mLiveData的观察者 mLiveData.removeObserver(this); &#125; @Override public void onChanged(@Nullable V v) &#123; if (mVersion != mLiveData.getVersion()) &#123; mVersion = mLiveData.getVersion(); mObserver.onChanged(v); &#125; &#125; &#125;&#125; MediatorLiveData可以添加其它LiveData的监听，当其它LiveData的观察者被回调时就会作用的MediatorLiveData上。 这里结合的Transformations能更好的使用MediatorLiveData，具体查看Transformations。 3. 总结 我们的观察者经过包装后，被添加进LiveData的观察者集合，也被添加到了我们提供的Lifecycle的观察者集合中（假如不是通过调用observeForever） 无论是LiveData本身的数据发生变化，还是观察者变为“活动”状态时，我们的观察者都会被通知。 当我们的观察者处于“活动”状态并且没有被通知过的时候（version低于LiveData的version），Observer的onChanged方法才会被调用。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://blog.xusheng.online/categories/Jetpack/"}],"tags":[{"name":"LiveData","slug":"LiveData","permalink":"https://blog.xusheng.online/tags/LiveData/"}]},{"title":"Jetpack之Lifecycle","slug":"Jetpack之Lifecycle","date":"2019-09-17T04:57:00.000Z","updated":"2020-09-13T12:40:43.725Z","comments":true,"path":"2019/09/17/Jetpack之Lifecycle/","link":"","permalink":"https://blog.xusheng.online/2019/09/17/Jetpack%E4%B9%8BLifecycle/","excerpt":"","text":"Lifecycle是一个可以用来响应其他组件（如Activity、Fragment）生命周期变化的类。 本文源代码基于: 123def lifecycle_version = &quot;2.1.0&quot;implementation &quot;androidx.lifecycle:lifecycle-common:$lifecycle_version&quot;implementation &quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot; 1. 简单使用1.1 创建LifecycleObserver通过实现LifecycleObserver接口，然后就能根据注解响应到生命周期事件： 12345678910111213class MyViewModel : ViewModel(), LifecycleObserver &#123; ... @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun onCreate() &#123; Log.d(TAG, &quot;onCreate: &quot;) &#125; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun onDestroy() &#123; Log.d(TAG, &quot;onDestroy: &quot;) &#125;&#125; 1.2 创建LifecycleOwner实现LifecycleOwner接口，然后通过LifecycleRegistry处理生命周期事件： 1234567891011121314151617181920class MyActivity : Activity(), LifecycleOwner &#123; private val lifecycleRegistry = LifecycleRegistry(this) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE) &#125; override fun onDestroy() &#123; super.onDestroy() lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY) &#125; override fun getLifecycle(): Lifecycle &#123; return lifecycleRegistry &#125;&#125; 1.3 为生命周期添加观察者12345override fun onCreate(savedInstanceState: Bundle?) &#123; ... val viewModel = MainViewModel() lifecycle.addObserver(viewModel)&#125; 启动Activity后就会看到如下日志： 1D&#x2F;MyViewModel: onCreate: 1.4 总结lifecycleRegistry是Lifecycle的实现类。Lifecycle响应生命周期的原理很简单，就是在Activity或者Fragment的生命周期中发送事件，然后添加一个观察者去响应这些事件。 在实际使用中我们并不需要去处理生命周期事件的发送，因为Support Library 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner接口。 2 源码分析在分析源码之前我们先介绍一下Lifecycle中关键的几个类： Lifecycle：用于存储组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。 Lifecycle.Event：生命周期事件，这些事件映射到 Activity 和 Fragment 中的回调方法。 Lifecycle.State：生命周期状态。 LifecycleOwner：接口，表示类具有Lifecycle。 LifecycleObserve：接口，表示类可以通过OnLifecycleEvent注释响应生命周期。 LifecycleRegistry：Lifecycle的实现类。 2.1 事件和状态Livecycle使用两种主要枚举跟踪其关联组件的生命周期状态： 12345678910111213141516171819202122232425public abstract class Lifecycle &#123; ... @SuppressWarnings(&quot;WeakerAccess&quot;) public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY &#125; @SuppressWarnings(&quot;WeakerAccess&quot;) public enum State &#123; DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125;&#125; 它们对应的关系如下图所示: 2.2 Lifecycle生命周期事件的分发上面说到在正式开发中一般不需要我们去分发Lifecycle的生命周期事件，这些事件都由sdk处理好了。进入ComponentActivity： 1234567891011121314151617181920212223public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, SavedStateRegistryOwner, OnBackPressedDispatcherOwner &#123; ... private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); ... @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); ... &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125;&#125; 它同样实现了LifecycleOwner接口，但是不同的是多了一个ReportFragment。那我们就看看ReportFragment是用来干什么的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ReportFragment extends Fragment &#123; private static final String REPORT_FRAGMENT_TAG = &quot;androidx.lifecycle&quot; + &quot;.LifecycleDispatcher.report_fragment_tag&quot;; public static void injectIfNeededIn(Activity activity) &#123; android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); manager.executePendingTransactions(); &#125; &#125; ... @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); &#125; @Override public void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE); &#125; @Override public void onStop() &#123; super.onStop(); dispatch(Lifecycle.Event.ON_STOP); &#125; @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won&#x27;t leak reference to an activity mProcessListener = null; &#125; private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125; ...&#125; ReportFragment.injectIfNeededIn(activity)向Activity中添加一个无界面的Fragment，然后在Fragment的生命周期回调中分发事件。 Fragment中也会有类似的操作。 2.3 添加生命周期观察者LifecycleRegistry通过调用addObserver(observer)来添加一个观察者。 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; // 创建一个ObserverWithState对象用来接收事件 ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); // 将statefulObserver添加到mObserverMap // 如果ObserverMap中已经存在则返回已存在的值，防止重复添加 ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; // 是否正在添加LifecycleObserver或者正在同步生命周期事件 boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; // 根据mParentState计算当前状态 State targetState = calculateTargetState(observer); mAddingObserverCounter++; // 如果statefulObserver的状态在targetState之前 while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); // 回调事件 statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; // 如果不是添加LifecycleObserver且不在回调周期事件，那么同步所有Observer if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--;&#125; 这段代码很简单： 首先创建一个ObserverWithState对象(ObserverWithState具体在后面会说到) 判断当前正在添加LifecycleObserver或者正在回调生命周期事件，如果是直接使用ObserverWithState回调事件，否则同步回调事件。 2.4 生命周期事件的回调LifecycleRegistry有三种方法去发送生命周期事件： 12345678910111213@Deprecated@MainThreadpublic void markState(@NonNull State state) &#123; setCurrentState(state);&#125;@MainThreadpublic void setCurrentState(@NonNull State state) &#123; moveToState(state);&#125;public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125; 其中getStateAfter(event)的方法的作用是获取事件之后的状态，对比之前的时序图还是很好理解。 这三个方法最终都会调用到moveToState()： 123456789101112131415161718private void moveToState(State next) &#123; // 如果当前状态和设置的状态相同 if (mState == next) &#123; return; &#125; mState = next; // 如果正在同步状态或者正在添加LifecycleObserver if (mHandlingEvent || mAddingObserverCounter != 0) &#123; // 有新的事件产生 mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; // 同步状态 sync(); mHandlingEvent = false;&#125; 这里先判断当前的状态和要同步的状态是否一样，如果相同就不做处理。然后判断当前是不是正在同步或者正在添加LifecycleObserver(添加LifecycleObserver的时候也会执行sync())，如果满足上述条件之一则表明有新的事件产生。 最后调用sync()同步状态： 12345678910111213141516171819202122232425private void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; throw new IllegalStateException(&quot;LifecycleOwner of this LifecycleRegistry is already&quot; + &quot;garbage collected. It is too late to change lifecycle state.&quot;); &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. // 比较当前状态和mObserverMap中最早添加的LifecycleObserver中的状态 if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; // 向后同步 backwardPass(lifecycleOwner); &#125; // mObserverMap中最新添加的LifecycleObserver中的状态 Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); // 如果有最新添加的并且当前状态在最新添加的LifecycleObserver中的状态之前 if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; // 向前同步 forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false;&#125; FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap类似于LinkedHashMap，它支持迭代期间进行修改。sync会根据当前状态和mObserverMap中的eldest和newest的状态做对比 ，判断当前状态是向前还是向后。forwardPass()和backwardPass()的代码大同小异，这里以forwardPass()为例： 123456789101112131415161718private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); // observer中保存的状态在当前状态之前 while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; // 像mParentStates添加state pushParentState(observer.mState); // 回调事件 observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); // 从mParentStates删除最后一个值 popParentState(); &#125; &#125;&#125; 迭代mObserverMap，然后进行事件回调。mParentStates主要在添加LifecycleObserver中用到，upEvent(observer.mState)会得到当前状态的向前的事件。ObserverWithState从名称就可以看出，它内部包含了一个State和LifecycleEventObserver。 1234567891011121314151617static class ObserverWithState &#123; State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; // 获取到对应的LifecycleEventObserver实现类 mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; Lifecycling.lifecycleEventObserver(observer)根据LifecycleObserver来创建LifecycleEventObserver的实现类。 1234567891011121314151617181920212223242526272829303132333435363738@NonNullstatic LifecycleEventObserver lifecycleEventObserver(Object object) &#123; // 是不是LifecycleEventObserver的实现类 boolean isLifecycleEventObserver = object instanceof LifecycleEventObserver; // 是不是FullLifecycleObserver的实现类 boolean isFullLifecycleObserver = object instanceof FullLifecycleObserver; if (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123; return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, (LifecycleEventObserver) object); &#125; if (isFullLifecycleObserver) &#123; return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, null); &#125; if (isLifecycleEventObserver) &#123; return (LifecycleEventObserver) object; &#125; final Class&lt;?&gt; klass = object.getClass(); // 获取观察者构造函数类型 int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; // 通过引入kapt &quot;android.arch.lifecycle:compiler:2.1.0&quot;生成的实现 List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); if (constructors.size() == 1) &#123; GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; return new ReflectiveGenericLifecycleObserver(object);&#125; 可以看到我们这里的产生的实现就是ReflectiveGenericLifecycleObserver： 1234567891011121314class ReflectiveGenericLifecycleObserver implements LifecycleEventObserver &#123; private final Object mWrapped; private final CallbackInfo mInfo; ReflectiveGenericLifecycleObserver(Object wrapped) &#123; mWrapped = wrapped; mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass()); &#125; @Override public void onStateChanged(LifecycleOwner source, Event event) &#123; mInfo.invokeCallbacks(source, event, mWrapped); &#125;&#125; ReflectiveGenericLifecycleObserver在onStateChanged()会调用CallbackInfo的invokeCallbacks方法。在讲这个方法前，需要先了解CallbackInfo是怎么创建的，是由createInfo方法创建的，如下所示： 12345678910111213141516171819202122232425262728293031323334private CallbackInfo createInfo(Class klass, @Nullable Method[] declaredMethods) &#123; Class superclass = klass.getSuperclass(); Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = new HashMap&lt;&gt;(); ... Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass); boolean hasLifecycleMethods = false; for (Method method : methods) &#123; // 遍历各个方法，获取方法上的名为OnLifecycleEvent的注解，这个注解正是实现LifecycleObserver接口时用到的 OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation == null) &#123; continue; &#125; hasLifecycleMethods = true; Class&lt;?&gt;[] params = method.getParameterTypes(); int callType = CALL_TYPE_NO_ARG; if (params.length &gt; 0) &#123; callType = CALL_TYPE_PROVIDER; if (!params[0].isAssignableFrom(LifecycleOwner.class)) &#123; throw new IllegalArgumentException( &quot;invalid parameter type. Must be one and instanceof LifecycleOwner&quot;); &#125; &#125; // 获取该注解的值，也就是在@OnLifecycleEvent中定义的事件 Lifecycle.Event event = annotation.value(); ... // 新建了一个MethodReference，其内部包括了使用了该注解的方法 MethodReference methodReference = new MethodReference(callType, method); verifyAndPutHandler(handlerToEvent, methodReference, event, klass); &#125; CallbackInfo info = new CallbackInfo(handlerToEvent); mCallbackMap.put(klass, info); mHasLifecycleMethods.put(klass, hasLifecycleMethods); return info; &#125; 其实就是回调ViewModel中注解的方法。 3. 总结Lifecycle的流程如下： Activity或Fragment中实现LifecycleOwner接口。 为Lifecycle添加生命周期观察者LifecycleObserver。 通过LifecycleRegistry在Activity或Fragment的生命周期方法中发送事件。 LifecycleRegistry根据不同的实现的LifecycleEventObserver来回调onStateChanged(LifecycleOwner owner, Event event)。 LifecycleObserver观察到生命周期事件。","categories":[{"name":"Jetpack","slug":"Jetpack","permalink":"https://blog.xusheng.online/categories/Jetpack/"}],"tags":[{"name":"Lifecycle","slug":"Lifecycle","permalink":"https://blog.xusheng.online/tags/Lifecycle/"}]},{"title":"OkHttp源码解析","slug":"OkHttp源码解析","date":"2019-08-15T00:48:17.000Z","updated":"2020-09-13T12:40:43.728Z","comments":true,"path":"2019/08/15/OkHttp源码解析/","link":"","permalink":"https://blog.xusheng.online/2019/08/15/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"1. 开始使用在build.gradle中添加依赖： 12def okhttpVersion = &quot;4.2.2&quot;implementation &quot;com.squareup.okhttp3:okhttp:$okhttpVersion&quot; OkHttp 4.0后就使用了Kotlin来重写 创建OkHttpClient： 12val okHttpClient = OkHttpClient.Builder() .build() 发送请求并响应返回结果: 12345val request = Request.Builder() .url(&quot;url&quot;) .build()val call = okHttpClient.newCall(request)val response = call.execute() 下面我们以这个例子为切入点，开始分析OkHttp的内部实现。 2. OkHttpClient的创建OkHttpClient的创建方式有两种：通过OkHttpClient.Builder创建和直接使用构造方创建，： 123456789101112131415161718192021222324252627282930313233343536373839404142open class OkHttpClient internal constructor( builder: Builder) : Cloneable, Call.Factory, WebSocket.Factory &#123; constructor() : this(Builder()) init &#123; if (builder.sslSocketFactoryOrNull != null || connectionSpecs.none &#123; it.isTls &#125;) &#123; this.sslSocketFactoryOrNull = builder.sslSocketFactoryOrNull this.certificateChainCleaner = builder.certificateChainCleaner this.x509TrustManager = builder.x509TrustManagerOrNull &#125; else &#123; this.x509TrustManager = Platform.get().platformTrustManager() Platform.get().configureTrustManager(x509TrustManager) this.sslSocketFactoryOrNull = newSslSocketFactory(x509TrustManager!!) this.certificateChainCleaner = CertificateChainCleaner.get(x509TrustManager!!) &#125; if (sslSocketFactoryOrNull != null) &#123; Platform.get().configureSslSocketFactory(sslSocketFactoryOrNull) &#125; this.certificatePinner = builder.certificatePinner .withCertificateChainCleaner(certificateChainCleaner) check(null !in (interceptors as List&lt;Interceptor?&gt;)) &#123; &quot;Null interceptor: $interceptors&quot; &#125; check(null !in (networkInterceptors as List&lt;Interceptor?&gt;)) &#123; &quot;Null network interceptor: $networkInterceptors&quot; &#125; &#125; ... class Builder constructor() &#123; ... fun build(): OkHttpClient = OkHttpClient(this) &#125;&#125; 在init里面为一些属性赋值，但是对比一下之前版本的构造方法，发现少了很多的内容： 1234567891011121314151617181920212223242526272829OkHttpClient(Builder builder) &#123; this.dispatcher = builder.dispatcher; this.proxy = builder.proxy; this.protocols = builder.protocols; this.connectionSpecs = builder.connectionSpecs; this.interceptors = Util.immutableList(builder.interceptors); this.networkInterceptors = Util.immutableList(builder.networkInterceptors); this.eventListenerFactory = builder.eventListenerFactory; this.proxySelector = builder.proxySelector; this.cookieJar = builder.cookieJar; this.cache = builder.cache; this.internalCache = builder.internalCache; this.socketFactory = builder.socketFactory; this.hostnameVerifier = builder.hostnameVerifier; this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner( certificateChainCleaner); this.proxyAuthenticator = builder.proxyAuthenticator; this.authenticator = builder.authenticator; this.connectionPool = builder.connectionPool; this.dns = builder.dns; this.followSslRedirects = builder.followSslRedirects; this.followRedirects = builder.followRedirects; this.retryOnConnectionFailure = builder.retryOnConnectionFailure; this.connectTimeout = builder.connectTimeout; this.readTimeout = builder.readTimeout; this.writeTimeout = builder.writeTimeout; this.pingInterval = builder.pingInterval; ...&#125; 这是因为kotlin的成员变量可以通过构造方法中的参数来赋值： 1234567891011@get:JvmName(&quot;dispatcher&quot;) val dispatcher: Dispatcher = builder.dispatcher@get:JvmName(&quot;connectionPool&quot;) val connectionPool: ConnectionPool = builder.connectionPool@get:JvmName(&quot;interceptors&quot;) val interceptors: List&lt;Interceptor&gt; = builder.interceptors.toImmutableList()@get:JvmName(&quot;networkInterceptors&quot;) val networkInterceptors: List&lt;Interceptor&gt; = builder.networkInterceptors.toImmutableList()@get:JvmName(&quot;eventListenerFactory&quot;) val eventListenerFactory: EventListener.Factory = builder.eventListenerFactory@get:JvmName(&quot;retryOnConnectionFailure&quot;) val retryOnConnectionFailure: Boolean = builder.retryOnConnectionFailure... 这里每个字段的意思先不去详细了解，我们的目的是为了了解它内部的实现机制。 3. Request、Call接下来我们看看如何去创建一个请求。 3.1 RequestRequest中的代码很简单，也是通过构造方法或者Request.Builder来创建： 1234567891011121314151617181920class Request internal constructor( @get:JvmName(&quot;url&quot;) val url: HttpUrl, // 请求Url @get:JvmName(&quot;method&quot;) val method: String, // 请求方法 GET、POST @get:JvmName(&quot;headers&quot;) val headers: Headers, // 请求头 @get:JvmName(&quot;body&quot;) val body: RequestBody?, // 请求体 internal val tags: Map&lt;Class&lt;*&gt;, Any&gt; // 请求tag) &#123; open class Builder &#123; ... open fun build(): Request &#123; return Request( checkNotNull(url) &#123; &quot;url == null&quot; &#125;, method, headers.build(), body, tags.toImmutableMap() ) &#125; &#125;&#125; 3.2 Call我们回到okHttpClient.newCall(request)这一行代码。这里OkHttpClient通过我们的请求信息来创建了一个Call： 123override fun newCall(request: Request): Call &#123; return RealCall.newRealCall(this, request, forWebSocket = false)&#125; 这里的RealCall是Call的实现类，我们先来看看Call的接口方法： 123456789101112131415161718192021interface Call : Cloneable &#123; // 原始请求信息 fun request(): Request // 通过执行请求 @Throws(IOException::class) fun execute(): Response // 异步执行请求 fun enqueue(responseCallback: Callback) // 尽可能的取消请求，已完成的请求无法被取消 fun cancel() // 调用execute或者enqueue都返回true fun isExecuted(): Boolean // 是否被取消 fun isCanceled(): Boolean // 超时 fun timeout(): Timeout // 创建一个与当前Call相同的Call，即使当前Call已经被execute或者enqueue public override fun clone(): Call ...&#125; 回到RealCall，看看它的newRealCall()以及构造方法等： 123456789101112131415161718192021internal class RealCall private constructor( val client: OkHttpClient, val originalRequest: Request, val forWebSocket: Boolean) : Call &#123; private lateinit var transmitter: Transmitter var executed: Boolean = false companion object &#123; fun newRealCall( client: OkHttpClient, originalRequest: Request, forWebSocket: Boolean ): RealCall &#123; // Safely publish the Call instance to the EventListener. return RealCall(client, originalRequest, forWebSocket).apply &#123; transmitter = Transmitter(client, this) &#125; &#125; &#125; &#125; 其中Transmitter是OkHttp的应用层和网络层之间的桥梁。 3.3 Transmitter12345678910111213141516class Transmitter( private val client: OkHttpClient, private val call: Call) &#123; private val connectionPool: RealConnectionPool = client.connectionPool.delegate private val eventListener: EventListener = client.eventListenerFactory.create(call) private val timeout = object : AsyncTimeout() &#123; override fun timedOut() &#123; cancel() &#125; &#125;.apply &#123; timeout(client.callTimeoutMillis.toLong(), MILLISECONDS) &#125; ...&#125; 在创建 Transmitter 对象传入了OkHttpClient对象和RealCall对象，并设置了相关指标的监听器和 ConnectionPool。 具体的方法在后续执行的时候我们再深入了解。 4. RealCall.execute()接下来我们重点看看OkHttp是如何放送请求的。 1234567891011121314override fun execute(): Response &#123; synchronized(this) &#123; check(!executed) &#123; &quot;Already Executed&quot; &#125; executed = true &#125; transmitter.timeoutEnter() transmitter.callStart() try &#123; client.dispatcher.executed(this) return getResponseWithInterceptorChain() &#125; finally &#123; client.dispatcher.finished(this) &#125;&#125; 我们可以看到RealCall.execute()执行时，立马将executed设置为true，如果多次调用就会报错。 接下来轮到我们看看transmitter.timeoutEnter()和transmitter.callStart()两个方法理的内容： 1234567891011121314151617181920212223class Transmitter( private val client: OkHttpClient, private val call: Call) &#123; private val eventListener: EventListener = client.eventListenerFactory.create(call) private val timeout = object : AsyncTimeout() &#123; override fun timedOut() &#123; cancel() &#125; &#125;.apply &#123; timeout(client.callTimeoutMillis.toLong(), MILLISECONDS) &#125; fun timeoutEnter() &#123; timeout.enter() &#125; fun callStart() &#123; this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;) eventListener.callStart(call) &#125; &#125; EventListener用于Call事件的监听器，里面的接口对应了Call的每个事件。在 这里默认的是EventListener.NONE空实现，当我们要监听Call事件的时候我们可以看看LoggingEventListener。 AsyncTimeout用于监听Call是否超时，它是一个链表。当timeout.enter()执行的时候AsyncTimeout便从Watchdog线程来对比OkHttpClient中设置的时间，如果超时就会调用timedOut()。大致如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950open class AsyncTimeout : Timeout() &#123;*/ private var next: AsyncTimeout? = null private var timeoutAt = 0L fun enter() &#123; ... scheduleTimeout(this, timeoutNanos, hasDeadline) &#125; companion object &#123; ... private var head: AsyncTimeout? = null private fun scheduleTimeout(node: AsyncTimeout, timeoutNanos: Long, hasDeadline: Boolean) &#123; synchronized(AsyncTimeout::class.java) &#123; // Start the watchdog thread and create the head node when the first timeout is scheduled. if (head == null) &#123; head = AsyncTimeout() // 启动watch dog Watchdog().start() &#125; ... &#125; &#125; // Watchdog 线程 private class Watchdog internal constructor() : Thread(&quot;Okio Watchdog&quot;) &#123; init &#123; isDaemon = true &#125; override fun run() &#123; while (true) &#123; try &#123; var timedOut: AsyncTimeout? = null synchronized(AsyncTimeout::class.java) &#123; timedOut = awaitTimeout() if (timedOut === head) &#123; head = null return &#125; &#125; // 超时了 timedOut?.timedOut() &#125; catch (ignored: InterruptedException) &#123; &#125; &#125; &#125; &#125; ... &#125; 现在我们回到RealCall，继续看看client.dispatcher.executed(this)的调用： 123456789class Dispatcher constructor() &#123; // 同步运行的Call数组队列 private val runningSyncCalls = ArrayDeque&lt;RealCall&gt;() @Synchronized internal fun executed(call: RealCall) &#123; // 将Call插入到队列末尾 runningSyncCalls.add(call) &#125;&#125; 接下来就调用getResponseWithInterceptorChain()去返回结果了，最后调用client.dispatcher.finished(this)从Dispatchs.runningSyncCalls中移除当前的Call。 小结一下 OkHttp发送请求的流程为： 创建Request请求信息 OkHttpClient执行newCall()的时候使用Request对象来创建RealCall RealCall执行同步请求execute()并返回Response： 使用transmitter来记录超时信息 使用transmitter发送Call开始事件 将当前Call添加到Dispatcher中当前运行的Call队列(runningAsyncCalls)末尾 调用getResponseWithInterceptorChain()获取结果并返回(当然其方法内部也会调用Transmitter的相关方法) 从Dispatchers中的运行Call队列移除当前Call。 5. getResponseWithInterceptorChain()1234567891011121314151617181920212223242526272829303132333435363738@Throws(IOException::class)fun getResponseWithInterceptorChain(): Response &#123; // Build a full stack of interceptors. val interceptors = mutableListOf&lt;Interceptor&gt;() interceptors += client.interceptors // 用户传入的拦截器 interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) &#123; // 如果不是WebSocket链接 // 将添加用户传入的网络拦截器 interceptors += client.networkInterceptors &#125; interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis) var calledNoMoreExchanges = false try &#123; val response = chain.proceed(originalRequest) if (transmitter.isCanceled) &#123; // 关闭Response.body.source response.closeQuietly() throw IOException(&quot;Canceled&quot;) &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges = true // 释放链接 throw transmitter.noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null) &#125; &#125;&#125; 将用户传入的一些拦截器和OkHttp自带的拦截器加入到interceptors列表中，然后创建一个拦截器链RealInterceptorChain，并调用其proceed()开始处理网络请求。 下面来看看RealInterceptorChain是如何处理网络请求的： 123456789101112131415161718192021222324252627282930313233343536373839class RealInterceptorChain( private val interceptors: List&lt;Interceptor&gt;, private val transmitter: Transmitter, private val exchange: Exchange?, private val index: Int, private val request: Request, private val call: Call, private val connectTimeout: Int, private val readTimeout: Int, private val writeTimeout: Int) : Interceptor.Chain &#123; private var calls: Int = 0 ... @Throws(IOException::class) fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response &#123; if (index &gt;= interceptors.size) throw AssertionError() calls++ ... // 在index为n的时候创建一个index为n+1的拦截器链 val next = RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout) val interceptor = interceptors[index] @Suppress(&quot;USELESS_ELVIS&quot;) val response = interceptor.intercept(next) ?: throw NullPointerException( &quot;interceptor $interceptor returned null&quot;) check(exchange == null || index + 1 &gt;= interceptors.size || next.calls == 1) &#123; &quot;network interceptor $interceptor must call proceed() exactly once&quot; &#125; check(response.body != null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125; return response &#125;&#125; 上面的逻辑相当于： 在getResponseWithInterceptorChain()创建了一个index为0的RealInterceptorChain，接着就调用了其proceed() 在RealInterceptorChain.proceed()中，当index为n的时候创建一个index为n+1的拦截器链 执行interceptor.intercept(next)的时候会调用chain.proceed()，相当于回到了RealInterceptorChain.proceed()调用。(CallServerInterceptor是最后添加的，而且里面并没有执行chain.proceed()，它是直接与服务器建立连接。) 可以看到我们自定义token拦截器的时候也会执行chain.proceed() 12345678910class RequestInterceptor : Interceptor &#123; @Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response &#123; val r = chain.request().newBuilder() if (token) &#123; r.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;) &#125; return chain.proceed(r.build()) &#125;&#125; 下图为OkHttp工作的大致流程，来自拆轮子系列：拆 OkHttp： 接下来我们看看这些拦截器的一些实现 6. RetryAndFollowUpInterceptor重试、重定向拦截器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Interceptor &#123; @Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response &#123; var request = chain.request() val realChain = chain as RealInterceptorChain val transmitter = realChain.transmitter() var followUpCount = 0 var priorResponse: Response? = null while (true) &#123; transmitter.prepareToConnect(request) if (transmitter.isCanceled) &#123; throw IOException(&quot;Canceled&quot;) &#125; var response: Response var success = false try &#123; // 进行正常请求 response = realChain.proceed(request, transmitter, null) success = true &#125; catch (e: RouteException) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.lastConnectException, transmitter, false, request)) &#123; throw e.firstConnectException &#125; continue &#125; catch (e: IOException) &#123; // An attempt to communicate with a server failed. The request may have been sent. val requestSendStarted = e !is ConnectionShutdownException if (!recover(e, transmitter, requestSendStarted, request)) throw e continue &#125; finally &#123; // The network call threw an exception. Release any resources. if (!success) &#123; transmitter.exchangeDoneDueToException() &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; // 使用priorResponse新建Response并将Body设为空 response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build() &#125; val exchange = response.exchange val route = exchange?.connection()?.route() // 重试 val followUp = followUpRequest(response, route) if (followUp == null) &#123; if (exchange != null &amp;&amp; exchange.isDuplex) &#123; transmitter.timeoutEarlyExit() &#125; return response &#125; val followUpBody = followUp.body if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) &#123; return response &#125; response.body?.closeQuietly() if (transmitter.hasExchange()) &#123; exchange?.detachWithViolence() &#125; // 重试次数 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;) &#125; request = followUp // 将重试Response添加priorResponse priorResponse = response &#125; &#125;&#125; 首先正常进行请求，如果请求成功则在finally中释放资源，然后返回Response。如果遇到不可修复的异常则抛出异常并跳出循环，否则使用followUpRequest()进行重试","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"https://blog.xusheng.online/tags/OkHttp/"}]},{"title":"通过Git自动更新Android编译版本号","slug":"通过Git自动更新Android编译版本号","date":"2019-07-04T09:21:02.000Z","updated":"2020-09-13T12:40:43.736Z","comments":true,"path":"2019/07/04/通过Git自动更新Android编译版本号/","link":"","permalink":"https://blog.xusheng.online/2019/07/04/%E9%80%9A%E8%BF%87Git%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0Android%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E5%8F%B7/","excerpt":"","text":"我们公司的Android打包是通过使用Jenkins，然后Jenkins将打包好的App发布到下载服务器供测试同学进行测试。虽然Jenkins上可以通过使用脚本来指定对应的版本号和版本名称，但是这种方式并不优雅。 本文试图提供一种更优雅的方式来管理应用版本的方法。 1. Android应用版本我们都知道Android应用的版本是通过指定AndroidManifest.xml文件属性来完成的： 123456&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.zzt8888.construction.assistant&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0.0&quot; &gt; ...&lt;/manifest&gt; versionCode：版本号，用作内部版本号。此数字仅用于确定某个版本是否比另一个版本更新：数字越大，则版本越新。 versionName：一个字符串，用作向用户显示的版本号。 要为应用定义版本信息，需要在 Gradle 构建文件中为版本设置设定相应的值。这些值随后会在构建流程中合并到应用的AndroidManifest.xml中。 12345678910111213android &#123; defaultConfig &#123; applicationId &quot;com.example.app&quot; minSdkVersion 16 targetSdkVersion 29 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; &#125; ...&#125; 2. VersionName通常在我们发布应用的时候都会打一个tag，这个tag也就是应用的版本名。 git通过git describe --tags可以获取到最新的tag信息，类似如下： 1v_2.3-35-g123123 其中v_2.3是tag的名字，35是tag后提交的次数，123123是最新提交的id。 在build.gradle中使用git describe --tags来自动更新版本名： 123456789101112 def _versionName() &#123; def cmd &#x3D; &#39;git describe --tags&#39; def version &#x3D; cmd.execute().text.trim() def pattern &#x3D; &quot;-(\\\\d+)-g&quot; def matcher &#x3D; version &#x3D;~ pattern if (matcher) &#123; version &#x3D; version.substring(0, matcher.start()) + &quot;-&quot; + matcher[0][1] &#125; else &#123; version &#x3D; version + &quot;-0&quot; &#125; return version&#125; 3. VersionCode一般来说，我们的往 Git 库中提交的 Commit 的数量应该是逐渐增加的。这样我们就可以使用git的Commit次数作为VersionCode。 1234def _versionCode() &#123; def cmd = &#x27;git rev-list HEAD --first-parent --count&#x27; return cmd.execute().text.trim().toInteger()&#125; 之前我们Jenkins上是每编译一次，版本号就加一。个人很不合理的，如果是相同的代码，发布出去版本号应该保持一致，而不在于你编译多少次。 另外，VersionCode是一个32位的int类型，最大值是2147483647，使用commit次数并不会导致过大。 4. 优化build.gradle尽可能减少 gradle 脚本的运算，提高编译速度，我们可以把这样的自动版本的计算放到 release 编译中去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def _versionCode() &#123; def cmd = &#x27;git rev-list HEAD --first-parent --count&#x27; return cmd.execute().text.trim().toInteger()&#125;def _versionName() &#123; def cmd = &#x27;git describe --tags&#x27; def version = cmd.execute().text.trim() def pattern = &quot;-(\\\\d+)-g&quot; def matcher = version =~ pattern if (matcher) &#123; version = version.substring(0, matcher.start()) + &quot;-&quot; + matcher[0][1] &#125; else &#123; version = version + &quot;-0&quot; &#125; return version&#125;android &#123; defaultConfig &#123; applicationId &quot;com.example.test&quot; versionCode 999999 versionName &quot;1.0.0&quot; ... &#125; applicationVariants.all &#123; variant -&gt; // 只在release的时候才使用自动版本号 if (variant.buildType.name == &quot;release&quot;) &#123; variant.outputs.all &#123; output -&gt; def date = new Date().format(&quot;yyyyMMddHHmmss&quot;, TimeZone.getTimeZone(&quot;GMT+08&quot;)) if (variant.buildType.name == &#x27;release&#x27;) &#123; output.versionCodeOverride = _versionCode() output.versionNameOverride = _versionName() // 输出文件名 outputFileName = &quot;xiaozhu_release_$&#123;date&#125;_$&#123;_versionName()&#125;_$&#123;_versionCode()&#125;.apk&quot; &#125; &#125; &#125; &#125; ...&#125;","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://blog.xusheng.online/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.xusheng.online/tags/Git/"}]},{"title":"RxJava2源码解析-线程切换","slug":"RxJava2源码解析-线程切换","date":"2019-05-20T09:32:10.000Z","updated":"2020-09-13T12:40:43.730Z","comments":true,"path":"2019/05/20/RxJava2源码解析-线程切换/","link":"","permalink":"https://blog.xusheng.online/2019/05/20/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/","excerpt":"","text":"1. 示例代码1234567891011121314151617181920212223242526thread(name = &quot;subscribe thread&quot;, start = true) &#123; Observable.create&lt;String&gt; &#123; Log.d(TAG, &quot;create: $&#123;Thread.currentThread().name&#125;&quot;) it.onNext(&quot;1&quot;) it.onComplete() &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Observer&lt;String&gt; &#123; override fun onComplete() &#123; Log.d(TAG, &quot;onComplete: $&#123;Thread.currentThread().name&#125;&quot;) &#125; override fun onSubscribe(d: Disposable) &#123; Log.d(TAG, &quot;onSubscribe: $&#123;Thread.currentThread().name&#125;&quot;) &#125; override fun onNext(t: String) &#123; Log.d(TAG, &quot;onNext: $&#123;Thread.currentThread().name&#125;&quot;) &#125; override fun onError(e: Throwable) &#123; Log.d(TAG, &quot;onError: $&#123;Thread.currentThread().name&#125;&quot;) &#125; &#125;)&#125; 运行结果： 1234D&#x2F;MainActivity: onSubscribe: subscribe threadD&#x2F;MainActivity: create: RxCachedThreadScheduler-1D&#x2F;MainActivity: onNext: mainD&#x2F;MainActivity: onComplete: main 根据运行结果我们可以发现： onSubscribe()发生在调用线程 subscribeOn()决定了上游数据产生的线程 observeOn()决定了下游数据订阅时的线程 2. obServeOn()observeOn()用来指定观察者回调的线程，我们进入到这个方法中： 12345678910111213 public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize()); &#125; public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError) &#123; return observeOn(scheduler, delayError, bufferSize()); &#125; public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize)); &#125; 该方法执行后会返回一个ObservableObserveOn对象，进入到ObservableObserveOn的subscribeActual()： 12345678910111213protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // 如果传入的是Schedulers.trampoline(), 不做线程切换 // 我们传入的是AndroidSchedulers.mainThread() if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; // 通过传入的scheduler来创建一个Worker Scheduler.Worker w = scheduler.createWorker(); // 直接调用了上游ObservableSource的订阅方法 // 因此observeOn不会影响到上游ObservableSource运行环境 source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125; &#125; 因为我们传入的是AndroidSchedulers.mainThread()，所以在这里scheduler.createWorker()创建的是一个HandlerWorker(handler, async)。这里先不去细说，先来看看Worker到底是干什么的。 进入到ObserveOnObserver中，来看看它的onSubscribe()： 12345678910111213141516171819202122232425static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;implements Observer&lt;T&gt;, Runnable &#123; SimpleQueue&lt;T&gt; queue; Disposable upstream; ... ObserveOnObserver(Observer&lt;? super T&gt; actual, Scheduler.Worker worker, boolean delayError, int bufferSize) &#123; this.downstream = actual; ... &#125; @Override public void onSubscribe(Disposable d) &#123; if (DisposableHelper.validate(this.upstream, d)) &#123; this.upstream = d; if (d instanceof QueueDisposable) &#123; ... &#125;// 创建一个单生产者单消费者的队列 queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize);// 直接调用上游Observer的onSubscribe方法 downstream.onSubscribe(this); &#125; &#125;&#125; 可以看到在ObserveOnObserver的onSubscribe中直接调用了上游ObservableSource的onSubscribe()，这说明了observeOn()不会影响上游线程执行环境，也不会影响下游Observer的onSubscribe()回调的线程。 在看看ObserveOnObserver的onNext()： 1234567891011121314151617181920212223@Overridepublic void onNext(T t) &#123; // 在onCompete和onError中done被设置为了true if (done) &#123; return; &#125; // 如果是非异步操作, 将数据添加到队列中 if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125;void schedule() &#123; // ObserveOnObserver类间接继承了AtomicInteger // getAndIncrement()只有在第一次执行的时候才返回0，后面执行会自增 // 所以worker.schedule(this)只会执行一次 if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; Worker.schedule(Runnable run)方法直接调用了重载方法schedule(Runnable run, long delay, TimeUnit unit)，后面的两个参数为0L, TimeUnit.NANOSECONDS，这就意味着立刻马上执行run()。 RxAndroid 由于上面的worker是通过AndroidSchedulers.mainThread()创建的，所以这里就要看看RxAndroid这个库的代码了。RxANdroid总共就4个文件，其中两个文件比较重要：HandlerScheduler以及封装了该类的AndroidSchedulers。AndroidSchedulers提供了两个公有静态方法来切换线程： mainThread()指定主线程 from(Looper looper)指定别的线程 这两者都是通过创建HandlerScheduler时指定Handle的Looper来实现的，AndroidSchedulers代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public final class AndroidSchedulers &#123; private static final class MainHolder &#123; static final Scheduler DEFAULT &#x3D; new HandlerScheduler(new Handler(Looper.getMainLooper()), false); &#125; private static final Scheduler MAIN_THREAD &#x3D; RxAndroidPlugins.initMainThreadScheduler( new Callable&lt;Scheduler&gt;() &#123; @Override public Scheduler call() throws Exception &#123; return MainHolder.DEFAULT; &#125; &#125;); public static Scheduler mainThread() &#123; return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD); &#125; public static Scheduler from(Looper looper) &#123; return from(looper, false); &#125; @SuppressLint(&quot;NewApi&quot;) &#x2F;&#x2F; Checking for an @hide API. public static Scheduler from(Looper looper, boolean async) &#123; if (looper &#x3D;&#x3D; null) throw new NullPointerException(&quot;looper &#x3D;&#x3D; null&quot;); if (Build.VERSION.SDK_INT &lt; 16) &#123; async &#x3D; false; &#125; else if (async &amp;&amp; Build.VERSION.SDK_INT &lt; 22) &#123; &#x2F;&#x2F; Confirm that the method is available on this API level despite being @hide. Message message &#x3D; Message.obtain(); try &#123; message.setAsynchronous(true); &#125; catch (NoSuchMethodError e) &#123; async &#x3D; false; &#125; message.recycle(); &#125; return new HandlerScheduler(new Handler(looper), async); &#125; private AndroidSchedulers() &#123; throw new AssertionError(&quot;No instances.&quot;); &#125;&#125; 再说说另外一个关键文件HandlerScheduler，该类的作用就是将Runnable使用指定的Handler来执行。 该类的两个公共方法：scheduleDirect()方法直接执行Runnable；或者通过createWorker()创建一个HandlerWorker对象，稍后通过该对象的schedule方法执行Runnable。该文件比较简单，不做过多描述。 回到ObserveOnObserver.schedule()中，这里调用了worker.schedule(this)。说明已经通过HandlerScheduler回到了主线程。 ObserveOnObserver实现了Runnable接口，接着就看看它的run()： 12345678910@Overridepublic void run() &#123; // 断点查看的时候这里为false // 暂时不清楚这是来干嘛的😊 if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; 接下来进入drainNormal()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 void drainNormal() &#123; int missed = 1;// queue在onSubscribe中创建，然后在onNext中添加了值 final SimpleQueue&lt;T&gt; q = queue; // 下游的Observer final Observer&lt;? super T&gt; a = downstream; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; // 从queue中取值 try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); disposed = true; upstream.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; // 将取到的值发射给下游Observer a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125; &#125; 所以这里的流程大致如下： ObservableObserveOn将Observer包装成ObserveOnObserver，并调用了上游ObservableSource的source.subscribe()。(observeOn不会影响到上游ObservableSource运行环境） ObserveOnObserver在onSubscribe()被调用的时候创建了一个SpscLinkedArrayQueue&lt;T&gt;(bufferSize)队列并调用上游Observer的onSubscribe()方法(不会影响下游Observer的onSubscribe()回调的线程)。 ObserveOnObserver将onNext()中接收到的值存入到队列中并开始切换线程。 ObserveOnObserver在线程的run()中取出队列中的值，然后调用下游的onNext()、onError()。 至此，observeOn()工作原理已经解释完毕。我们已经知道了observeOn()是如何决定了下游订阅发生的线程的：将Runnable抛给指定的线程池来执行，Runnable里面会调用下游observer的onNext方法。 3. subscribeOn()subscribeOn()切换原理和observeOn()非常相似。 在Observable.subscribeOn()方法中，创建了一个ObservableSubscribeOn对象。 我们先进入到subscribeActual()中： 12345678910 @Override public void subscribeActual(final Observer&lt;? super T&gt; observer) &#123; // 将下游observer包装成为SubscribeOnObserver final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer);// 在Observable创建线程调用下游的onSubscribe方法 observer.onSubscribe(parent); // SubscribeTask是一个Runnable对象，其run方法为：source.subscribe(parent) // 调用scheduler.scheduleDirect开始执行Runnable parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); &#125; 和上面分析的observeOn()类似，scheduler.scheduleDirect()是一个线程切换的过程。 线程切换之后就会执行source.subscribe(parent)。就这样subscribe()会一直向上传递到数据发射的位置，发射数据的方法的线程自然也会发生改变。 我们先看看scheduler.scheduleDirect()干了什么，因为我们传入的是Schedulers.io()，scheduleDirect()调的是其基类Scheduler的方法： 1234567891011121314151617@NonNullpublic Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125;@NonNullpublic Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // DisposeTask的run方法就是调用decoratedRun的run方法 DisposeTask task = new DisposeTask(decoratedRun, w); // w是IoScheduler创建的EventLoopWorker w.schedule(task, delay, unit); return task;&#125; 接着进入EventLoopWorker.schedule() ： 12345678910@NonNull@Overridepublic Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don&#x27;t schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125; return threadWorker.scheduleActual(action, delayTime, unit, tasks);&#125; 这里的threadWorker其实就是继承自NewThreadWorker，直接查看NewThreadWorker.scheduleActual()： 1234567891011121314151617181920212223242526272829 public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123; Runnable decoratedRun = RxJavaPlugins.onSchedule(run);// runnable ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); if (parent != null) &#123; if (!parent.add(sr)) &#123; return sr; &#125; &#125; Future&lt;?&gt; f; try &#123; // 根据延时时间来执行ScheduledRunnable if (delayTime &lt;= 0) &#123; f = executor.submit((Callable&lt;Object&gt;)sr); &#125; else &#123; f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); &#125; sr.setFuture(f); &#125; catch (RejectedExecutionException ex) &#123; if (parent != null) &#123; parent.remove(sr); &#125; RxJavaPlugins.onError(ex); &#125; return sr; &#125; 这个时候开始的SubscribeTask就会在指定的Schedules.io()线程池中运行了。 为什么subscribeOn()只有第一次切换有效？ 因为RxJava订阅的时候是从下往上订阅，所以从上往下第一个subscribeOn()就是最后运行的。所以能影响ObservableOnSubscribe这个匿名实现接口的运行环境的只能是最后一次subscribe()操作(也就是调用链的第一次subscribeOn())。","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://blog.xusheng.online/tags/RxJava/"}]},{"title":"RxJava2源码解析-订阅流程","slug":"RxJava2源码解析-订阅流程","date":"2019-04-18T04:33:40.000Z","updated":"2020-09-13T12:40:43.730Z","comments":true,"path":"2019/04/18/RxJava2源码解析-订阅流程/","link":"","permalink":"https://blog.xusheng.online/2019/04/18/RxJava2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AE%A2%E9%98%85%E6%B5%81%E7%A8%8B/","excerpt":"","text":"RxJava就是一种用Java语言实现的响应式编程，通过使用可观察的序列来组成异步和基于事件的程序。 本文基于代码基于RxJava v2.2.6和RxAndroid 2.1.0，文中以Observable为例来进行分析。 1. 使用示例在App的build.gradle中添加依赖： 12implementation &quot;io.reactivex.rxjava2:rxjava:2.2.6&quot;implementation &#x27;io.reactivex.rxjava2:rxandroid:2.1.0&#x27; 开始使用 12345678910111213141516171819202122232425262728293031323334// 被观察者者val observable = object : ObservableOnSubscribe&lt;String&gt; &#123; override fun subscribe(emitter: ObservableEmitter&lt;String&gt;) &#123; emitter.onNext(&quot;1&quot;) emitter.onComplete() &#125;&#125;// map转换val mapFunc = object : Function&lt;String, Int&gt; &#123; override fun apply(t: String): Int &#123; return t.toInt() * 10 &#125;&#125;// 观察者val observer = object : Observer&lt;Int&gt; &#123; override fun onComplete() &#123; Log.d(TAG, &quot;onComplete: &quot;) &#125; override fun onSubscribe(d: Disposable) &#123; Log.d(TAG, &quot;onSubscribe: &quot;) &#125; override fun onNext(t: Int) &#123; Log.d(TAG, &quot;onNext: $t&quot;) &#125; override fun onError(e: Throwable) &#123; Log.d(TAG, &quot;onError: &quot;) &#125;&#125;// 链式调用Observable.create(observable).map(mapFunc).subscribe(observer) 输出结果 123D&#x2F;MainActivity: onSubscribe: D&#x2F;MainActivity: onNext: 10D&#x2F;MainActivity: onComplete: 2. 订阅流程分析在分析源码之前，我们先理清这几个类有助于后面的分析： ObservableSource：数据源，在订阅时会被Observer消耗。它是一个接口。 Observable：ObservableSource的实现类。Observable是一个抽象类，它里面只有一个抽象方法subscribeActual()。它是Observable.subscribe()实际调用的方法。 Emitter：用于发射数据 Observer：数据的接收者(观察者？) 下面根据例子来看看Rxjava是怎么处理数据的。 Observable.create() 先看看Observable.create()方法： 123456public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; // 检查传入的source是否为null ObjectHelper.requireNonNull(source, &quot;source is null&quot;); // 尝试使用RxJavaPlugins.onAssembly转换ObservableCreate return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; RxJavaPlugins.onAssembly()是一个hook方法，将传入的Observable对象转换为另一个Observable对象。 1234567891011121314151617181920@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125;@Nullable@SuppressWarnings(&quot;rawtypes&quot;)public static Function&lt;? super Observable, ? extends Observable&gt; getOnObservableAssembly() &#123; return onObservableAssembly;&#125;@Nullable@SuppressWarnings(&quot;rawtypes&quot;)public static Function&lt;? super ConnectableObservable, ? extends ConnectableObservable&gt; getOnConnectableObservableAssembly() &#123; return onConnectableObservableAssembly;&#125; Observable对象是否转换取决于onObservableAssembly是否为空。默认情况下，onObservableAssembly是空值，但是可以通过RxJavaPlugins的静态方法进行get/set。 由于onObservableAssembly为空所以Observable.create(observable)和ObservableCreate(observable)是相同的。 例子中的调用方式就可以变为： 1ObservableCreate(observable).map(mapFunc).subscribe(observer) map() 下面进入到map()操作符： 1234public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; 这段代码与create()操作符类似，这里直接返回了一个ObservableMap对象。 再次把ObservableMap带入到调用中就变成这样了： 1ObservableMap(ObservableCreate(observable), mapFunc).subscribe(observer) 这里我们已经建立了两个Observable对象了，一个用于数据创建的ObservableCreate和一个用于数据转换的ObservableMap。这就是在订阅发生前数据的调流程了。 每个操作符都会创建一个新的Observable实例，并将上一个Observable的实例作为参数传入到构造函数中。这就是为什么RxJava中的数据为什么会依次经过这些操作符的原因了。 操作符中创建的实例都是Observable的实现类，它们实现subscribeActual()抽象方法。 subscribe() 接下来我们看看订阅发生后的流程。进入到subscribe()中： 123456789101112131415161718192021222324public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;); try &#123; // onSubscribe也是一个hook方法，和onAssembly()类似 observer = RxJavaPlugins.onSubscribe(this, observer); // 判断observer是否为null ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;); // 调用真正的订阅 subscribeActual(observer); // 直接捕获异常，不向外抛出 &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can&#x27;t call onError because no way to know if a Disposable has been set or not // can&#x27;t call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(&quot;Actually not, but can&#x27;t throw other exceptions due to RS&quot;); npe.initCause(e); throw npe; &#125;&#125; 看看上面map的流程我们就知道subscribeActual()现在执行的是ObservableMap中的方法。 我们看看ObservableMap中是如何实现的： 1234567891011121314151617public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123; final Function&lt;? super T, ? extends U&gt; function; public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123; super(source); this.function = function; &#125; @Override public void subscribeActual(Observer&lt;? super U&gt; t) &#123; source.subscribe(new MapObserver&lt;T, U&gt;(t, function)); &#125; static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123; ... &#125;&#125; MapObserver是Observer的实现类。将MapObserver带入到订阅后的代码中： 1ObservableCreate(observable).subscribe(ObservableMap.MapObserver(observer, mapFunc)) 接下来就看看ObservableCreate了： 1234567891011121314151617181920212223242526272829public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // observer回调onSubscribe，表示已经开始订阅 observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125; &#125; static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable &#123; ... &#125;&#125; 我们继续CreateEmitter将代入订阅流程 1observable.subscribe(ObservableCreate.CreateEmitter(ObservableMap.MapObserver(observer, mapFunc))) 这里执行的时候并没有出现D/MainActivity: onSubscribe: 日志，从上面的代码可以看到onSubscribe()不是由CreateEmitter调用的。所以我们知道不管Observable如何切线程，onSubscribe()都是在调用线程中执行的。 3. 总结我们先基于实例代码来看看操作符和订阅是一步一步执行的： 1234567891011&#x2F;&#x2F; 原始调用Observable.create(observable).map(mapFunc).subscribe(observer)&#x2F;&#x2F; &#x3D;&#x3D;》将observable放入ObservableCreate中ObservableCreate(observable).map(mapFunc).subscribe(observer)&#x2F;&#x2F; &#x3D;&#x3D;》将ObservableCreate放入ObservableMap中ObservableMap(ObservableCreate(observable), mapFunc).subscribe(observer)&#x2F;&#x2F; &#x3D;&#x3D;》 订阅开始&#x2F;&#x2F; &#x3D;&#x3D;》 调用ObservableMap中的subscribeActual，将observer放入MapObserver中ObservableCreate(observable).subscribe(ObservableMap.MapObserver(observer, mapFunc))&#x2F;&#x2F; &#x3D;&#x3D;》 调用ObservableCreate中的subscribeActual，将MapObserver放入CreateEmitter中observable.subscribe(ObservableCreate.CreateEmitter(ObservableMap.MapObserver(observer, mapFunc))) 可以看出在执行subscribe()之前，链式调用一步步从前往后展开，将前面的前面的操作符都会作为参数传入后面的操作符中。 当执行``subscribe()`执行时，会从最后面的操作符开始订阅。","categories":[{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://blog.xusheng.online/tags/RxJava/"}]},{"title":"Retrofit2 源码解析","slug":"Retrofit2-源码解析","date":"2019-03-19T11:12:52.000Z","updated":"2020-09-13T12:40:43.730Z","comments":true,"path":"2019/03/19/Retrofit2-源码解析/","link":"","permalink":"https://blog.xusheng.online/2019/03/19/Retrofit2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Retrofit2 源码解析Retrofit是适用于Android和Java的类型安全的Http客户端，网络请求的工作本质是在OkHttp上完成，而Retrofit仅负责网络请求接口的封装。 本文代码基于Retrofit-2.8.0 1. 基本使用 定义Http API接口信息 1234interface GitHubService &#123; @GET(&quot;users/&#123;user&#125;/repos&quot;) fun listRepos(@Path(&quot;user&quot;) user: String?): Call&lt;ResponseBody&gt;&#125; 利用Retrofit生成GithubService的实现 1234val retrofit: Retrofit = Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .build()val service: GitHubService = retrofit.create(GitHubService::class.java) 通过GithubService的实现获取请求返回结果 123456789101112val call = service.listRepos(&quot;xshengcn&quot;)// val response = call.execute() // 同步执行val callback:Callback&lt;ResponseBody&gt; = object : Callback&lt;ResponseBody&gt; &#123; override fun onResponse(call: Call&lt;ResponseBody&gt;, response: Response&lt;ResponseBody&gt;) &#123; Log.d(&quot;Callback&quot;, &quot;onResponse: $call, $response&quot;) &#125; override fun onFailure(call: Call&lt;ResponseBody&gt;, t: Throwable) &#123; &#125;&#125;call.enqueue(callback) 2. 源码分析2.1 Retrofit.build()我们先看看Retrofit.Builder在创建Retrofit时干了些什么。这里直接查看它的build方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 public Retrofit build() &#123; if (baseUrl == null) &#123; // 如果不传入base url就抛出异常 throw new IllegalStateException(&quot;Base URL required.&quot;); &#125; // 如果没有传入自定义的OkHttpClient就创建一个新的 // OkHttpClient实现了okhttp3.Call.Factory接口 okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // 没有设置过callbackExecutor，且此处platform为Android // 因此这里被赋值为了MainThreadExecutor Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // 将设置的CallAdapter.Factory添加到集合中 // 并添加根据不同平台添加默认的CallAdapter.Factory // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); // 将设置的Converter.Factory添加到集合中 // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. // 添加了一个内置的BuiltInConverters converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); // 并添加根据不同平台添加默认的Converter.Factory converterFactories.addAll(platform.defaultConverterFactories()); return new Retrofit( callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); &#125;&#125; Retrofit对象已经创建了，其构造器实现都是赋值语句。我们先简单介绍一下几个关键类吧： CallAdapter.Factory：用于创建CallAdapter实例的工厂。 CallAdapter：将一个Call从响应类型R适配成T类型的适配器 12345678public interface CallAdapter&lt;R, T&gt; &#123; // 将HTTP响应体转换为Java对象时，该对象的类型 Type responseType(); // 返回一个代理了call的T T adapt(Call&lt;R&gt; call); ...&#125; Converter.Factory：基于一个类型和目标类型创建一个Converter实例的工厂。 Converter ：将F类型的值转换为T类型。 1234public interface Converter&lt;F, T&gt; &#123; @Nullable T convert(F value) throws IOException;&#125; 2.2 Retrofit.create 通过上面的使用步骤，可以看到是Retrofit通过create方法创建了一个具体的实例。直接查看create的源码： 12345678910111213141516171819202122232425262728public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;// 验证service接口信息validateServiceInterface(service); // 通过动态代理返回service实例return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class&lt;?&gt;[] &#123;service&#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // 如果是调用的Object中的方法，那就直接执行此方法 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; // 通过Platform.get()获取平台信息，这里是Android if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 加载service method return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;); &#125; InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。 在InvocationHandler中，这里面最重要的就是loadServiceMethod(method).invoke()，通过Method信息获取的ServiceMethod后并调用invoke。 loadServiceMethod 那我们先看看``loadServiceMethod(method)`到底干了哪些事情： 123456789101112131415ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123; // 如果serviceMethodCache中缓存了ServiceMethod直接返回 ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; // 将service中的method解析为ServiceMethod result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); // 加入缓存 &#125; &#125; return result;&#125; 可以明显的看出这里采取了缓存的设计，所以Retrofit使用单例时才能发挥最大的作用。 这段代码的重点就是ServiceMethod.parseAnnotations(this, method)。那么就继续进入到ServiceMethod。 ServiceMethod 1234567891011121314151617181920212223242526272829abstract class ServiceMethod&lt;T&gt; &#123; /** * 将Service接口中的方法转化为ServiceMethod */ static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123; // 解析方法信息对应的请求信息 RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); // 获取方法的返回值类型 Type returnType = method.getGenericReturnType(); // 验证返回类型 if (Utils.hasUnresolvableType(returnType)) &#123; // 方法返回类型不得包含类型变量或通配符 throw methodError( method, &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType); &#125; // 方法返回类型不能是void if (returnType == void.class) &#123; throw methodError(method, &quot;Service methods cannot return void.&quot;); &#125; // 使用HttpServiceMethod解析 return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); &#125; abstract @Nullable T invoke(Object[] args);&#125; ServiceMethod是一个抽象类，loadServiceMethod(method).invoke()调用的就是它的抽象方法invoke()。 它在解析方法的时候先取出要调用方法的注解、参数以及参数注解等，生成对于的http请求信息。这里的方法太长，就贴了几个重要的。 12345678910111213141516171819202122232425262728final class RequestFactory &#123;static RequestFactory parseAnnotations(Retrofit retrofit, Method method) &#123; return new Builder(retrofit, method).build();&#125;Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); // 获取方法的注解 this.parameterTypes = method.getGenericParameterTypes(); // 获取方法的参数类型 this.parameterAnnotationsArray = method.getParameterAnnotations(); // 获取方法的参数注解 &#125; RequestFactory build() &#123; for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); // 解析方法注解, 并判断注解的合法性(例如header是否为空等) &#125; ...一些判断 return new RequestFactory(this); &#125; /** * 解析注解， 并为httpMethod(GET, POST等), hasBody等赋值 */ private void parseMethodAnnotation(Annotation annotation) &#123; ... &#125;&#125; ServiceMethod解析了部分信息后继续交由HttpServiceMethod来解析，并返回了HttpServiceMethod&lt;ResponseT, ReturnT&gt;。 HttpServiceMethod HttpServiceMethod是ServiceMethod的子类，我们先来看看它的parseAnnotations是如何工作的。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 检查接口方法上的注释，以构造使用HTTP的可重用服务方法。 这需要潜在的昂贵反射，因此最好只构建一次每个服务方法并重用它。 */static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) &#123; ... Annotation[] annotations = method.getAnnotations(); // 获取方法的注解 Type adapterType; // 返回值类型 如Call&lt;Data&gt;或者Observable&lt;Data&gt; ... adapterType = method.getGenericReturnType(); ... // 从传入大CallAdapter.Factory中查找匹配的CallAdapter，如RxJava2CallAdapter CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); // CallAdapter返回的类型 ，如Data Type responseType = callAdapter.responseType(); // 不是有效的返回类型 if (responseType == okhttp3.Response.class) &#123; throw methodError( method, &quot;&#x27;&quot; + getRawType(responseType).getName() + &quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;); &#125; // 返回类型必须包含通用类型（例如Response &lt;String&gt;） if (responseType == Response.class) &#123; throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;); &#125; ... // 从Converter.Factory中查找匹配的Converter，GsonResponseBodyConverter Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; ... return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter); ...&#125; 我们过滤掉处理协程的相关部分，发现这里做了这几部分工作： 根据方法的返回值类型等信息从Retrofit.Builder中的callAdapterFactories获取CallAdapter。 获取到CallAdapter后根据它的responseType()得到的类型获取到对应的Converter 用Converter和 callAdapter等创建CallAdapted CallAdapted loadServiceMethod(method)获取到ServiceMethod实例就是CallAdapted了，所以invoke调用的就是CallAdapted.invoke() 12345678910111213141516171819202122232425262728293031abstract class HttpServiceMethod&lt;ResponseT, ReturnT&gt; extends ServiceMethod&lt;ReturnT&gt; &#123; ... @Override final @Nullable ReturnT invoke(Object[] args) &#123; Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter); return adapt(call, args); &#125; protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args); static final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123; private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter; CallAdapted( RequestFactory requestFactory, okhttp3.Call.Factory callFactory, Converter&lt;ResponseBody, ResponseT&gt; responseConverter, CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123; super(requestFactory, callFactory, responseConverter); this.callAdapter = callAdapter; &#125; @Override protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123; return callAdapter.adapt(call); &#125; &#125; ...&#125; 因为它继承于HttpServiceMethod，而且并没有重写invoke方法。所以这里就是创建好一个OkHttpCall后并通过callAdapter.adapt()返回一个对象。 这里的CallAdapter是什么呢？我们在Retrofit.build()时添加了一个默认的CallAdapter.Factory，它就是DefaultCallAdapterFactory： 1callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); 我们进入到DefaultCallAdapterFactory查看它通过get()获取的是什么CallAdapter，并且通过callAdapter.adapt(call)返回是什么对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344final class DefaultCallAdapterFactory extends CallAdapter.Factory &#123; private final @Nullable Executor callbackExecutor; DefaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public @Nullable CallAdapter&lt;?, ?&gt; get( Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; // 返回类型必须通过Call包装，如Call&lt;Foo&gt; if (!(returnType instanceof ParameterizedType)) &#123; throw new IllegalArgumentException( &quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;); &#125; // 获取返回类型 Foo final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType); // 如果有SkipCallbackExecutor注解就是空否则是Retrofit#build时传入的 final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class) ? null : callbackExecutor; return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; // 因为Retrofit#build时并未添加executor，所以返回的是Call本身(OkHttpCall) return executor == null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; ... &#125;&#125; 所以loadServiceMethod(method).invoke(args != null ? args : emptyArgs)返回的就是一个OkHttpCall对象。 Call 这时候Retrofit还没有进行网络请求，当执行execute()或者enqueue()才开始进行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; ... @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, &quot;callback == null&quot;); okhttp3.Call call; ... call = rawCall; ... call = rawCall = createRawCall(); ... call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; ... response = parseResponse(rawResponse); ... callback.onResponse(OkHttpCall.this, response); ... &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; private void callFailure(Throwable e) &#123; ... callback.onFailure(OkHttpCall.this, e); ... &#125; &#125;); &#125; @Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; ... call = rawCall; .... call = rawCall = createRawCall(); ... return parseResponse(call.execute()); &#125; private okhttp3.Call createRawCall() throws IOException &#123; okhttp3.Call call = callFactory.newCall(requestFactory.create(args)); if (call == null) &#123; throw new NullPointerException(&quot;Call.Factory returned null.&quot;); &#125; return call; &#125; Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ... ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody); ... T body = responseConverter.convert(catchingBody); return Response.success(body, rawResponse); ... &#125; ...&#125; Call在不管调用的是enqueue还是execute，都会创建一个okhttp3.Call，然后调用okhttp3.Call相应的方法。 在okhttp3.Call取得结果后就通过Converter.Factory创建的Converter解析生成接口的返回值。 3. 总结 Retrofit使用了动态代理实现了我们定义的接口。 在实现接口方法时，Retrofit会通过loadServiceMethod为每一个接口方法构建了一个ServiceMethod对象，并会缓存到ConcurrentHashMap中。 在ServiceMethod构建时，会根据接口方法的注解类型、参数类型以及参数注解来拼接请求参数、确定请求类型、构建请求体等来确定使用哪个CallAdapter和Converter，并返回CallAdapted对象 ServiceMethod.invoke()调用了CallAdapter.adapt，这里生成了OkHttpCall。当Call执行请求时也就是OkHttpCall在调用方法执行请求。 Call在不管调用的是enqueue还是execute，都会创建一个okhttp3.Call，然后调用okhttp3.Call相应的方法 在okhttp3.Call取得结果后就通过Converter.Factory创建的Converter解析生成接口的返回值。 这里并没有使用RxJava2CallAdapterFactory和GsonConverterFactory等，是最基础的Retrofit请求流程了。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"RecyclerView的缓存机制","slug":"RecyclerView的缓存机制","date":"2019-02-12T00:19:15.000Z","updated":"2020-09-14T07:11:48.685Z","comments":true,"path":"2019/02/12/RecyclerView的缓存机制/","link":"","permalink":"https://blog.xusheng.online/2019/02/12/RecyclerView%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1. Recycler同ListView里的RecycleBin缓存一样，RecyclerView中的缓存也由一个内部类Recycler进行管理。 Recycler里面有四个不同层次的缓存，比ListView层次要更丰富，这与RecyclerView拓展性更好有一定的关系。 Recycler里面主要字段如下： 123456789101112131415161718 public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2;&#125; 其中的字段作用如下： mAttachedScrap、mChangedScrap：一级缓存，在layout发生前将屏幕上面的ViewHolder保存起来，供layout中进行复用 mCachedViews：二级缓存，默认大小保持在DEFAULT_CACHE_SIZE = 2，可以通过RecyclerView.setItemViewCacheSize(int)方法进行设置 mCachedViews数量如果超出限制，会根据索引将里面旧的移动到RecyclerViewPool中 ViewCacheExtension：三级缓存，开发者可以自定义的缓存 RecyclerViewPool：四级缓存，可以在多个RecyclerView中共享缓存根据ViewType来缓存ViewHolder，每个ViewType的数组大小默认为DEFAULT_MAX_SCRAP = 5，超过部分会丢弃，可以通过其setMaxRecycledViews(int viewType, int max)方法来控制对应type的缓存池大小。 Recycler的方法本质上就是对上面数据结构的一些操作。主要的方法有： recycleView(View)：将view对应的ViewHolder移动到mCachedViews中；如果View是scrapped状态，会先unscrap recycleViewHolderInternal(ViewHolder)：将ViewHolder保存到mCachedViews中 addViewHolderToRecycledViewPool(ViewHolder, boolean)：将ViewHolder保存到RecycledViewPool中 scrapView(View)：将一个attached状态的View保存到mAttachedScrap或mChangedScrap中 getChangedScrapViewForPosition(int)：从mChangedScrap中寻找匹配的ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int, boolean)：依次从mAttachedScrap、mCachedViews中寻找匹配的ViewHolder getScrapOrCachedViewForId(long, int, boolean)：依次从mAttachedScrap、mCachedViews中寻找匹配的ViewHolder tryGetViewHolderForPositionByDeadline(int, boolean, long)：从mChangedScrap、mAttachedScrap、mCachedViews、ViewCacheExtension、RecycledViewPool中进行匹配；若匹配不了，最后会直接调用Adapter.createViewHolder方法进行创建 tryBindViewHolderByDeadline(ViewHolder, int, int, long)：调用Adapter.bindViewHolder方法绑定View 2. 缓存流程RecyclerView的缓存流程同ListView一样，也是体现在了layout过程中。 RecyclerView的layout流程分为三个方法，对应layout step的三个步骤： State.STEP_START：State.STEP_START状态可以执行，执行完毕后状态变成State.STEP_LAYOUT 处理Adapter的更新，更新一些相关的值 决定应该执行哪个动画 保存当前View的动画信息 如果有必要，执行预测性的layout并保存View动画信息 State.STEP_LAYOUT：State.STEP_LAYOUT | State.STEP_ANIMATIONS状态可以执行，执行完毕后状态变成State.STEP_ANIMATIONS。真正执行views的layout；如有必要，该步骤可能执行多次 State.STEP_ANIMATIONS：State.STEP_ANIMATIONS | State.STEP_ANIMATIONS状态可以执行，执行开始前状态变成State.STEP_START。执行第一步保存的View的动画信息 我们关注的重点显然是在dispatchLayoutStep2方法中： 12345678910111213141516171819202122232425/** * The second layout step where we do the actual layout of the views for the final state. * This step might be run multiple times if necessary (e.g. measure). */private void dispatchLayoutStep2() &#123; eatRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; // Step 2: Run layout mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); mState.mStructureChanged = false; mPendingSavedState = null; // onLayoutChildren may have caused client code to disable item animations; re-check mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; mState.mLayoutStep = State.STEP_ANIMATIONS; onExitLayoutOrScroll(); resumeRequestLayout(false);&#125; 该方法比较简单，重点在第15行的mLayout.onLayoutChildren(mRecycler, mState)方法中。这里mLayout我们选择最常用的LinearLayoutManager进行分析。LinearLayoutManager.onLayoutChildren方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/** * &#123;@inheritDoc&#125; */@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; // layout algorithm: // 1) by checking children and other variables, find an anchor coordinate and an anchor // item position. // 2) fill towards start, stacking from bottom // 3) fill towards end, stacking from top // 4) scroll to fulfill requirements like stack from bottom. // create layout state if (DEBUG) &#123; Log.d(TAG, &quot;is pre layout:&quot; + state.isPreLayout()); &#125; if (mPendingSavedState != null || mPendingScrollPosition != NO_POSITION) &#123; if (state.getItemCount() == 0) &#123; removeAndRecycleAllViews(recycler); return; &#125; &#125; if (mPendingSavedState != null &amp;&amp; mPendingSavedState.hasValidAnchor()) &#123; mPendingScrollPosition = mPendingSavedState.mAnchorPosition; &#125; ensureLayoutState(); mLayoutState.mRecycle = false; // resolve layout direction resolveShouldLayoutReverse(); final View focused = getFocusedChild(); if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) &#123; mAnchorInfo.reset(); mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; // calculate anchor position and coordinate updateAnchorInfoForLayout(recycler, state, mAnchorInfo); mAnchorInfo.mValid = true; &#125; else if (focused != null &amp;&amp; (mOrientationHelper.getDecoratedStart(focused) &gt;= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(focused) &lt;= mOrientationHelper.getStartAfterPadding())) &#123; // This case relates to when the anchor child is the focused view and due to layout // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows // up after tapping an EditText which shrinks RV causing the focused view (The tapped // EditText which is the anchor child) to get kicked out of the screen. Will update the // anchor coordinate in order to make sure that the focused view is laid out. Otherwise, // the available space in layoutState will be calculated as negative preventing the // focused view from being laid out in fill. // Note that we won&#x27;t update the anchor position between layout passes (refer to // TestResizingRelayoutWithAutoMeasure), which happens if we were to call // updateAnchorInfoForLayout for an anchor that&#x27;s not the focused view (e.g. a reference // child which can change between layout passes). mAnchorInfo.assignFromViewAndKeepVisibleRect(focused); &#125; if (DEBUG) &#123; Log.d(TAG, &quot;Anchor info:&quot; + mAnchorInfo); &#125; // LLM may decide to layout items for &quot;extra&quot; pixels to account for scrolling target, // caching or predictive animations. int extraForStart; int extraForEnd; final int extra = getExtraLayoutSpace(state); // If the previous scroll delta was less than zero, the extra space should be laid out // at the start. Otherwise, it should be at the end. if (mLayoutState.mLastScrollDelta &gt;= 0) &#123; extraForEnd = extra; extraForStart = 0; &#125; else &#123; extraForStart = extra; extraForEnd = 0; &#125; extraForStart += mOrientationHelper.getStartAfterPadding(); extraForEnd += mOrientationHelper.getEndPadding(); if (state.isPreLayout() &amp;&amp; mPendingScrollPosition != NO_POSITION &amp;&amp; mPendingScrollPositionOffset != INVALID_OFFSET) &#123; // if the child is visible and we are going to move it around, we should layout // extra items in the opposite direction to make sure new items animate nicely // instead of just fading in final View existing = findViewByPosition(mPendingScrollPosition); if (existing != null) &#123; final int current; final int upcomingOffset; if (mShouldReverseLayout) &#123; current = mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(existing); upcomingOffset = current - mPendingScrollPositionOffset; &#125; else &#123; current = mOrientationHelper.getDecoratedStart(existing) - mOrientationHelper.getStartAfterPadding(); upcomingOffset = mPendingScrollPositionOffset - current; &#125; if (upcomingOffset &gt; 0) &#123; extraForStart += upcomingOffset; &#125; else &#123; extraForEnd -= upcomingOffset; &#125; &#125; &#125; int startOffset; int endOffset; final int firstLayoutDirection; if (mAnchorInfo.mLayoutFromEnd) &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL : LayoutState.ITEM_DIRECTION_HEAD; &#125; else &#123; firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; &#125; onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); detachAndScrapAttachedViews(recycler); mLayoutState.mInfinite = resolveIsInfinite(); mLayoutState.mIsPreLayout = state.isPreLayout(); if (mAnchorInfo.mLayoutFromEnd) &#123; // fill towards start updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; final int firstElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd += mLayoutState.mAvailable; &#125; // fill towards end updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtra = extraForEnd; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) &#123; // end could not consume all. add more items towards start extraForStart = mLayoutState.mAvailable; updateLayoutStateToFillStart(firstElement, startOffset); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; &#125; &#125; else &#123; // fill towards end updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtra = extraForEnd; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; final int lastElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForStart += mLayoutState.mAvailable; &#125; // fill towards start updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtra = extraForStart; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd = mLayoutState.mAvailable; // start could not consume all it should. add more items towards end updateLayoutStateToFillEnd(lastElement, endOffset); mLayoutState.mExtra = extraForEnd; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; &#125; &#125; // changes may cause gaps on the UI, try to fix them. // TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have // changed if (getChildCount() &gt; 0) &#123; // because layout from end may be changed by scroll to position // we re-calculate it. // find which side we should check for gaps. if (mShouldReverseLayout ^ mStackFromEnd) &#123; int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true); startOffset += fixOffset; endOffset += fixOffset; fixOffset = fixLayoutStartGap(startOffset, recycler, state, false); startOffset += fixOffset; endOffset += fixOffset; &#125; else &#123; int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true); startOffset += fixOffset; endOffset += fixOffset; fixOffset = fixLayoutEndGap(endOffset, recycler, state, false); startOffset += fixOffset; endOffset += fixOffset; &#125; &#125; layoutForPredictiveAnimations(recycler, state, startOffset, endOffset); if (!state.isPreLayout()) &#123; mOrientationHelper.onLayoutComplete(); &#125; else &#123; mAnchorInfo.reset(); &#125; mLastStackFromEnd = mStackFromEnd; if (DEBUG) &#123; validateChildOrder(); &#125;&#125; 方法很长，但还好有一些注释。 首先，从开头到第112行都是第一步的内容：计算锚点坐标以及锚点item的position。谁让112行是onAnchorReady方法呢，太明显了。 注意第113行的detachAndScrapAttachedViews方法，该方法会对所有的子View调用scrapOrRecycleView方法。这样所有的子View都会暂时detach掉，并保存到mAttachedScrap或mChangedScrap或mCachedViews中，等待后续复用。 123456789101112131415161718192021222324252627282930313233 /** * Temporarily detach and scrap all currently attached child views. Views will be scrapped * into the given Recycler. The Recycler may prefer to reuse scrap views before * other views that were previously recycled. * * @param recycler Recycler to scrap views into */public void detachAndScrapAttachedViews(Recycler recycler) &#123; final int childCount = getChildCount(); for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View v = getChildAt(i); scrapOrRecycleView(recycler, i, v); &#125;&#125; private void scrapOrRecycleView(Recycler recycler, int index, View view) &#123; final ViewHolder viewHolder = getChildViewHolderInt(view); if (viewHolder.shouldIgnore()) &#123; if (DEBUG) &#123; Log.d(TAG, &quot;ignoring view &quot; + viewHolder); &#125; return; &#125; if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved() &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123; removeViewAt(index); recycler.recycleViewHolderInternal(viewHolder); &#125; else &#123; detachViewAt(index); recycler.scrapView(view); mRecyclerView.mViewInfoStore.onViewDetached(viewHolder); &#125;&#125; 前面提到过mCachedViews如果空间不足，会根据索引将里面旧的移动到RecyclerViewPool中，这样此方法的就将除了ViewCacheExtension之外的缓存全部囊括了。 根据计算的值，多次调用fill方法填充子View。显然，fill方法是新重点。该方法和ListView中的fillDown等类似，也是循环计算-填充-计算，我们直接看填充部分。填充部分调用了layoutChunk方法：该方法会首先调用LayoutState.next方法获取一个view；然后会addView，add过程中如果是detach过的，将会view重新attach到RecyclerView上，否则就是remove过了的，直接addView；最后调用measureChildWithMargins、layoutDecoratedWithMargins方法对子View进行测量、布局。layoutChunk方法代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); if (view == null) &#123; if (DEBUG &amp;&amp; layoutState.mScrapList == null) &#123; throw new RuntimeException(&quot;received null view when unexpected&quot;); &#125; // if we are laying out views in scrap, this may return null which means there is // no more items to layout. result.mFinished = true; return; &#125; LayoutParams params = (LayoutParams) view.getLayoutParams(); if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addDisappearingView(view); &#125; else &#123; addDisappearingView(view, 0); &#125; &#125; measureChildWithMargins(view, 0, 0); result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; if (mOrientation == VERTICAL) &#123; if (isLayoutRTL()) &#123; right = getWidth() - getPaddingRight(); left = right - mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; else &#123; left = getPaddingLeft(); right = left + mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; bottom = layoutState.mOffset; top = layoutState.mOffset - result.mConsumed; &#125; else &#123; top = layoutState.mOffset; bottom = layoutState.mOffset + result.mConsumed; &#125; &#125; else &#123; top = getPaddingTop(); bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view); if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; right = layoutState.mOffset; left = layoutState.mOffset - result.mConsumed; &#125; else &#123; left = layoutState.mOffset; right = layoutState.mOffset + result.mConsumed; &#125; &#125; // We calculate everything with View&#x27;s bounding box (which includes decor and margins) // To calculate correct layout position, we subtract margins. layoutDecoratedWithMargins(view, left, top, right, bottom); if (DEBUG) &#123; Log.d(TAG, &quot;laid out child at position &quot; + getPosition(view) + &quot;, with l:&quot; + (left + params.leftMargin) + &quot;, t:&quot; + (top + params.topMargin) + &quot;, r:&quot; + (right - params.rightMargin) + &quot;, b:&quot; + (bottom - params.bottomMargin)); &#125; // Consume the available space if the view is not removed OR changed if (params.isItemRemoved() || params.isItemChanged()) &#123; result.mIgnoreConsumed = true; &#125; result.mFocusable = view.hasFocusable();&#125; 很显然，缓存部分的关键就是LayoutState.next方法了： 1234567891011121314/** * Gets the view for the next element that we should layout. * Also updates current item index to the next item, based on &#123;@link #mItemDirection&#125; * * @return The next element that we should layout. */View next(RecyclerView.Recycler recycler) &#123; if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125; 我们先略过mScrapList，暂时认为其为null，后面遇到再分析。所以这里调用了RecyclerView.getViewForPosition方法： 1234567public View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125; 离真相又近了一步，tryGetViewHolderForPositionByDeadline方法里面会对各级缓存进行匹配，这里分段进行解释。 如果有mChangedScrap，尝试进行匹配 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 0) If there is a changed scrap, try to find from there&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mState.isPreLayout()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = getChangedScrapViewForPosition(position);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; fromScrapOrHiddenOrCache = holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 这里的 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;isPreLayout()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 与 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mState.mRunPredictiveAnimations&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 有直接关系，可以看成前者的值取决与后者，该值在 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatchLayoutStep1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 过程中被更新；当Item发生了更新时， &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scrapView&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 方法会将ViewHolder保存到 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mChangedScrap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 中去。 尝试从mAttachedScrap、mCachedViews中寻找匹配的ViewHolder。找到之后会对ViewHolder做一些检查，如果不满足条件，且dryRun为false（实际上就是false），会将ViewHolder清除掉并保存到mCachedViews中。在向mCachedViews中添加缓存时，如果超过了允许的上限(即mViewCacheMax)，将会把旧的缓存移动到RecycledViewPool中。 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1) Find by position from scrap/hidden list/cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!validateViewHolderForOffsetPosition(holder)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// recycle holder (and unscrap if relevant) since it can&amp;#x27;t be used&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!dryRun) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// we would like to recycle this but need to make sure it is not used by&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// animation logic etc.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder.addFlags(ViewHolder.FLAG_INVALID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder.isScrap()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; removeDetachedView(holder.itemView, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder.unScrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder.wasReturnedFromScrap()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder.clearReturnedFromScrapFlag();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; recycleViewHolderInternal(holder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; fromScrapOrHiddenOrCache = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 如果Adapter.hasStableIds()为true，会根据ItemId和ViewType在mAttachedScrap、mCachedViews中寻找ViewHolder。Adapter中该属性默认为false。 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2) Find from scrap/cache via stable ids, if exists&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mAdapter.hasStableIds()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; type, dryRun);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// update position&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder.mPosition = offsetPosition;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; fromScrapOrHiddenOrCache = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 如果存在ViewCacheExtension，调用ViewCacheExtension.getViewForPositionAndType寻找ViewHolder &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; mViewCacheExtension != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// We are NOT sending the offsetPosition because LayoutManager does not&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// know it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; View view = mViewCacheExtension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; .getViewForPositionAndType(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, position, type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (view != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = getChildViewHolder(view);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&amp;quot;getViewForPositionAndType returned&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + &lt;span class=&quot;string&quot;&gt;&amp;quot; a view which does not have a ViewHolder&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + exceptionLabel());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder.shouldIgnore()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&amp;quot;getViewForPositionAndType returned&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + &lt;span class=&quot;string&quot;&gt;&amp;quot; a view that is ignored. You must call stopIgnoring before&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + &lt;span class=&quot;string&quot;&gt;&amp;quot; returning this view.&amp;quot;&lt;/span&gt; + exceptionLabel());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; fallback到 1RecycledViewPool ，看是否有可用的ViewHolder &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// fallback to pool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (DEBUG) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&amp;quot;tryGetViewHolderForPositionByDeadline(&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; + position + &lt;span class=&quot;string&quot;&gt;&amp;quot;) fetching from shared pool&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = getRecycledViewPool().getRecycledView(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder.resetInternal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (FORCE_INVALIDATE_DISPLAY_LIST) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; invalidateDisplayListInt(holder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 以上都不满足，最后调用 1Adapter.createViewHolder 创建ViewHolder &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start = getNanoTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (deadlineNs != FOREVER_NS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;amp;&amp;amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// abort - we have a deadline we can&amp;#x27;t meet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder = mAdapter.createViewHolder(RecyclerView.&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ALLOW_THREAD_GAP_WORK) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// only bother finding nested RV if prefetching&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; RecyclerView innerView = findNestedRecyclerView(holder.itemView);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (innerView != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; holder.mNestedRecyclerView = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(innerView);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; end = getNanoTime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; mRecyclerPool.factorInCreateTime(type, end - start);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (DEBUG) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Log.d(TAG, &lt;span class=&quot;string&quot;&gt;&amp;quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; 在获取到ViewHolder之后，如果需要bind，会调用tryBindViewHolderByDeadline方法，该方法中接着调用Adapter.bindViewHolder方法交给开发者完成绑定工作。 12345678910111213boolean bound = false;if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; // do not update unless we absolutely have to. holder.mPreLayoutPosition = position;&#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; if (DEBUG &amp;&amp; holder.isRemoved()) &#123; throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot; + &quot; come here only in pre-layout. Holder: &quot; + holder + exceptionLabel()); &#125; final int offsetPosition = mAdapterHelper.findPositionOffset(position); bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);&#125; tryGetViewHolderForPositionByDeadline方法完成之后会一直返回到LinearLayoutManager.layoutChunk方法中，接着会根据ViewHolder的来源，该attach的attach，该addView的addView，最后measure并layout，一个子View的layout过程就完成了。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://blog.xusheng.online/tags/RecyclerView/"}]},{"title":"探索Android布局优化","slug":"探索Android布局优化","date":"2019-01-28T07:47:04.000Z","updated":"2020-09-13T12:40:43.732Z","comments":true,"path":"2019/01/28/探索Android布局优化/","link":"","permalink":"https://blog.xusheng.online/2019/01/28/%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/","excerpt":"","text":"布局是 Android 应用中直接影响用户体验的关键部分。不合理的布局会导致应用界面运行缓慢甚至会占用大量的内存。 1. 优化方案1.1 优化布局层次结构首先我们应当删除布局中无用的控件。无用的控件不仅占用了inflate的时间，还增加的程序的内存。 优化视图的层级，例如使用嵌套的 LinearLayout 实例会导致视图层次结构过深。LayoutInflater.inflate()在加载布局的时候会根据布局的层级递归调用rInflate()，这就导致内存占用增加。 选择性能较高的ViewGroup，例如布局中既可以使用LinearLayout也可以使用RelativeLayout，那么就采用LinearLayout。这是因为RelativeLayout的功能比LinearLayout更加复杂，它的布局过程需要话费更多的CPU时间。 合理使用LinearLayout的layout_weight 参数，因为每个它子View都需要测量两次。如果是在RecycleView或者ListView中使用时，需要特别注意。 1.2 布局复用布局的复用主要是通过&lt;include/&gt; 和 &lt;merge/&gt;来实现的。&lt;incloud&gt;虽然不会提升界面的性能(如果没有和&lt;merge&gt;一起使用甚至会增加视图的层级)，但是因为它的可重复使用为我们的开发带来了极大的便利。 &lt;incloud&gt; 1234567891011121314151617&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/app_bg&quot; android:gravity=&quot;center_horizontal&quot;&gt; &lt;include layout=&quot;@layout/common_progress_bar&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hello&quot; android:padding=&quot;10dp&quot; /&gt; ...&lt;/LinearLayout&gt; 使用&lt;incloud&gt;时除了可以为布局添加android:id外还可以修改任何 android:layout_属性，不过必须同时替换 android:layout_height 和 android:layout_width 才能让其他布局属性生效。 1.3 按需加载布局&lt;ViewStub&gt;提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，这样提高了程序的初始化效率。 ViewStub继承至View，它非常轻量级且宽高都为0，因此它本身不参与任何的布局和绘制过程。比如我们需要先从网络请求数据，然后再加载到布局中。这时候我们可以先加载&lt;ProgressBar&gt;，等数据加载到本地和后通过&lt;ViewStub&gt;显示数据内容。如： 1234567891011121314151617&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/common_loading_view&quot; android:id=&quot;@+id/loadingView&quot;/&gt; &lt;ViewStub android:inflatedId=&quot;@+id/stubView&quot; android:id=&quot;@+id/contentView&quot; android:layout=&quot;@layout/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/FrameLayout&gt; 等到需要使用ViewStub时可以按照如下方式进行： 12val view = contentView.inflate() view.contentTv.text = remoteData 一旦ViewStub调用inflate(后，ViewStub会被替换掉，此时ViewStub不再是整个布局结构的一部分了。此外，ViewStub还不 支持merge标签。 1.4 绘制优化绘制优化的分为是避免过度绘和View#onDraw()优化。 采取以下几种策略来减少甚至消除过度绘制： 移除布局中不必要的背景 减少视图层级 降低透明度 开发者模式中的一些设置可以在我们进行过渡绘制优化时提供很大的帮助，下节工具中会提到。 View#onDraw()方法优化： onDraw()不要创建新的局部对象，比如我们定义Paint的时候就不能在onDraw()中定义。 优化onDraw()的执行时间。View的绘制帧率保证60fps，即每帧的绘制时间不超过16ms（16ms = 1000/60）。 2. 布局调优工具2.1 Layout InspectorLayout Inspector可以帮我们了解布局的层级结构，用来优化布局的合理性。 当我们的程序运行在模拟器或者真机上时，可以从Tools &gt; Android &gt; Layout Inspector打开Layout Inspector验证应用的布局。 使用方法参考使用布局检查器和布局验证工具调试布局。 2.2 Debug GPU overdraw 当应用在同一帧中多次绘制同一像素的时候，便会发生过度绘制。 Android 通过颜色来确定过度绘制的次数： 默认颜色：没有过度绘制 蓝色：1次 绿色：2次 粉色：3次 红色：4次及以上 一下是Android默认设置过度绘制查看结果： 有些时候过度绘制是不可避免的(系统应用都有😭)，我们在优化过度绘制的时候应尽量尝试达到大部分显示默认颜色或仅有 1 次过度绘制（蓝色）的视觉效果。 2.3 Profile GPU RenderingProfile GPU Rendering工具可以显示前一帧所用的相对时间。 GPU 渲染模式分析工具以图表的形式显示各个阶段及其相对时间。 GPU 渲染模式分析图表中显示的每个竖条中的每个分段都表示流水线的一个阶段，并在条形图中使用特定的颜色突出显示。下表统计了渲染阶段对应的颜色及发生的原因（参考使用 GPU 渲染模式分析工具进行分析）： 颜色 渲染阶段 说明 产生原因 其它 除了渲染系统执行其工作所用的时间外的时间。 用可能包含应在其他线程上执行的回调、Intent 或其他工作。通过方法跟踪或Systrace 等工具可以查看主线程上运行的任务。 输入处理 表示应用执行输入 Event 回调中的代码所花的时间。 通常是由于输入处理程序事件回调中的工作过多或过复杂导致的。 由于这些回调总是发生在主线程上，因此该问题的解决方法主要是直接优化工作，或者将工作转移到其他线程。 动画 显示的是评估在该帧中运行的所有 Animator 所用的时间。 通常是因动画的某种属性更改而执行的工作。 测量/布局 视图层次结构中的 测量 和 布局 回调上所花的时间 通常是由于需要布局的视图数量过多，或者出现了其他问题（例如在层次结构的错误位置发生了 Double Taxation 等）。在这两种情况下，要解决性能问题，都需要改善视图层次结构的性能。 绘制 用于创建和更新视图显示列表的时间。 如果竖条的此部分很高，则表明这里可能有许多自定义视图绘制，或 onDraw 函数执行的工作很多。 同步/上传 当前帧中将位图对象从 CPU 内存传输到 GPU 内存所需的时间 帧的所有资源都必须位于 GPU 内存中才能用来绘制帧。这意味着，该指标的值较高可能表示需要加载大量小型资源或少量大型资源 发出命令 是发出将显示列表绘制到屏幕上所需的全部命令所需的时间 此阶段花费的时间直接反映了系统在给定帧中渲染的显示列表的复杂程度和数量 处理/交换缓冲区 表示 CPU 等待 GPU 完成其工作的时间 如果此竖条升高，则表示应用在 GPU 上执行太多工作。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://blog.xusheng.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Android中的线程和线程池","slug":"Android中的线程和线程池","date":"2019-01-09T12:02:21.000Z","updated":"2020-09-14T06:43:34.922Z","comments":true,"path":"2019/01/09/Android中的线程和线程池/","link":"","permalink":"https://blog.xusheng.online/2019/01/09/Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"在Android应用启动的时候，系统会为该应用创建一个”main”线程。这个线程主要负责处理与UI相关的事件，如：用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理，因此又被叫作UI线程。 如果应用执行比较耗时的操作就会阻塞住整个UI现场，所以这种单线程模式可能会导致性能低下。一旦UI线程被阻塞，线程将无法分派任何事件，此时应用会显示为挂起状态。如果UI线程被阻塞超过几秒钟时间（ 5 秒），就可能会出现“ANR”对话框。 此外Android中的UI组件并不是线程安全的，不能通过非UI线程访问UI组件。所以在进行多线程编程时有两大原则： 不要阻塞 UI 线程 不要在UI线程外访问UI组件 Android中的线程除了传统的Thread外，还包含AsyncTask、HandlerThread、IntentService等。 本文源代码基于Android 8.1。 1. AsyncTaskAsyncTask是一种轻量级的异步执行任务类，它可以在线程中执行后台任务，然后将结果返回到UI线程。 AsyncTask是一个抽象类，它有三个泛型参数。Params表示传入参数类型，Progress表示后台任务执行进度的类型，Result表示后台任务的返回结果的类型。如果AsyncTask不需要传递具体的参数，可以使用Void代替。 AsyncTask有4个核心方法，它们的含义如下所示： onPreExecute()：在异步任务执行之前调用，运行在主线程。一般用来做一些准备工作。 doInBackground(vararg Params)：用于执行异步任务，运行在工作线程。可以使用publishProgress(vararg Progress)来更新任务进度。 onProgressUpdate(vararg Progress)：当任务进度发生改变时被调用，运行在主线程。 onPostExecute(Result)：异步任务完成后被调用，运行在主线程。 下面我们就来定义一个用于下载文件的AsyncTask： 12345678910111213141516171819202122232425262728293031inner class DownloadTask : AsyncTask&lt;String, Float, Void&gt;() &#123; override fun onPreExecute() &#123; super.onPreExecute() &#125; override fun doInBackground(vararg params: String?): Void? &#123; for (i in params.indices) &#123; repository.downloadFile(params[i]) publishProgress((i * 1f) / params.size) if (isCancelled) break &#125; return null &#125; override fun onProgressUpdate(vararg values: Float?) &#123; super.onProgressUpdate(*values) updateProgress(values) &#125; override fun onPostExecute(result: Void?) &#123; super.onPostExecute(result) showDownloadSuccessDialog() &#125; override fun onCancelled() &#123; super.onCancelled() showCancelDialog() &#125;&#125; 执行异步任务的方法也很简单： 1DownloadTask().execute(&quot;url1&quot;, &quot;url2&quot;, &quot;url3&quot;) AsyncTask的工作原理 下面我们就来看看AsyncTask是怎么工作的，先从它的execute()开始： 12345678910111213141516171819202122232425262728@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; // 将传入的参数赋值给mWorker exec.execute(mFuture); // 执行任务 return this;&#125; 我们可以看到**execute()的执行线程必须是主线程**。execute()执行时调用了executeOnExecutor()，并传入了默认的sDefaultExecutor。 在executeOnExecutor判断了当前的状态，这里需要注意一个AsyncTask只能执行一次。 executeOnExecutor先调用了onPreExecute()接着执行了exec.execute(mFuture)。 接下来，先看看sDefaultExecutor是什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; // 将Runnable包装并添加到mTasks的末尾 // 这里只是添加Runnable对象，而里面的run方法现在并没有执行 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; // 当任务结束后再从mTasks取出任务执行 scheduleNext(); &#125; &#125; &#125;); // 执行下一个任务 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; // 从mTasks取出任务并执行 if ((mActive = mTasks.poll()) != null) &#123; // THREAD_POOL_EXECUTOR才是AsyncTask的执行器 THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125;// 静态 public static final Executor THREAD_POOL_EXECUTOR; static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; &#125; sDefaultExecutor的作用是将一个Runnable包装并添加到ArrayDeque&lt;Runnable&gt;，然后使用THREAD_POOL_EXECUTOR去执行Runnable。当Runnable执行完成后接着调用scheduleNext()取出下一个执行。 sDefaultExecutor就是一个串行的线程池，一个进程中所有的AsyncTask全部在这个串行线程池中排队执行。而THREAD_POOL_EXECUTOR才是AsyncTask的执行器。 接下来看看mWorker： 1234567891011121314151617181920212223242526 private final WorkerRunnable&lt;Params, Result&gt; mWorker; public AsyncTask(@Nullable Looper callbackLooper) &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); // 设置任务已经被调用 Result result = null; // 结果 try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); // 调用doInBackground执行异步任务 Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); // 设置任务被取消 throw tr; &#125; finally &#123; postResult(result); // 发送结果 &#125; return result; &#125; &#125;;... &#125; private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams; &#125; mWorker是WorkerRunnable的实例，WorkerRunnable是一个抽象类，里面只有一个mParams成员变量和一个来自Callable的接口方法call()。 在mWorker的call()方法中先设置mTaskInvoked表明任务已经被调用，然后调用doInBackground(mParams)来执行异步的任务。当任务出现异常时设置mCancelled，最后使用postResult去发送结果。 在开始的时候我们就知道doInBackground(params)是在后台执行，onPostExecute()和onCancelled()是在主线程执行。 在executeOnExecutor()中执行exec.execute(mFuture)才会将任务切换到后台线程中执行，我们来看看mFuture与mWorker直接的关系： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 private final FutureTask&lt;Result&gt; mFuture; public AsyncTask(@Nullable Looper callbackLooper) &#123; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; // 当mWorker.call()执行完后调用 // 如果任务没有被调用 // 提交结果 try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125;public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; /** * Creates a &#123;@code FutureTask&#125; that will, upon running, execute the * given &#123;@code Callable&#125;. * * @param callable the callable task * @throws NullPointerException if the callable is null */ public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; public void run() &#123; ... result = c.call(); ... set(result); ... &#125; ... &#125; FutureTask的作用是将传入的Callable在执行run的时候调用，所以mWorker中的doInBackground()也就切换到后台环境中了。 接下来看看postResult(result)和是怎么把结果发送到UI线程的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private static InternalHandler sHandler; private final Handler mHandler; public AsyncTask(@Nullable Looper callbackLooper) &#123; // 通过Looper来获取Handler对象 // 如果传入的callbackLooper为空就使用Looper.getMainLooper() mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); &#125; private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125; &#125;// 内部Handler private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result // 调用AsyncTask.finish // finish将结果返回 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: // 调用AsyncTask.onProgressUpdate result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; @WorkerThread protected final void publishProgress(Progress... values) &#123; // 利用handler发送进度 if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; private Result postResult(Result result) &#123; // 利用handler发送结果 @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 在AsyncTask里有一个内部Handler对象InternalHandler，publishProgress和postResult都是发送对应Message在InternalHandler中handleMessage()中处理，最后将结果回调给AsyncTask的方法。 AsyncTask流程总结 AsyncTask利用SerialExecutor，ThreadPoolExecutor和InternalHandler来完成任务线程的切换： 当AsyncTask开始被执行的时候调用onPreExecute()。 将AsyncTask执行的参数传给WorkerRunnable，WorkerRunnable的call方法里面会调用AsyncTask的doInBackground(mParams) 将WorkerRunnable传入FutureTask的构造方法中，FutureTask会在run方法执行的时候调用WorkerRunnable的call方法。 SerialExecutor将FutureTask加入到队列，然后使用ThreadPoolExecutor执行FutureTask。 FutureTask被执行后，WorkerRunnable里call方法就会被调用，所以doInBackground(mParams)此时运行在非UI线程来。当doInBackground(mParams)返回结果后就调用postResult()来返回结果。 postResult()使用InternalHandler发送MESSAGE_POST_RESULT消息，然后InternalHandler使用handleMessage处理这些消息。 InternalHandler根据消息的类别来调用onCancelled()、onPostExecute()和onProgressUpdate()，此时这些方法就运行在InternalHandler的线程了。 当我们手动更新进度调用publishProgress()时，也是发生MESSAGE_POST_PROGRESS，与上一步相同。 2. HandlerThreadHandlerThread继承了Thread，它里面持有Handler对象。它在HandlerThread运行的时候使用Looper.prepare()来创建线程的Looper对象，然后调用Looper.loop()开启消息循环。这样当有Message进来，就会在该线程中处理此Message。 一下是它的源码实现： 12345678910111213141516171819202122232425262728public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; protected void onLooperPrepared() &#123; // 空实现 &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); // 创建线程Looper对象 synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); // 开启消息循环 mTid = -1; &#125;&#125; 我们比较熟悉的HandlerThread使用场景是IntentService，具体分析移步到IntentService。 3. ThreadPoolExecutorThreadPoolExecutor是Java提供给我们的线程池的实现类。 线程池可以解决两个不同问题： 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能， 并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。 ThreadPoolExecutor的构造方法提供了一系列参数来配置线程池： corePoolSize：池中所保存的线程数，包括空闲线程。 maximumPoolSize：线程池中允许存在的最大线程数。 keepAliveTime：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 unit：keepAliveTime 参数的时间单位。 workQueue：执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。 一般来说，我们不会通过它的构造方法来创建线程池，而是使用工具类Executors的静态方法来获取我们要创建的线程池对象。Executors可以为我们创建四种常用的线程池： FixedThreadPool 这是一个线程数量固定、队列大小没有限制的线程池。在任何时候，线程都将会被激活以处理任务。线程池中的线程不会停止直到调用shutdown。由于FixedThreadPool只有核心线程并且这些核心线程不会被回收，这意味着它能够更快速的响应外界的请求。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; SingleThreadExecutor 这是一个单一线程、队列大小没有限制的线程池。其内部只有一个线程，可以确保所有任务都在同一个线程中按顺序执行。SingleThreadExecutor的意义在于统一外界任务到一个线程中，这使得这些任务之间不需要处理线程同步问题。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; CachedThreadPool 这是一个线程数量不定的线程池，它只有非核心线程，并且其最大线程数为Integer.MAX_VALUE。线程池中的空闲线程都有超时机制，这个超时时常为60s，超过这个时间的闲置线程就会被回收。CachedThreadPool的任务队列可以简单的理解为一个无法存储元素的队列，因此这将导致任何任务都会立刻执行。 从其特性来看，这类线程池适合执行大量耗时较少的任务。当整个线程池处理闲置状态时，线程池中的线程都会因为超时而被停止，这个时候CachedThreadPool之中实际上是没有线程的，它几乎不占用任何系统资源。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; ScheduledThreadPool 这是一个核心线程数量固定、非核心线程数量没有限制、非核心线程闲置时间10s的线程池。此类线程池主要用于执行定时任务和具有固定周期的重复任务。 1234567891011private static final long DEFAULT_KEEPALIVE_MILLIS = 10L;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125;","categories":[{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/categories/Framework/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.xusheng.online/tags/Thread/"}]},{"title":"探索Android启动优化","slug":"探索Android启动优化","date":"2018-12-27T10:59:26.000Z","updated":"2020-09-13T12:40:43.732Z","comments":true,"path":"2018/12/27/探索Android启动优化/","link":"","permalink":"https://blog.xusheng.online/2018/12/27/%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"对于客户端应用来说，启动速度是用户对于APP的第一体验。用户在使用APP时，交互最多最频繁的也就是APP启动页面。如果启动加载过慢，很可能造成用户对APP的印象过差，更有可能导致用户的卸载行为。 1. APP的启动方式 Android的启动方式分为冷启动、热启动、温启动。一般在做APP启动优化的时候都是基于冷启动的基础上。 1.1 冷启动（cold start） 冷启动是指应用从头开始启动，这时候的后台并没有该应用的进程（如APP首次启动、进程被杀等）。 在冷启动开始的时候，系统会开始创建应用进程： 加载并启动应用 在应用启动后创建应用的空白窗口 创建应用进程 系统创建完应用进程之后，应用进程就负责后续的任务： 创建应用对象（Application create） 创建主线程 创建主Activity 加载布局（inflate views） 布局屏幕（layout screen） 绘制首帧（initial draw） 应用进程完成第一次绘制后，系统进程会将掉当前显示的后台窗口替换为主Activity。这时候用户就可以开始使用应用，至此应用启动完成。 应用创建 当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么程序启动时会先出现一段时间的黑屏(白屏)。 如果有Application，系统会onCreate()在Application对象上调用该方法。之后，应用程序会生成主线程（也称为UI线程），并通过创建主要活动来执行任务。 从这一点开始，APP就按照他的应用程序生命周期阶段进行。 Activity创建 应用程序进程创建活动后，活动将执行以下操作： 初始化值。 调用构造函数。 调用回调方法，例如 Activity.onCreate()，对应Activity的当前生命周期状态。 通常，该onCreate()方法对加载时间的影响最大，因为它以最高的开销执行工作：加载和填充视图，以及初始化活动运行所需的对象。 1.2 热启动（hot start） 热启动比冷启动简单的多。系统只需要将Activity从后台切换到到前台，并不会执行应用创建等系列任务。但是在应用完成Activity绘制之前，系统进程也会显示空白窗口。 1.3 温启动（warm start） 温启动的场景有很多，它包含了在冷启动期间发生的部分操作。常见的场景有： 用户在退出应用后又重新打开冷应用。此时应用进程可能已经存在，但是应用必须通过调用onCreate()重新创建 应用被系统杀死，然后用户有重新启动了应用。此时应用进程和Activity都需要重建，但是通过onSaveInstanceState()保存的数据能够帮助恢复数据。 2. 启动时间检测 APP的启动时间是指从应用初始化到显示启动的Activity的这段时间。 2.1 通过logcat查看启动时间在 Android 4.4及更高版本中，logcat 通过 Displayed 日志来输出从启动进程到在屏幕上完成对应 Activity 的绘制所用的时间。日志的显示类似如下： 1ActivityTaskManager: Displayed [package_name]&#x2F;[activity]: +132ms 这里显示的时间包含一下事件： 1启动进程 --&gt; 初始化对象 --&gt; 创建并初始化Activity --&gt; 填充布局 --&gt; 绘制首帧 2.2 通过adb命令查看启动时间 通过手动执行adb命令来查看启动时间： 1adb shell am start -S -W [package_name]&#x2F;[activity] 查看输出结果： 1234567Starting: Intent &#123; act&#x3D;android.intent.action.MAIN cat&#x3D;[android.intent.category.LAUNCHER] cmp&#x3D;[package_name]&#x2F;[activity] &#125;Status: okLaunchState: COLD Activity: [package_name]&#x2F;[activity]TotalTime: 704WaitTime: 706Complete 2.3 完全显示所用时间（reportFullyDrawn） 在Android 4.4之后可以在Activity中手动调用reportFullyDrawn()，通知系统Activity已经完成加载。此时logcat中显示的时间为创建应用对象到手动调用``reportFullyDrawn()`的时间，输入如下： 1ActivityTaskManager: Fully drawn [package_name]&#x2F;[activity]: +1s3ms 3. 冷启动优化 当应用启动出现以下情况时，将被视作启动时间过长。为了更好的用户体验，需要对APP的启动进行优化。 冷启动用了 5 秒或更长时间。 温启动用了 2 秒或更长时间。 热启动用了 1.5 秒或更长时间。 3.1 设置启动屏幕背景 为了优化系统创建应用进程时创建的空白窗口导致启动时白屏。我们可以使用Activity的WindowBackground主题背景属性，为Activity提供默认的背景页面。 drawable布局文件： 12345678&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;item android:drawable=&quot;@android:color/white&quot;/&gt; &lt;item&gt; &lt;bitmap android:src=&quot;@drawable/logo&quot; android:gravity=&quot;center&quot;/&gt; &lt;/item&gt;&lt;/layer-list&gt; 设置启动也的样式： 123&lt;style name=&quot;AppTheme.Launcher&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/background_launcher&lt;/item&gt;&lt;/style&gt; 然后在清单文件中设置style： 12&lt;activity ...android:theme=&quot;@style/AppTheme.Launcher&quot; /&gt; 如果需要切回正常的主题，最简单的方法是先调用setTheme(R.style.AppTheme)，然后再调用 super.onCreate() 和 setContentView()： 123456class SplashActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; setTheme(R.style.R.style.AppTheme) super.onCreate(savedInstanceState) &#125;&#125; 3.2 Application create优化 一般来说，我们引用的很多第三方库都是在Application中初始化。假设Application的初始化操作有友盟，百度，bugly，数据库，IM，图片加载库，网络请求库，广告sdk，地图，推送等。这些会导致Application加载缓慢，需要异步执行。下面是简单的使用线程去初始化第三方sdk： 123456thread &#123; initUMengPush() initBadidu() initBlugy() ...&#125; 3.3 Activity create优化Activity的优化部分主要在于布局的优化，Android布局优化 3.4 使用App Startup The App Startup library provides a straightforward, performant way to initialize components at application startup. Both library developers and app developers can use App Startup to streamline startup sequences and explicitly set the order of initialization. App Startup库提供了一种直接、高效的方法在应用程序启动时初始化组件。sdk库和app的开发人员都可以使用App Startup来简化并明确设置初始化顺序。 参考：App Startup","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://blog.xusheng.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Android消息机制","slug":"Android消息机制","date":"2018-11-21T14:28:43.000Z","updated":"2020-09-13T12:40:43.722Z","comments":true,"path":"2018/11/21/Android消息机制/","link":"","permalink":"https://blog.xusheng.online/2018/11/21/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Android中的消息机制其实是指Handler的运行机制。Handler可以轻松的将一个任务切换到Handler所在的线程中运行。比如我们从获取到网络获取数据然后更新UI，由于在Android中不能在主线程中去发松网络请求，同时也不能够在子线程中去访问UI控件。这时候就可以从子线程中获取数据，然后通过Handler将更新UI的操作切换到主线程中执行。 1. 概述Android的消息机制由Handler、Message、MessageQueue和Looper四个要素组成。 Handler在创建的时候会使用当前线程的Looper来构造消息循环模型，如果当前线程中没有Looper就会抛出运行时异常： 1234567891011public Handler(@Nullable Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; ...&#125; 解决的办法就是在主线程中创建Handler，或者在子线程创建之前调用Looper.prepare()去初始化Looper。 Handler创建完成之后，Looper和MessageQueue就能与Handler一起工作了。Handler将Message发送到MessageQueue中，Looper会取出消息并交由Handler.handleMessage()处理。由于Looper运行在创建Handler的线程，这样Handler中的业务逻辑就被切换到创建Handler所在的线程中去了。 Handler.post(Runnable)最终也是通过发送Message实现的。 2. 消息机制分析2.1 ThreadLocal在执行Looper.prepare()和Looper myLooper()都会使用到ThreadLocal，所以我们需要先了解一下ThreadLocal的工作原理。 ThreadLocal是一个线程内部的数据存储类，通过它可以在各个线程中存储不同的数据。 ThreadLocal 内部维护了一个 ThreadLocalMap，ThreadLocalMap将当前线程作为key来保存我们传入的数据。我们使用ThreadLocal的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法： 1234567891011121314151617181920public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) return (T)map.get(this); // Maps are constructed lazily. if the map for this thread // doesn&#x27;t exist, create it, with this ThreadLocal and its // initial value as its only entry. T value = initialValue(); createMap(t, value); return value; &#125; 我们就不继续往下深入ThreadLocalMap了，现在回到Looper中看看它是怎样使用ThreadLocal的： 12345678910111213141516171819public final class Looper &#123; ... static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125;&#125; 这样我们使用Looper.prepare()的时候就能将Looper对象添加到当前线程中了。 2.2 MessageMessage的作用是定义一条可以被发送到Handler的消息。 Message可以通过构造方法创建，也可以通过Message.obtain()来创建。我们看看Message.obtain()创建的Message有什么不同： 12345678910111213141516171819 private static Message sPool; // 静态变量，消息池Message next;private static int sPoolSize = 0; // sPool长度计数器int flags; private static final int MAX_POOL_SIZE = 50;public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; // sPool头节点 sPool = m.next; // 将sPool后移以为 m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; // 长度减1 return m; // 返回头节点 &#125; &#125; return new Message(); &#125; Message里的sPool是一个单向链表，它的结构类似如下： 如果sPool不为空，将sPool后移一位，然后将原来的头结点m返回，同时计数减1。如果为空就新建Message。这里可以看出Message使用obtain()是可以复用Message的，所以Message的创建方式最好还是obtain()，这样可以用到缓存池里面的缓存对象。 了解了Message复用之后，我们来看看Message是怎么回收的： 1234567891011121314151617181920212223242526272829303132333435363738394041public void recycle() &#123; // 如果Message的flags是FLAG_IN_USE // 在obtain的时候已经将flags设为0了 if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return; &#125; // 执行回收操作 recycleUnchecked();&#125;boolean isInUse() &#123; return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);&#125;void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; // 清空消息中的成员变量 what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; // 将Message放入sPool头节点 sPoolSize++; // sPool长度加一 &#125; &#125;&#125; 如果Message的flags为FLAG_IN_USE，recycle()会直接返回，而不会执行recycleUnchecked()。当Message在obtain()的时候flags已经被设置为0，在执行recycle()的时候就会调用recycleUnchecked()。 recycleUnchecked()会将flags设置为FLAG_IN_USE，然后清空里面的成员属性。然后添加到sPool的头节点。 这样保证了我们在复用Message的时候拿到的是一个干净的Message。 2.3 MessageQueueMessageQueue主要有两个操作：Message的插入enqueueMessage()和Message的取出next()。 MessageQueue内部也是通过单向链表来维护Message队列的，和Message.sPool一样。 我们先来看一下插入Message的方法enqueueMessage()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; // MessageQueue在退出的时候mQuitting会被设置为true if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); // 回收Message return false; &#125; msg.markInUse(); // 标记Message msg.when = when; Message p = mMessages; boolean needWake; // 将message插入mMessages链表中 if (p == null || when == 0 || when &lt; p.when) &#123; // 将Message添加为链表的头节点 // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; // 根据when将Message插入到mMessages链表中 for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; // 跳出循环 break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; // native方法 // 唤醒阻塞状态 nativeWake(mPtr); &#125; &#125; return true;&#125; enqueueMessage()就是添加Message和唤醒阻塞线程的操作。添加Message根据传入的when来插入到链表中，这时候就能体现出链表的效率了。 接下来看一下插入Message的方法next()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; // 待处理的空闲handler数量 int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; // 下一次轮询时间 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; // 刷新挂起命令 Binder.flushPendingCommands(); &#125;// native // 如果没有消息，进入阻塞状态 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); // 返回Message return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; if (mQuitting) &#123; dispose(); return null; &#125; ... 处理空闲Handler的操作，省略 ... pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; &#125; &#125; 可以看出next()取出消息的操作是一个死循环，在循环中根据下次轮询的时间nextPollTimeoutMillis来刷新挂起。如果没有Message则从调用native方法nativePollOnce()进入阻塞状态，直到enqueueMessage()中进行唤醒。 2.4 LooperLooper在Android消息机制扮演着消息循环的角色，它会一直从MessageQueue中取出Message（假如MessageQueue没有阻塞的话）。 Looper通过调用prepare()来为当前线程创建一个Looper对象，然后调用loop()来开启消息循环。我们主要看看loop()是如何循环消息的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public final class Looper &#123; final MessageQueue mQueue; public static void loop() &#123; final Looper me = myLooper(); // 当前线程Looper对象 if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); boolean slowDeliveryDetected = false; for (;;) &#123; // 从MessageQueue中取出消息 Message msg = queue.next(); // might block if (msg == null) &#123; // 只有msg为null时才跳出循环 // MessageQueue.next方法只有在MessageQueue退出的时候才返回null // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; // Make sure the observer won&#x27;t change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; // message的handler分发消息 msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&#x27;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; // 回收消息 msg.recycleUnchecked(); &#125; &#125;&#125; Looper最重要的方法是loop()方法，只有调用了此方法消息循环系统才会真正开始运行。loop()是一个死循环，唯一跳出循环的条件是MessageQueue.next()返回null(MessageQueue只有在退出的时候才会返回null)。 上面的代码主要干了这些事： 开启一个死循环 从MessageQueue中取出消息 将消息发送给Handler的dispatchMessage() 回收消息 2.5 HandlerHandler主要用于发送消息以及处理消息。它发送消息的方法最终都会执行enqueueMessage()，其实就是调用MessageQueue.enqueueMessage()： 12345678910111213141516171819202122public class Handler &#123; final Looper mLooper; final MessageQueue mQueue; ... public Handler(@Nullable Callback callback, boolean async) &#123; mLooper &#x3D; Looper.myLooper(); mQueue &#x3D; mLooper.mQueue; ... &#125; private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target &#x3D; this; msg.workSourceUid &#x3D; ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; &#x2F;&#x2F; 使用Looper中的MessageQueue插入消息 return queue.enqueueMessage(msg, uptimeMillis); &#125; &#125; 上面的方法最后都会通过MessageQueue.enqueueMessage()向中插入新消，然后通过Looper.loop()从MessageQueue.next()中获取出来，最后由Looper传递给msg.target.dispatchMessage()来处理。这时Handler就进入了处理消息的阶段。 我们来看看dispatchMessage()是怎样把消息传入到handleMessage()中的 123456789101112131415161718192021222324252627282930313233 public Handler(@Nullable Callback callback, boolean async) &#123; mCallback = callback; ... &#125; public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) &#123; mCallback = callback; ... &#125;public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; // 如果是post(Runnable) handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ boolean handleMessage(@NonNull Message msg); &#125; Handler处理消息的过程如下： 如果Message的callback不为空，执行它的run方法 如果通过Handler的Callback不为空，执行它的handleMessage方法 如果都为空，则执行Handler的handleMessage方法 Handler的子类为了能够接受Message需要实现handleMessage方法 3. 主线程的消息循环Android的主线程就是ActivityThread，入口方法和Java程序一样也是main()。 12345678910111213141516171819202122232425262728293031 final H mH = new H();static volatile Handler sMainThreadHandler; // set once in main()public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125;final Handler getHandler() &#123; return mH; &#125; 我们可以看到在main方法中通过使用Looper.prepareMainLooper()来创建了一个Looper对象，然后调用Looper.loop()来开启循环。 在这里还创建了一个ActivityThread.H的handler，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class H extends Handler &#123; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122; public static final int DUMP_SERVICE = 123; public static final int LOW_MEMORY = 124; public static final int PROFILER_CONTROL = 127; public static final int CREATE_BACKUP_AGENT = 128; public static final int DESTROY_BACKUP_AGENT = 129; public static final int SUICIDE = 130; public static final int REMOVE_PROVIDER = 131; public static final int DISPATCH_PACKAGE_BROADCAST = 133; public static final int SCHEDULE_CRASH = 134; public static final int DUMP_HEAP = 135; public static final int DUMP_ACTIVITY = 136; public static final int SLEEPING = 137; public static final int SET_CORE_SETTINGS = 138; public static final int UPDATE_PACKAGE_COMPATIBILITY_INFO = 139; public static final int DUMP_PROVIDER = 141; public static final int UNSTABLE_PROVIDER_DIED = 142; public static final int REQUEST_ASSIST_CONTEXT_EXTRAS = 143; public static final int TRANSLUCENT_CONVERSION_COMPLETE = 144; public static final int INSTALL_PROVIDER = 145; public static final int ON_NEW_ACTIVITY_OPTIONS = 146; public static final int ENTER_ANIMATION_COMPLETE = 149; public static final int START_BINDER_TRACKING = 150; public static final int STOP_BINDER_TRACKING_AND_DUMP = 151; public static final int LOCAL_VOICE_INTERACTION_STARTED = 154; public static final int ATTACH_AGENT = 155; public static final int APPLICATION_INFO_CHANGED = 156; public static final int RUN_ISOLATED_ENTRY_POINT = 158; public static final int EXECUTE_TRANSACTION = 159; public static final int RELAUNCH_ACTIVITY = 160; public static final int PURGE_RESOURCES = 161; public void handleMessage(Message msg) &#123; ... &#125; &#125; 为什么在主线程中调用Looper.loop()不导致线程阻塞？ Looper.loop()是一个死循环，它会不断的调用MessageQueue.next()来读取MessageQueue中的消息。 next 操作是一个阻塞操作，当MessageQueue中没有消息的时候 next 方法会一直阻塞, 进而导致 loop 阻塞。我们知道nativePollOnce()是让线程阻塞，nativeWake()是用来唤醒的。那我们发送一次Message并完成处理后MessageQueue是不是就会一直阻塞呢？ Android是基于事件的，在屏幕刷新、系统广播等都会往主线程的MessageQueue中添加消息，然后通过nativeWake()唤醒线程。 实际上可以理解为, 主线程也是随时挂起, 随时被阻塞的。","categories":[],"tags":[{"name":"Handler","slug":"Handler","permalink":"https://blog.xusheng.online/tags/Handler/"}]},{"title":"探索Android中的ClassLoader","slug":"探索Android中的ClassLoader","date":"2018-11-03T15:04:32.000Z","updated":"2020-09-13T12:40:43.731Z","comments":true,"path":"2018/11/03/探索Android中的ClassLoader/","link":"","permalink":"https://blog.xusheng.online/2018/11/03/%E6%8E%A2%E7%B4%A2Android%E4%B8%AD%E7%9A%84ClassLoader/","excerpt":"","text":"对于Java程序来说，编写程序就是在编写类，运行程序就是在运行Java编译后的class文件。在程序运行时，需要将class文件加载到jvm中才可以使用，负责加载这些class文件就是Java中的ClassLoader。 1. ClassLoader的加载机制ClassLoader加载类的过程就是loadClass(String class_name, boolean resolve)的过程： 1234567891011121314151617181920212223242526272829303132333435363738public Class&lt;? loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125;protected Class&lt;? loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // First, check if the class has already been loaded Class&lt;? c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; return c;&#125;private Class&lt;? findBootstrapClassOrNull(String name)&#123; return null;&#125;protected Class&lt;? findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name);&#125; ClassLoader加载的机制就是双亲委托，当类加载器收到加载类或者资源的请求时，通常都是先委托给父类加载器，也就是说当父类加载器找不到指定的类或资源时，自身才会执行实际的类加载过程，具体的加载过程如下： 源classloader判断该class是否已加载，如果已加载，则直接返回class，反之则委托给父类加载器。 父类加载器判断是否加载过该 Class，如果已加载，则直接返回 Class，如果没有则委托给祖父类加载器。 依此类推，直到始祖类加载器（引用类加载器）。 始祖类加载器判断是否加载过该class，如果已加载则直接返回class，如果没有加载则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功就直接返回，如果载入失败则委托给始祖类的字类加载器。 始祖类加载器的字类加载同样尝试加载类class，并在失败时委托给其子类加载器 依次类推直到源类加载器 源类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则字节返回class，否则抛出ClassNotFoundException 2.1 Android中的ClassLoaderAndroid平台抛弃了传统JVM需要的.jar文件，而是采用体积更小的.dex文件。因此，Android自定义了一些ClassLoader以满足对dex加载。 PathClassLoader 提供一个简单的ClassLoader实现，该实现对本地文件系统中的文件和目录列表进行操作，但不尝试从网络中加载类。Android将此类用于其系统类加载器和应用程序类加载器。 12345678910111213141516171819public class PathClassLoader extends BaseDexClassLoader &#123; /** * 创建PathClassLoader对指定文件和目录列表进行操作的。 * @param dexPath 包含类和资源的jar / apk文件列表 * @param parent 父类加载器 */ public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; /** * 创建一个PathClassLoader对两个给定的文件和目录列表进行操作的。 * @param dexPath 包含类和资源的jar / apk文件列表 * @param librarySearchPath 包含native库的目录列表 * @param parent 父类加载器 */ public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, null, librarySearchPath, parent); &#125;&#125; 上面就是是PathClassLoader的全部代码了，我们可以看到它单纯的继承了BaseDexClassLoader，然后重写了构造方法。 DexClassLoader 从.jar和.apk文件中加载类classes.dex，可以从未安装的应用中执行代码。因此我们用它来加载插件。 1234567891011121314public class DexClassLoader extends BaseDexClassLoader &#123; /** * 用来加载包含 class.dex 的 .jar 和 .apk 文件 * * @param dexPath 包含类和资源的jar / apk文件列表 * @param optimizedDirectory 存放优化后的 dex，不建议使用此参数，并且自API 26起无效 * @param librarySearchPath 包含native库的目录列表 * @param parent 父类加载器 */ public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, null, librarySearchPath, parent); &#125;&#125; 和PathClassLoader一样，DexClassLoader也只是继承了BaseDexClassLoader。看来，只要弄清楚了BaseDexClassLoader就能理解PathClassLoader和DexClassLoader的加载机制了。 这个Demo简单的演示类如何使用DexClassLoader来加载插件。 BaseDexClassLoader 12345678910111213141516171819202122232425262728293031323334public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; this(dexPath, optimizedDirectory, librarySearchPath, parent, false); &#125; /** * @hide */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent, boolean isTrusted) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted); ... &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException( &quot;Didn&#x27;t find class \\&quot;&quot; + name + &quot;\\&quot; on path: &quot; + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c; &#125; ...&#125; 上面这段代码是BaseDexClassLoader加载类的关键代码，首先构造方法中通过创建了一个DexPathList对象，然后重写了findClass()，并使用DexPathList来加载类。 所以我们接下来进入**DexPathList**中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293final class DexPathList &#123; private static final String DEX_SUFFIX = &quot;.dex&quot;; private static final String zipSeparator = &quot;!/&quot;; private final ClassLoader definingContext; private Element[] dexElements; public DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory) &#123; this(definingContext, dexPath, librarySearchPath, optimizedDirectory, false); &#125; DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123; ... // 使用传入的文件路径来生成Element数组 this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext, isTrusted); &#125; public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123; for (Element element : dexElements) &#123; Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null; &#125; private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) &#123; Element[] elements = new Element[files.size()]; int elementsPos = 0; for (File file : files) &#123; // 遍历文件 if (file.isDirectory()) &#123; // 如果文件是一个目录 // // We support directories for looking up resources. Looking up resources in // directories is useful for running libcore tests. elements[elementsPos++] = new Element(file); &#125; else if (file.isFile()) &#123; String name = file.getName(); DexFile dex = null; ... dex = loadDexFile(file, optimizedDirectory, loader, elements); if (dex != null) &#123; elements[elementsPos++] = new Element(dex, null); &#125; ... if (dex == null) &#123; elements[elementsPos++] = new Element(file); &#125; else &#123; elements[elementsPos++] = new Element(dex, file); &#125; ... &#125; else &#123; System.logW(&quot;ClassLoader referenced unknown path: &quot; + file); &#125; &#125; ... return elements; &#125; private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory == null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125; &#125; static class Element &#123; private final File path; private final DexFile dexFile; private ClassPathURLStreamHandler urlHandler; private boolean initialized; ... public Class&lt;?&gt; findClass(String name, ClassLoader definingContext, List&lt;Throwable&gt; suppressed) &#123; return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null; &#125; &#125;&#125; 可以看到DexPathList在构造方法中将传入的参数生成一个Element数组，然后findClass()的时候遍历Element数组，使用Element#findClass()去加载类。 Element#findClass()真正调用的是dexFile.loadClassBinaryName，在DexFile中是通过native来实现类加载的。","categories":[{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/categories/Framework/"}],"tags":[{"name":"Animation","slug":"Animation","permalink":"https://blog.xusheng.online/tags/Animation/"}]},{"title":"View的工作流程","slug":"View的工作流程","date":"2018-10-16T13:21:12.000Z","updated":"2020-09-13T12:40:43.731Z","comments":true,"path":"2018/10/16/View的工作流程/","link":"","permalink":"https://blog.xusheng.online/2018/10/16/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"理解Android View的事件分发","slug":"理解Android-View的事件分发","date":"2018-09-17T00:08:47.000Z","updated":"2020-09-14T07:18:10.121Z","comments":true,"path":"2018/09/17/理解Android-View的事件分发/","link":"","permalink":"https://blog.xusheng.online/2018/09/17/%E7%90%86%E8%A7%A3Android-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/","excerpt":"","text":"1. 触摸事件的传递规则ViewGroup触摸事件的分发由三个重要的方法来共同完成： public boolean dispatchTouchEvent(MotionEvent ev)：用来进行事件的分发。如果事件能够传递给当前View，此方法一定会被调用。返回true表示此事件被处理了。 public boolean onInterceptTouchEvent(MotionEvent ev)：用来判断是否拦截此事件。返回true表示拦截此事件。 public boolean onTouchEvent(MotionEvent event)：用来处理点击事件。返回true表示处理了事件。 对于一个ViewGroup来说，点击事件产生后，其dispatchTouchEvent方法会被调用，如果其onInterceptTouchEvent返回true，表示ViewGroup要拦截该事件，其onTouchEvent就会被调用；否则，表示不拦截当前事件，点击事件就会传递给它的子元素，子元素的dispatchTouchEvent方法会被调用。如果最后点击事件传递到了View，由于View没有onInterceptTouchEvent方法，一旦有事件传递给它，其onTouchEvent就会被调用。其关系可以用伪代码来表示： 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 当一个点击事件产生后，它的传递过程如下：Activity -&gt; Window -&gt; 顶级View。顶级View再在View体系内部进行传递。 2. 事件分发的源码解析所有源码基于Android 8.1。 2.1 Activity的事件分发过程当触摸事件传递到Activity时，也是从Activity的dispatchTouchEvent方法开始。 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 当触摸事件是ACTION_DOWN时，会回调onUserInteraction方法。onUserInteraction在Activity里面是一个空实现，会在按键事件、触摸事件、轨迹球事件分发到Activity时调用。 触摸事件的具体分发是由Activity内部的Window来完成的。Window是一个抽象类，其实现类是PhoneWindow（关于Window与WindowManager会在后续章节中讲解）。 这点可以从Android 7.0以后的代码上直接看出来，具体在Activity类的attach方法中mWindow = new PhoneWindow(this, window);。 下面接着看PhoneWindow的superDispatchTouchEvent方法： 1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; PhoneWindow直接将事件委托给了DecorView处理，而DecorView是一个FrameLayout。 12345678** @hide */public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; .... public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; ....&#125; 从这里开始，事件已经传递到了顶级View，顶级View一般都是ViewGroup。 因此，点击事件在Activity中的传递由Activity的dispatchTouchEvent方法开始，Activity会将事件交给Window处理，而Window又会转手交给DecorView处理。如果DecorView里面有View处理了触摸事件，那么Activity的dispatchTouchEvent会返回true；否则，如果没有View处理点击事件，那么Activity的onTouchEvent会被调用。 2.2 顶级View的事件分发过程在开始的时候我们以伪代码的形式阐述了ViewGroup的触摸事件传递规则，现在我们看看真正的源码。ViewGroup的事件分发机制主要体现在dispatchTouchEvent方法中。这个方法太长，也比较难看，我们分段说明。 这一段说明针对ACTION_DOWN进行的重置操作： 12345678// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125; 当ACTION_DOWN事件来到时，ViewGroup会首先进行重置操作，清除touch targets以及FLAG_DISALLOW_INTERCEPT标志位。 下面这一段说明的是否要拦截点击事件： 123456789101112131415 // Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; mFirstTouchTarget在ViewGroup的子元素成功处理事件时会被赋值指向子View。因此，如果是ACTION_DOWN或者子元素成功处理时，ViewGroup才会判断是否要拦截当前事件。反之，如果不是初始的ACTION_DOWN事件且没有触摸目标，ViewGroup会继续拦截触摸事件，这样自己就会处理。 当然，FLAG_DISALLOW_INTERCEPT标志位是一个特殊情况。此标记位可以通过子View的requestDisallowInterceptTouchEvent设置。当此标记位设置后，ViewGroup无法拦截除了ACTION_DOWN之外的事件。ACTION_DOWN事件无法拦截的原因是因为ViewGroup在分发事件时会重置此标记位（见第一段代码）。因此，ACTION_DOWN事件来临时，ViewGroup总会调用onInterceptTouchEvent方法询问自己是否需要拦截。 从上面的源码分析，我们可以得出两个结论： 当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理并且不再调用它的onInterceptTouchEvent方法。也就是说，onInterceptTouchEvent不是每次事件都会被调用的，如果我们想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用 FLAG_DISALLOW_INTERCEPT这个标志的作用是让ViewGroup不再拦截事件，前提是ViewGroup不拦截ACTION_DOWN事件。FLAG_DISALLOW_INTERCEPT标记位的作用给我们提供了一个思路，当面对滑动冲突时，我们可以考虑基于该原理的内部拦截法。 下面一段代码讲述的是ViewGroup不拦截之后，事件在子View中的分发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&#x27;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125;&#125; 上面的代码配合注释也很清楚，首先从前往后遍历找到能够接受事件的View。是否能够接受事件由第50、51行的两个方法决定：子元素是否可见、是否在播放动画，点击事件的坐标是否落在子元素的区域内。如果某子元素满足这些条件，那么事件则会交给其处理。dispatchTransformedTouchEvent方法实际上调用的就是子元素的dispatchTouchEvent方法，这样触摸事件就交给子元素进行分发了。dispatchTransformedTouchEvent方法内部核心源码： 1234567891011final boolean handled;...if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent);&#125; else &#123; ... handled = child.dispatchTouchEvent(transformedEvent);&#125;...return handled; 当子元素的dispatchTouchEvent方法true，则mFirstTouchTarget会在addTouchTarget(child, idBitsToAssign)方法中完成赋值，然后跳出事件分发循环。 如果遍历所有子View都没有被合适地处理，此时ViewGroup就会自己处理点击事件。 123456// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 在前面的代码中分析过dispatchTransformedTouchEvent方法，此处第三个参数传入null，显然会调用super.dispatchTouchEvent(transformedEvent)，即View的dispatchTouchEvent方法，此时点击事件会传递给View处理。 2.3 View的事件处理过程View对点击事件的处理比较简单。因为View是叶子节点了，它没有子元素，无法向下传递事件，只能自己处理。 下面我们看看dispatchTouchEvent方法，同样View的dispatchTouchEvent方法也会判断到底要不要执行onTouchEvent： 1234567891011121314151617181920212223public boolean dispatchTouchEvent(MotionEvent event) &#123; ... boolean result = false; ... if (onFilterTouchEventForSecurity(event)) &#123; ... //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... return result;&#125; View首先会判断有没有设置OnTouchListener，若有则会先执行OnTouchListener的onTouch方法。如果onTouch方法返回true，那么onTouchEvent不会被调用。因此OnTouchListener的优先级会比onTouchEvent要高。此外，若想OnTouchListener生效，View还要处于ENABLED状态。 接着看看onTouchEvent方法，该方法也有点长，但是非常好理解，我们分为几段来阅读。 即使View处于DISABLED状态，只要其是可点击或者可长按，就能消耗事件。 12345678910if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn&#x27;t respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; 如果有TouchDelegat，则调用TouchDelegat的onTouchEvent。若代理消耗了事件，则不再继续执行。 12345if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; 当View处于可点击或者可长按时，就会消耗事件，即onTouchEvent返回true。点击事件发生在performClick方法中。PerformClick是一个封装performClick在run方法的Runnable类。 123456789101112131415161718192021222324252627if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ... if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; ... if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; ... break; ... &#125; return true; &#125; 点击事件的执行过程：View首先会判断有没有设置OnClickListener，若有则会先执行OnClickListener的onClick方法，并返回true；否则返回false。 1234567891011121314public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; ... return result; &#125; View的LONG_CLICKABLE属性默认为false；而CLICKABLE属性和具体的View有关，即可点击的View比如Button其属性为true，不可点击的比如TextView则为false。setOnClickListener以及setOnLongClickListener会将View的对应属性设为true。 12345678910111213public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l; &#125; 3. 结论 一般情况下，一个事件序列只能被一个View拦截且消耗。一旦某个View开始拦截，那么这个事件序列都只能由它来处理，且其onInterceptTouchEvent方法不会在调用。mFirstTouchTarget 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN（既onTouchEvent方法返回了false），那么同一序列中其他事件不会交给它处理，事件将重新交给它的父元素去处理，即父元素的onTouchEvent会被调用。mFirstTouchTarget 如果View只消耗ACTION_DOWN，同时当前View可以持续收到后续事件。最后除了ACTION_DOWN之外的点击事件会传递给Activity处理。对于ACTION_DOWN后面的事件，mFirstTouchTarget收到了事件，但是其不消耗，也就是返回false，这样Activity就会调用onTouchEvent方法 ViewGroup默认不拦截事件。 View没有onInterceptTouchEvent方法，事件一旦传递给View，其onTouchEvent方法就会调用 View的onTouchEvent默认会消耗事件，除非它是不可点击、不可长按的。View的longClickable默认为false，clickable要看View的类型。 View的enable属性不影响onTouchEvent的返回值。 onClick事件发生的前提是当前View必须是可点击的，并且要收到down和up事件。 事件传递总是先传递给父布局，然后在传给子布局。子布局可以通过requestDisallowInterceptTouchEvent来干预父布局的事件分发，ACTION_DOWN除外。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"TouchEvent","slug":"TouchEvent","permalink":"https://blog.xusheng.online/tags/TouchEvent/"}]},{"title":"ContentProvider","slug":"ContentProvider","date":"2018-08-09T04:18:24.000Z","updated":"2020-09-13T12:40:43.723Z","comments":true,"path":"2018/08/09/ContentProvider/","link":"","permalink":"https://blog.xusheng.online/2018/08/09/ContentProvider/","excerpt":"","text":"1. ContentProvider介绍ContentProvider可以帮助应用程序管理自身存储的数据，并提供了一种与其他应用程序共享数据的方式。它们封装数据，并提供数据安全的机制。ContentProvider是代码运行的进程与另一个进程连接数据的标准接口。实现ContentProvider有很多优点。更重要的是，你可以配置一个ContentProvider，以允许其他应用程序能够安全地访问和修改应用程序数据，如下图所示。 Android系统预置了很多ContentProvider，比如MediaProvider、CalendarProvider、ContactsProvider等。如需跨进程访问这些信息，只要通过调用ContentProvider的query、update、insert和delete方法。 而创建一个ContentProvider也很简单，只需要实现onCreate、query、update、insert、delete和getType。onCreate可以做一些初始化工作，getType用来返回一个URI请求所对应的mimeType，如果应用不关注这个，可以返回null或者”/“。剩下的四个方法对应增删改查操作。 2. ContentProvider的使用注册ContentProvider 与 Activity 和 Service 组件类似，需要在AndroidManifest中为ContentProvider注册。 1234567891011121314151617 &lt;provider android:authorities=&quot;list&quot; android:directBootAware=[&quot;true&quot; | &quot;false&quot;] android:enabled=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:grantUriPermissions=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:initOrder=&quot;integer&quot; android:label=&quot;string resource&quot; android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:permission=&quot;string&quot; android:process=&quot;string&quot; android:readPermission=&quot;string&quot; android:syncable=[&quot;true&quot; | &quot;false&quot;] android:writePermission=&quot;string&quot; &gt; . . .&lt;/provider&gt; 参考开发指南的[ &lt;provider&gt; ](信息，请参阅开发指南的 元素主题。)元素。 Content URI 为了帮助对传入的内容 URI 执行的操作，ContentProvider API 加入了便利类 UriMatcher，它会将 URI映射为整型值。这样就可以在 switch 语句中处理这些整型值，为匹配特定模式的一个或多个内容 URI 选择所需操作。 URI 模式使用以下通配符匹配内容 URI： \\*：匹配由任意长度的任何有效字符组成的字符串 #：匹配由任意长度的数字字符组成的字符串 以下代码段展示了 UriMatcher 中方法的工作方式： 123456789101112131415161718192021222324252627private val sUriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply &#123; addURI(&quot;com.example.app.provider&quot;, &quot;table3&quot;, 1) addURI(&quot;com.example.app.provider&quot;, &quot;table3/#&quot;, 2)&#125;class ExampleProvider : ContentProvider() &#123; override fun query( uri: Uri?, projection: Array&lt;out String&gt;?, selection: String?, selectionArgs: Array&lt;out String&gt;?, sortOrder: String? ): Cursor? &#123; when (sUriMatcher.match(uri)) &#123; 1 -&gt; &#123; // 匹配到 addURI(&quot;com.example.app.provider&quot;, &quot;table3&quot;, 1) &#125; 2 -&gt; &#123; // 匹配到 addURI(&quot;com.example.app.provider&quot;, &quot;table3/#&quot;, 2) &#125; else -&gt; &#123; &#125; &#125; &#125; ...&#125; 实现自定义ContentProvider ContentProvider 会处理其他应用发送的请求，从而管理对数据的访问。所有的访问最终都会调用 ContentResolver，后者接着通过调用 ContentProvider 的具体方法来获取访问权限。 ContentProvider提供了6个抽象方法，在继承ContentProvider后我们分别要对它们加以实现： query()：查询数据 insert()：插入数据 update()更新数据 delete()：删除数据 getType()返回对应的 MIME 类型。如需查看这些标准类型的完整列表，请访问 IANA MIME Media Types 网站。 onCreate()：初始化ContentProvider。执行在Application.onCreate之前。","categories":[{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/categories/Framework/"}],"tags":[{"name":"ContentProvider","slug":"ContentProvider","permalink":"https://blog.xusheng.online/tags/ContentProvider/"}]},{"title":"Broadcasts","slug":"Broadcasts","date":"2018-07-23T03:18:26.000Z","updated":"2020-09-13T12:40:43.723Z","comments":true,"path":"2018/07/23/Broadcasts/","link":"","permalink":"https://blog.xusheng.online/2018/07/23/Broadcasts/","excerpt":"","text":"Broadcasts是Android系统提供的一种组件，利用它可以接收系统的广播消息，也可以和其它应用相互收发广播消息。应用可以发送自定义广播来通知其他应用，也可以注册接收指定的广播。广播发出后，系统会自动将广播传送给注册接收这种广播的应用。 1.系统广播系统自动发出的广播，这种广播通常与系统的状态有关。 系统广播的完整列表可以在sdk文件中找到，路径为： 1ANDROID_HOME&#x2F;platforms&#x2F;android-&#123;version&#125;&#x2F;data&#x2F;broadcast_actions.txt 需要注意的是，随着Android版本的更新，系统广播也会不断的更改。当我们为新平台适配的时候也需要注意系统广播是否有变动。 2. 注册广播接收器广播接收器 Android应用的广播接收器通过集成BroadcastReceiver来实现，当接收到指定广播是会回调onReceive(Context, Intent)： 12345class MyBroadcastReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; // do receive &#125;&#125; 广播接收器的注册方式有两种：通过在AndroidManifest.xml清单文件中注册和利用context在代码中注册。 在AndroidManifest中注册 在AndroidManifest中注册广播接收器需要指定&lt;receiver&gt;，并使用&lt;intent-filter&gt;过滤广播接收器订阅的广播。 12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 通过在AndroidManifest中注册的广播接收者，应用在安装的时候注册广播接收器。然后该接收器回成为应用的一个独立入口点。意味着如果应用没有正在运行，系统可以启动应用并发送广播。 系统会创建新的 BroadcastReceiver 对象来处理它接收到的每个广播。该对象只在回调 onReceive(Context, Intent) 的时候有效。一旦从此方法返回代码，系统便会认为该组件不再活跃。 Context注册的广播接收器 在Context注册广播接收需要先创建 IntentFilter ，然后调用 registerReceiver(BroadcastReceiver, IntentFilter) 来注册： 1234val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply &#123; addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED)&#125;registerReceiver(br, filter) 通过Context注册的广播接收器回与当前Context的生命周期有关。 例如使用Activity中注册，只要 Activity 没有被销毁，就会收到广播。如果在Application中注册，只要应用在运行，您就会收到广播。 当不需要广播接收器或者Context失效的时候，需要调用 unregisterReceiver(android.content.BroadcastReceiver)来注销广播接收器。 需要注意的事项： 在广播接收器的onReceive(Context, Intent)不要进行耗时操作，最长也不要超过10秒果要避免这种情况。如果真的需要花费一定的时候来处理的时候，该调用 goAsync()或者使用 JobScheduler 从广播接收器调度 JobService。 如果只需要应用内广播，可以使用本地广播LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)。 3. 发送广播广播的消息会被封装带Intent对象中。发送广播是需要在Intent中指定应用包名并标识唯一的广播事件， 如下： 12345val intent = Intent().apply &#123; action = &quot;com.example.broadcast.MY_NOTIFICATION&quot; putExtra(&quot;data&quot;, &quot;message&quot;)&#125;sendBroadcast(intent) Android 为应用提供三种方式来发送广播： sendOrderedBroadcast(Intent, String) ：发送有序广播。该广播一次发送给一个接收器，每个接收器执行。当接收器收到广播时，可以向下传递结果，也可以完全中止广播使其不再传递给其他接收器。 接收器的运行顺序通过匹配的 intent-filter 的 android:priority 属性来控制，具有相同优先级的接收器将按随机顺序运行。 sendBroadcast(Intent) ：发送普通广播。 接收器无法从其他接收器读取结果，无法传递从广播中收到的数据，也无法中止广播。 LocalBroadcastManager.sendBroadcast ：发送本地内广播。在不需要发送跨app广播时，发送本地广播是最佳的选择。这种实现方法的效率更高（无需进行进程间通信），而且无需担心其他应用在收发的广播时带来的任何安全问题。 4. 广播的权限可以通过权限对对广播的发送器或接收器加以限制。 带权限的发送 在我们调用sendBroadcast(Intent, String) 或 sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)来发送广播的时候，可以参数来指定广播的权限。只有已经请求了标签中的权限&lt;uses-permission&gt;标签的接收器才可以接收广播。 例如，下面代码发送广播： 1sendBroadcast(Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS) 要接收此广播，接收方应用必须请求如下权限： 1&lt;uses-permission android:name&#x3D;&quot;android.permission.SEND_SMS&quot;&#x2F;&gt; 除了可以指定现有的系统权限（如 SEND_SMS）外，也可以使用自定义权限。 带权限的接收 当注册广播接收者特别申明一个权限参数时，广播方必须通过其清单中的 &lt;uses-permissions&gt; 标记请求该权限，才能向该接收器发送 广播。 假设接收广播的应用已经在AndroidManifest文件中声明了如下接收器： 12345&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:permission=&quot;android.permission.SEND_SMS&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.AIRPLANE_MODE&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 或者通过动态注册的接收器如下： 12val filter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED)registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null ) 为了能够发射广播到这些接收器，广播方必须请求下面的权限： 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 5. 注意事项使用广播时的一些注意事项： 如果只是需要发送应用内的广播，那么用LocalBroadcastManager来收发本地广播的效率会更高。 优先使用Context注册而不是在AndroidManifest中注册。 确保广播的命名空间是全局唯一的。 不要在onReceiver中进行超过10秒的操作。 通过指定权限或者不接受外部应用的广播来提高安全性。","categories":[],"tags":[]},{"title":"Service","slug":"Service","date":"2018-06-29T06:43:31.000Z","updated":"2020-09-13T12:40:43.730Z","comments":true,"path":"2018/06/29/Service/","link":"","permalink":"https://blog.xusheng.online/2018/06/29/Service/","excerpt":"","text":"Service 是一种可以在Android系统后台运行并且不需要操作界面的应用组件。 Service与线程的选择？ 如果任务只在应用程序与用户有交互的情况下产生，并且任务很占时间或者会引起阻塞，则使用线程（AsyncTask、HandlerThread等）。 如果在应用程序与用户无交互的情况下仍需处理任务，那么用Service，因为Service是在后台运行的。同时仍要注意是否需要在Service中另起线程，默认情况下Service运行在主线程。 1. Service的启动类型Service的启动类型有两种： Start启动服务 Service由其他组件通过startService()启动时，Service处于启动状态。Service启动后，其生命周期独立于启动它的组件。即使系统销毁了启动Service的组件，该Service仍然可以在后台无期限的运行。通过startService()启动的Service通常不与其他组件进行交互。Service在运行完成时通过调用stopSelf()或由其他组件调用stopService()来停止运行。 Bind绑定服务 Service由其他组件通过bindService()启动时，Service处于绑定状态。如果要与 Activity 和其他应用组件中的服务进行交互，那么应该使用bindService()。Service需通过实现 onBind() 回调方法返回 IBinder，从而定义与服务进行通信的接口。实现绑定服务有多种方法，并且此实现比启动服务更为复杂，参考Google文档绑定服务。 注意事项： 启动状态与绑定状态不是完全独立的。可以绑定到已使用 startService() 启动的服务。 无论调用多少次startService()，只需要stopService或者stopSelf一次。在同一组件中调用多从bindService()只需要调用一次unbindService()，否则调用多次bindService，必须调用多次unbindService。 2. Service的生命周期2.1 生命周期方法Service主要有四个生命周期方法：onCreate()、onStartCommand()、onBind()、onDestroy()： onCreate()：首次创建Service时，系统会通过调用此方法进行初始化设置。调用时间在onStartCommand和onBind之前。如果该Service已经处于运行状态，此方法不会调用。 onStartCommand()：当其他组件通过startService()来启动Service时，系统会调用此方法。当该方法执行时，Service会启动并在后台无期限的运行。如果实现此方法，则需要在Service工作完成后调用 stopSelf() 或 stopService() 来停止服务。onStartCommand()的返回值必须是以下三种常量之一： START_No_STICK：如果系统在 onStartCommand() 返回后终止Service，则除非有待传递的挂起 Intent，否则系统不会重建Service。 START_STICK：如果系统在 onStartCommand() 返回后终止Service，则其会重建Service并调用 onStartCommand()，但不会重新传递最后一个 Intent。 START_REDELIVER_INTENT：如果系统在 onStartCommand() 返回后终止Service，则其会重建Service，并通过传递给Service的最后一个 Intent 调用 onStartCommand()。所有挂起 Intent 均依次传递。 onBind()：当另一个组件 bindService()来启动Service时，系统 来调用此方法。在此方法的实现中，您必须通过返回 IBinder 提供一个接口，以供客户端用来与服务进行通信。 onDestory()：当Service不在使用时，系统会调用此方法。 2.2 生命周期 通过实现上述方法，可以监控Service生命周期的两种嵌套循环： 整个生命周期：从调用 onCreate() 到返回 onDestroy() 之间的这段时间。 活动生命周期：开始于对onStartCommand()或onBind()的调用。对于startService，活动生命周期与整个生命周期结束，对于bindService，活动周期在调用onUnbind()后结束。 对于已经处于启动状态的Service，再次通过startService或bindService来启动同一个Service，其onCreate不会再次调用，而是直接调用对应的onStartCommand()或者onBind()方法。 3. IntentServiceIntentService 是继承自 Service 并处理异步请求的一个类，在 IntentService 内有一个工作线程来处理耗时操作，当任务执行完后，IntentService 会自动停止。 1234567891011121314151617181920private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125;@Overridepublic void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; IntentService会执行以下操作： 创建默认的工作线程(HandlerThread)来处理Service接收到的Intent请求。 创建工作队列(ServiceHandler)，用于将 Intent 逐一传递给 onHandleIntent() 实现。 处理完所有启动请求后停止Service，不必调用 stopSelf()。 onBind()默认返回null。 提供onStartCommand()的默认实现，它将Intent发送到工作队列，然后转发到onHandleIntent()。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"Service","slug":"Service","permalink":"https://blog.xusheng.online/tags/Service/"}]},{"title":"LayoutInflater布局加载流程","slug":"LayoutInflater加载流程","date":"2018-06-08T04:01:42.000Z","updated":"2020-09-13T12:40:43.727Z","comments":true,"path":"2018/06/08/LayoutInflater加载流程/","link":"","permalink":"https://blog.xusheng.online/2018/06/08/LayoutInflater%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"LayoutInflater布局加载流程LayoutInflater的作用是将xml的布局文件实例化为对应的View对象。通常有三种方法来获取LayoutInflater： Activity.getLayoutInflater() Context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) LayoutInflater.from(context) 事实上，Activity.getLayoutInflater()最终调用的是PhoneWindow.getLayoutInflater()，PhoneWindow在构造函数中直接通过LayoutInflater.from(Context)生成LayoutInflater对象。而在LayoutInflater.from(context)中，是通过getSystemService()来返回LayoutInflater对象。 12345678public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError(&quot;LayoutInflater not found.&quot;); &#125; return LayoutInflater;&#125; 2.1 inflate流程在LayoutInflater中有多个inflate重载方法。但是最终都会调用到public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)。 1234567891011121314151617181920212223242526272829303132333435363738public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; ... View result = root; try &#123; advanceToRootNode(parser); // 将parser前进到第一个START_TAG，也就是root节点 final String name = parser.getName(); // root节点名称 ... if (TAG_MERGE.equals(name)) &#123; // 解析merge ... rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // 根据name创建View final View temp = createViewFromTag(root, name, inflaterContext, attrs); ... rInflateChildren(parser, temp, attrs, true); ... if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; ... &#125; catch (Exception e) &#123; ... &#125; finally &#123; ... &#125; return result; &#125;&#125; 根据解析到的节点名称来进行下一步操作，如果是&lt;merge&gt;调用rInflate()解析布局，否则根据节点名称来床将View，并调用rInflateChildren()来解析子布局。最后将解析到的布局加入到root或直接返回布局。 ``rInflateChildren()最终调用的还是rInflate()。rInflate()是一个递归方法，用于递归xml层次结构并实例化视图，实例化其子级，然后调用onFinishInflate()`。 1234567891011121314151617181920212223242526272829303132333435363738void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; pendingRequestFocus = true; consumeChildElements(parser); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; ...&#125; 通过上面的代码，可以发现inflater的流程如下： inflate()在一开始通过解析获取到的root节点名称，如果节点名称是merge, 通过递归调用rinflate()来创建View并加入到parent中。否则使用createViewFromTag()来创建根布局，然后调用rInflateChildren()来递归实例化子布局，并将其子布局加入到跟布局中。 2.2 createViewFromTag()createViewFromTag()这个方法的作用是使用提供的属性集合从节点名称来创建试图。它创建试图的过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041@UnsupportedAppUsage View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; ... View view = tryCreateView(parent, name, context, attrs); if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&#x27;.&#x27;)) &#123; view = onCreateView(context, parent, name, attrs); &#125; else &#123; view = createView(context, name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; ... &#125; @UnsupportedAppUsage(trackingBug = 122360734) @Nullable public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; ... View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; return view; &#125; 首先会依次调用mFactory2、mFactory和mPrivateFactory三者之一的onCreateView方法去创建一个View。如果这几个Factory都为null，会调用LayoutInflater自己的onCreateView或者createView来实例化View。 123456789101112131415161718192021222324252627282930public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); Class&lt;? extends View&gt; clazz = null; try &#123; if (constructor == null) &#123; // 缓存中不存在某View的构造方法，先new出来放缓存中 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); ... constructor = clazz.getConstructor(mConstructorSignature); sConstructorMap.put(name, constructor); &#125; else &#123; ... &#125; Object[] args = mConstructorArgs; args[1] = attrs; return constructor.newInstance(args); &#125; catch (NoSuchMethodException e) &#123; ... &#125; &#125; 通过传进来的全类名，调用newInstance来创建一个这个类的实例并返回，返回的这个实例就是我们需要的View了。 mFactory2、mFactory、mPrivateFactory这三个实现子LayoutInflate.Factory或者LayoutInflate.Factory2。自定义Factory一个十分有用的使用场景就是实现应用换肤具体查看Android-Skin-Loader。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/tags/Framework/"}]},{"title":"Activity布局的加载流程","slug":"Activity布局的加载流程","date":"2018-05-05T14:03:32.000Z","updated":"2020-09-13T12:40:43.720Z","comments":true,"path":"2018/05/05/Activity布局的加载流程/","link":"","permalink":"https://blog.xusheng.online/2018/05/05/Activity%E5%B8%83%E5%B1%80%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"在Activity中，加载布局只需要在onCreate()设置setContentView()就可以将开发者定义的视图文件加载。这其中是如何实现的呢？我们将从setContentView开始一步一步去了解Activity的视图结构以及布局加载过程。 1. 加载布局1.1 setContentView当我们开始编写一个Activity时，会调用setContentView()来加载自定义的布局xml文件，通常如下 12345override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_xxx) ...&#125; 直接进入Activity中，可以发现setContentView()有多个重载方法。但是方法内部的实现都很简单，类似如下: 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); ...&#125; getWindow()返回了一个PhoneWindow对象。PhoneWindow对象在Activity中的attach()时创建。 123456789101112131415public Window getWindow() &#123; return mWindow;&#125;final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123; ... mWindow = new PhoneWindow(this, window, activityConfigCallback); ...&#125; 1.2 PhoneWindowPhoneWindow.setContentView()方法的核心是，生成DecorView和mContentParent对象，之后将布局文件添加到mContentParent上面去： 1234567public void setContentView(int layoutResID) &#123;... installDecor(); // 创建DecorView和ContentParent ... mLayoutInflater.inflate(layoutResID, mContentParent); // 将布局填充到ContentParent ...&#125; 接下来分析installDecor(): 1234567891011121314private void installDecor() &#123; ... if (mDecor == null) &#123; mDecor = generateDecor(-1); // 生成DecorView ... &#125; else &#123; mDecor.setWindow(this); // 关联DecorView和Window &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // 生成ContentParent ... &#125;&#125; 可以看到这里生成了DecorView和ContentParent对象，接下来看看它们时如何生成的： 1234protected DecorView generateDecor(int featureId) &#123; ... return new DecorView(context, featureId, this, getAttributes());&#125; 12345678910111213141516171819protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme.... int layoutResource; int features = getLocalFeatures(); ... // 根据features设置layoutResource ... mDecor.startChanging(); mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); // 加载布局资源文件 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(&quot;Window couldn&#x27;t find content container view&quot;); &#125;... mDecor.finishChanging(); return contentParent;&#125; 在generateLayout() DecorView将根据features来选择不同的布局，然后通过onResourcesLoaded()填充。而ContentParent其实就是一个id为android.R.id.content的ViewGroup。onResourcesLoaded()的主要代码为： 12345void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; ... final View root = inflater.inflate(layoutResource, null); ...&#125; 在mContentParent生成后，PhoneWindow.setContentView()直接通过mLayoutInflater.inflate(layoutResID, mContentParent);将布局加载到其中。 1.2 视图结构由上面的代码分析，可以发现一个Activity的视图结构如下： 其中各个的职能都不同： Activity：Activity并不控制视图，它只是控制生命周期和处理事件。 Window：Window是视图的承载器，内部持有一个 DecorView。Window是一个抽象类，实际在Activity中持有的是其子类PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局。 DecorView：DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView通过不同的feature来加载不同的布局，布局中有一个id为android.R.id.content的ViewGroup用来装载Activity中加载的自定义布局。 2. 显示布局当Activity的布局加载完毕之后是如何显示在屏幕中的？当Activity创建完成之后ActivityThread调用handleResumeActivity将DecorView添加到Window中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; &#x2F;&#x2F;Part01 &#x2F;&#x2F;调用activity.onResume，把activity数据记录更新到ActivityClientRecord ActivityClientRecord r &#x3D; performResumeActivity(token, clearHide); &#x2F;&#x2F;Part02 if (r !&#x3D; null) &#123; final Activity a &#x3D; r.activity; &#x2F;&#x2F;activity.mStartedActivity是用来标记启动Activity，有没有带返回值，一般我们startActivity(intent)是否默认是startActivityForResult(intent,-1)，默认值是-1，所以这里mStartedActivity &#x3D; false boolean willBeVisible &#x3D; !a.mStartedActivity; ... &#x2F;&#x2F;mFinished标记Activity有没有结束，而r.window一开始activity并未赋值给ActivityClientRecord，所以这里为null if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window &#x3D; r.activity.getWindow(); &#x2F;&#x2F;赋值 View decor &#x3D; r.window.getDecorView(); decor.setVisibility(View.INVISIBLE);&#x2F;&#x2F;默认设置DecorView不可见 ViewManager wm &#x3D; a.getWindowManager(); WindowManager.LayoutParams l &#x3D; r.window.getAttributes(); a.mDecor &#x3D; decor; l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |&#x3D; forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded &#x3D; true; &#x2F;&#x2F;把当前的DecorView与WindowManager绑定一起 wm.addView(decor, l); &#125; ... if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor !&#x3D; null &amp;&amp; !r.hideForNow) &#123; &#x2F;&#x2F;Part03 &#x2F;&#x2F;标记当前的Activity有没有设置新的配置参数，比如现在手机是横屏的，而之后你转成竖屏，那么这里的newCofig就会被赋值，表示参数改变 if (r.newConfig !&#x3D; null) &#123; r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig !&#x3D; null) &#123; r.tmpConfig.updateFrom(r.overrideConfig); &#125; &#x2F;&#x2F;然后调用这个方法回调，表示屏幕参数发生了改变 performConfigurationChanged(r.activity, r.tmpConfig); ... WindowManager.LayoutParams l &#x3D; r.window.getAttributes(); ...&#x2F;&#x2F;改变之后update更新当前窗口的DecorView if (r.activity.mVisibleFromClient) &#123; ViewManager wm &#x3D; a.getWindowManager(); View decor &#x3D; r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; &#x2F;&#x2F;参数没改变 r.activity.mVisibleFromServer &#x3D; true; mNumVisibleActivities++; &#x2F;&#x2F;Part04 if (r.activity.mVisibleFromClient) &#123; &#x2F;&#x2F;由于前面设置了INVASIBLE，所以现在要把DecorView显示出来了 r.activity.makeVisible(); &#125; &#125; &#x2F;&#x2F;通知ActivityManagerService，Activity完成Resumed ActivityManagerNative.getDefault().activityResumed(token);&#125; 3. 总结 Activity在attach中创建一个PhoneWindow setContentView`的时候创建DecorView的对象，并将此对象作为窗口的根视图 根据主题及其样式的不同获取对应的布局文件，解析并加载至mDecorView 通过mDecorView获取id为content的帧布局contentParent，并通过LayoutInflater将Activity的布局文件解析并加载至contentParent ActivityThread在handleResumeActivity`将DecorView添加到Window中","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/tags/Framework/"}]},{"title":"Activity","slug":"Activity","date":"2018-04-18T07:15:17.000Z","updated":"2020-09-13T12:40:43.718Z","comments":true,"path":"2018/04/18/Activity/","link":"","permalink":"https://blog.xusheng.online/2018/04/18/Activity/","excerpt":"","text":"Activity类是Android应用的关键组件，而Activity的启动和组合方式是Android平台应用模型的基本组成部分。 这里主要总结了Activity的生命周期、启动模式和IntentFilter的匹配规则。 1. Activity的生命周期1.1 普通情况下的Activity生命周期正常情况下，一个Activity的启动到销毁会经历如下的生命周期： 各个生命周期方法解释如下： onCreate：第一次创建Activity时调用。这里是做一些初始化的地方，比如创建视图，数据绑定等。onCreate完成，下一个回调时onStart。 onRestart：当处于“已停止”状态的Activity即将重启时被调用。此回调后面总是跟着onStart。 onStart：Activity进入“已启动状态”，并对用户可见 onResume：表示Activity已经可见，并且出现在前台可以与用户交互。onResume回调后面总是跟着onPause回调。 onPause：当Activity失去焦点并进入“已暂停”状态时回调。 onStop：当Activity对用户不可见时回调 onDestory：Activity即将被销毁时回调。实现onDestory是为了确保在销毁Activity或包含Activity的进程时释放掉资源。 在Activity中的生命周期有三个关键的循环： 完整的生命周期：onCreate ～ onDestory 可见生命周期：onStart ～ onStop 前台生命周期：onResume ～ onPause 当Activity位于前台，并且用户点击来返回按钮，Activity会经历onPause()、onStop() 和 onDestory()回调。Activity不仅会被销毁，还会从返回堆栈中移除。 当MainActivity启动SecondActivity时，生命周期如下： 12345MainActivity: onPause()SecondActivity: onCreate()SecondActivity: onStart()SecondActivity: onResume()MainActivity: onStop() 假如SecondActivity的主题中设置windowIsTranslucent=true时，MainActivity的onStop()并不会被回调，因为它依然时可见的。 1.2 异常情况下的Activity生命周期1.2.1 配置发生了更改有很多的事件会触发配置更改，比如横竖屏之间的屏幕方向发生变化、设备语言改变等都可能会导致配置发生更改。 因为是异常情况下Activity发生的停止,此时会调用 onSaveInstanceState() 来保存Activity的状态，在Android P之前此方法会在onStop之前执行，和onPause没有时间顺序，在Android P之后则会在onStop之后执行。此时的生命周期为: 1onPause() --&gt; onSaveInstanceState() --&gt; onStop() --&gt; onDestory() 在Activity重建后系统会把Activity销毁时保存的bundle传递给onCreate()和onRestoreInstance()，此时的生命周期为: 1onCreate() --&gt; onstart() --&gt; onRetoreInstanceState() --&gt; onResume() 1.2.2 系统终止了应用进程这种情况下Activity的生命周期回调和配置改变时完全一样。 当系统资源不足时，系统会按照Activity的优先级顺序来杀死目标Activity所在的进程。Activity的优先级从高到低可以分为以下三种： 前台Activity —— 正在和用户进行交互，处于running状态 可见但非前台 —— 比如Activity弹出了一个对话框 后台Activity —— 已经执行了onStop 2. Activity的启动模式在了解Activity的启动模式之前，我们需要先去了解一下任务(Task)和返回堆栈(Back Stack)的相关概念。 任务是用户在执行某项工作时与之互动的一系列的Activity的集合。这些Activity按照每个Activity的打开顺序排列在一个返回堆栈中。当用户点击主页上的应用程序时，该应用的任务就会转到前台运行。如果该应用没有任务存在，则会创建一个新的任务，并将该应用的“MainActivity”作为堆栈的Root Activity打开。 在当前Activity启动另一个Activity时新的 Activity 将被添加到堆栈顶部并获得焦点。上一个 Activity 仍保留在堆栈中，但会停止。当 Activity 停止时，系统会保留其界面的当前状态。当用户按返回按钮时，当前 Activity 会从堆栈顶部移除，上一个 Activity 会恢复）。堆栈中的 Activity 永远不会重新排列，只会被添加和移除，在当前 Activity 启动时被添加堆栈，在用户使用返回按钮离开时从堆栈中移除。因此，返回堆栈按照“后进先出”的对象结构运作。 3.1 LaunchModeActivity有四种启动模式：Standard、SingleTop、SingleTask、SingleInstance Standard：Activity默认的启动模式，每次启动一个Activity就会在栈顶创建一个新的实例。缺点是当Activity已经处于栈顶时，再次启动Activity还会创建一个新的实例，不会复用 SIngleTop：当要启动的Activity处于栈顶直接会调用onNewIntent，否则创建新的实例 SingleTask：Activity在整个应用程序中只有一个实例。如果它已经存在于栈中，会调用onNewIntent方法，不会创建新的实例。如果该Activity所在的栈上面有其他的Activity，那么在其之上的Activity会全部出栈 SingleInstance：如果此Activity没有实例，它会创建一个新的任务栈(和启动它的Activity的taskId不同)。如果任务栈中已经有实例会调用onNewIntent，否则创建新的实例 无论 Activity 是在新任务中启动的，还是在和启动它的 Activity 相同的任务中启动，用户按返回按钮都会回到上一个 Activity。但是，如果启动了指定 singleTask 启动模式的 Activity，而后台任务中已存在该 Activity 的实例，则系统会将该后台任务整个转到前台运行。此时，返回堆栈包含了转到前台的任务中的所有 Activity，这些 Activity 都位于堆栈的顶部。 3.2 taskAffinity“亲和性”表示 Activity 倾向于属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此具有亲和性。因此，在默认情况下，同一应用中的所有 Activity 都倾向于位于同一任务。 可以使用 元素的 taskAffinity 属性修改任何给定 Activity 的亲和性。 该属性主要用在这两个方面 当被启动的Activity包含 FLAG_ACTIVITY_NEW_TASK 标记时。 默认情况下，新Activity将启动到启动它的Activity的任务栈中。但是，如果传递给startActivity()的intent包含FLAG_ACTIVITY_NEW_TASK标志，系统会查找另一个任务栈以容纳新Activity。一般情况下，这是一项新的任务栈。但是，它不一定是。如果已经存在与新Activity具有相同affinity的任务栈，则会将Activity启动到该任务栈中。如果没有，系统会创建新的任务栈。 当被启动的Activity的 allowTaskReparenting属性设置为 “true“ 时。 在这种情况下，一旦和 Activity 有亲和性的任务进入前台运行，Activity 就可从其启动的任务转移到该任务。 3.3 清除返回堆栈如果用户长时间离开Task，系统将清除任务栈中除根Activity之外的所有Activity。当用户再次返回任务栈时，仅恢复根Activity。系统会以这种方式运行，是因为在很长一段时间之后，用户可能已经放弃了之前正在做的事情，并且返回任务栈以开始新的操作。 有如下的方式可以更改该操作： alwaysRetainTaskState在一个任务栈的根Activity上将该属性设置为true，上面描述的行为就不会发生了。任务栈中所有的Activity都会保留，即使过了很长时间。 clearTaskOnLaunch在一个任务栈的根Activity上将该属性设置为true，只要用户重新回到任务栈，任务栈会清除到只有根Activity。换句话说，它与alwaysRetainTaskState相反。即使在离开任务栈片刻之后，用户也始终会返回到初始状态的任务栈。 finishOnTaskLaunch该属性与clearTaskOnLaunch类似，不同点在于该属性作用于单独的Activity上，而不是整个任务栈。它还能使包括根Activity在内的任何Activity消失。当该属性设置为true，Activity仍然是当前任务栈的一部分，如果用户离开然后返回任务栈，则它不再存在了。","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"}],"tags":[{"name":"四大组件","slug":"四大组件","permalink":"https://blog.xusheng.online/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"}]},{"title":"探索ListView缓存机制","slug":"探索ListView缓存机制","date":"2018-03-20T12:02:47.000Z","updated":"2020-09-13T12:40:43.735Z","comments":true,"path":"2018/03/20/探索ListView缓存机制/","link":"","permalink":"https://blog.xusheng.online/2018/03/20/%E6%8E%A2%E7%B4%A2ListView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"ListView是一个显示竖直并且可以滚动的View的集合。其中每个View都位于列表中的上一个View的下方。 1. ListView的使用1.1 定义ListView适配器123456789101112131415161718192021222324252627282930313233343536373839class MyAdapter(context: Context) : BaseAdapter() &#123; private val inflater = LayoutInflater.from(context) var items: List&lt;Item&gt; = emptyList() @UIThread set(value) &#123; field = value notifyDataSetChanged() &#125; override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123; val holder: ViewHolder val view: View if (convertView == null) &#123; view = inflater.inflate(R.layout.item_view, parent, false) holder = ViewHolder(view) view.tag = holder &#125; else &#123; view = convertView holder = view.tag as ViewHolder &#125; val item = getItem(position) holder.nameTv.text = item.name holder.ageTv.text = &quot;$&#123;item.age&#125;&quot; return view &#125; override fun getItem(position: Int): Item = items[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = items.size /** * 创建ViewHolder避免重复查找 */ class ViewHolder(itemView: View) &#123; val nameTv = itemView.findViewById&lt;TextView&gt;(R.layout.name_tv) val ageTv = itemView.findViewById&lt;TextView&gt;(R.layout.age_tv) &#125;&#125; 判断convertView是否为空，如果为空表示View没有被复用，需要我们自己去加载View。 这里定义一个ViewHolder用来避免重复查找，因为ViewGroup每次根据id查找View的时候都会遍历其中所有的View，者会导致性能的下降。 定义一个items数据源，当数据发送变动时通知ListView刷新列表。 2. 将适配器绑定到ListView123456val adapter = MyAdapter(context)val listView: ListView = view.findViewById(R.id.list_view)listView.adapter = adapterval items = mockItems()adapter.items = items 2. 缓存原理ListView的缓存主要是通过RecycleBin来实现的。RecycleBin的代码只有300行左右，它是AbsListView中的一个内部类。所以所有继承自AbsListView的子类，也就是ListView和GridView，都是使用这个机制。 这里先介绍RecycleBin的重要变量和方法： private View[] mActiveViews：用来缓存屏幕上可见的View private int mViewTypeCount：ListView中包含的不同类型布局的总数 ArrayList&lt;View&gt;[] mScrapViews：ListView中所有的缓存View。这是一个ArrayList数组，数组中的每一项ArrayList都对应着一种布局类型的缓存。 void fillActiveViews(int childCount, int firstActivePosition)：将ListView中的指定元素存储到mActiveViews数组当中。childCount表示要存储的View的数量，firstActivePosition表示ListView中第一个可见元素的position值。 View getActiveView(int position)：获取与指定位置相对应的View。 如果找到该View，则将从mActiveViews中移除。 void addScrapView(View scrap, int position)：于将一个废弃的View进行缓存。scrap表示需要被废弃的View，position是View在其父级中的位置。如果childView的布局类型只有一项，就直接缓存到mCurrentScrap。如果多种布局，则从mScrapViews找到相对应的废弃缓存ArrayList并缓存view。 View getScrapView(int position)：从废弃缓存中取出一个View。如果childView的布局类型只有一项，就直接从mCurrentScrap中取。如果多种布局，则从mScrapViews找到相对应的缓存ArrayList再取出view。 public void setViewTypeCount(int viewTypeCount)：设置ListView中布局类型的数量，为每种类型布局项都启用缓存。而这个数量就是mScrapViews的数组的长度。 先简单的介绍一下RecycleBin的几个重要方法，然后简单的说一下RecycleBin缓存机制的工作原理： 每当ListView中的一个View滑出屏幕时，RecycleBin都会调用addScrapView进行缓存。当有View滑入屏幕时调用getScrapView从废弃缓存中获取。 所以在override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View中的convertView就是RecycleBin缓存机制调用getScrapView()方法获取废弃已缓存的view。因为使用LayoutInflater.inflate()加载布局比较消耗资源，所以当convertView不为空时，我们就直接用convertView了，而不需要再次调用LayoutInflater的inflate()方法加载出来布局。 3. 工作原理在分析ListView之前我们先看一下ListView的结构： 可以看到ListView直接继承与AbsListView，然后AbsListView有继承子AdapterView()。它最终的父类还是View。而每一个View的工作流程都是分为三步，onMeasure()测量，接着onLayout()布局，最后onDraw()绘制。 在ListView当中，onMeasure()并没有什么特殊的地方，因为它终归是一个View，占用的空间最多并且通常也就是整个屏幕。onDraw()在ListView当中也没有什么意义，因为ListView本身并不负责绘制，而是由ListView当中的子元素来进行绘制的。我们的重点就是在onLayout()方法上。 3.1 第一次onLayoutListView在加载子项视图的时候，先判断是否有子元素、RecycleBin缓存机制中是否已经有缓存视图了。由于此时ListView是第一次加载，没有任何视图，RecycleBin中也没有任何的缓存记录，所以ListView就直接进行计算，绘制子view等等一系列操作。ListView在加载子项视图的时候，先判断是否有子元素、RecycleBin缓存机制中是否已经有缓存视图了。由于此时ListView是第一次加载，没有任何视图，RecycleBin中也没有任何的缓存记录，所以ListView就直接进行计算，绘制子view等等一系列操作。 3.2 第二次onLayout我们做一下实验的话就会发现，即使是一个再简单的View，在展示到界面上之前都会经历至少两次onMeasure()和两次onLayout()的过程。 因为在有了第一次onLayout()的过程，ListView现在已经加载好了子项视图了。所以当ListView再次判断子元素是否为空时，现在子元素不再等于0了。所以这次会进行下面这些操作： ListView首先调用RecycleBin缓存机制的fillActiveViews()方法，将第一次onLayout()已经加载好的视图全部缓存到mActiveViews中，然后再detach掉第一次所有加载好的视图。这样就解决了第二次onLayout()再次加载视图的时候，出现数据重复的问题。 巧妙的是，在接下来加载子项视图的时候，也是先判断RecycleBin缓存机制中的mActiveViews是否为空，但是因为刚才ListView已经把第一次加载好的子视图全部缓存到了mActiveViews中了，所以此时mActiveView并不空，接下来就只要把mActiveViews里面的视图全部attach到ListView上，这样ListView中所有子视图又全部显示出来了。","categories":[{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/categories/Framework/"}],"tags":[{"name":"ListView","slug":"ListView","permalink":"https://blog.xusheng.online/tags/ListView/"}]}],"categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.xusheng.online/categories/Kotlin/"},{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Jetpack","slug":"Jetpack","permalink":"https://blog.xusheng.online/categories/Jetpack/"},{"name":"日常记录","slug":"日常记录","permalink":"https://blog.xusheng.online/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"Android","slug":"Android","permalink":"https://blog.xusheng.online/categories/Android/"},{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/categories/Framework/"}],"tags":[{"name":"Startup","slug":"Startup","permalink":"https://blog.xusheng.online/tags/Startup/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://blog.xusheng.online/tags/Kotlin/"},{"name":"Coroutines","slug":"Coroutines","permalink":"https://blog.xusheng.online/tags/Coroutines/"},{"name":"Delegate","slug":"Delegate","permalink":"https://blog.xusheng.online/tags/Delegate/"},{"name":"LeakCanary","slug":"LeakCanary","permalink":"https://blog.xusheng.online/tags/LeakCanary/"},{"name":"ViewModel","slug":"ViewModel","permalink":"https://blog.xusheng.online/tags/ViewModel/"},{"name":"LiveData","slug":"LiveData","permalink":"https://blog.xusheng.online/tags/LiveData/"},{"name":"Lifecycle","slug":"Lifecycle","permalink":"https://blog.xusheng.online/tags/Lifecycle/"},{"name":"OkHttp","slug":"OkHttp","permalink":"https://blog.xusheng.online/tags/OkHttp/"},{"name":"Git","slug":"Git","permalink":"https://blog.xusheng.online/tags/Git/"},{"name":"RxJava","slug":"RxJava","permalink":"https://blog.xusheng.online/tags/RxJava/"},{"name":"源码解析","slug":"源码解析","permalink":"https://blog.xusheng.online/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://blog.xusheng.online/tags/RecyclerView/"},{"name":"性能优化","slug":"性能优化","permalink":"https://blog.xusheng.online/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.xusheng.online/tags/Thread/"},{"name":"Handler","slug":"Handler","permalink":"https://blog.xusheng.online/tags/Handler/"},{"name":"Animation","slug":"Animation","permalink":"https://blog.xusheng.online/tags/Animation/"},{"name":"TouchEvent","slug":"TouchEvent","permalink":"https://blog.xusheng.online/tags/TouchEvent/"},{"name":"ContentProvider","slug":"ContentProvider","permalink":"https://blog.xusheng.online/tags/ContentProvider/"},{"name":"Service","slug":"Service","permalink":"https://blog.xusheng.online/tags/Service/"},{"name":"Framework","slug":"Framework","permalink":"https://blog.xusheng.online/tags/Framework/"},{"name":"四大组件","slug":"四大组件","permalink":"https://blog.xusheng.online/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"},{"name":"ListView","slug":"ListView","permalink":"https://blog.xusheng.online/tags/ListView/"}]}